(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("canvas"), require("gl"));
	else if(typeof define === 'function' && define.amd)
		define(["canvas", "gl"], factory);
	else if(typeof exports === 'object')
		exports["PhotoEditorSDK"] = factory(require("canvas"), require("gl"));
	else
		root["PhotoEditorSDK"] = factory(root["canvas"], root["gl"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_17__, __WEBPACK_EXTERNAL_MODULE_28__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 106);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(169);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(168);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(32);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(32);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _primitivesStack = __webpack_require__(140);
	
	var _primitivesStack2 = _interopRequireDefault(_primitivesStack);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Base class for filters. Extendable via {@link PhotoEditorSDK.Filter#extend}
	 * @class
	 * @memberof PhotoEditorSDK
	 */
	
	var Filter = function () {
	  function Filter() {
	    var intensity = arguments.length <= 0 || arguments[0] === undefined ? 1.0 : arguments[0];
	    (0, _classCallCheck3.default)(this, Filter);
	
	    this._intensity = intensity;
	    this._stack = new _primitivesStack2.default(intensity);
	  }
	
	  /**
	   * Renders the filter
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {PhotoEditorSDK.Engine.RenderTexture}
	   * @return {Promise}
	   */
	
	
	  Filter.prototype.render = function render(sdk, renderTexture) {
	    return this._stack.render(sdk, renderTexture);
	  };
	
	  /**
	   * Sets the intensity to the given value
	   * @param {Number} intensity
	   */
	
	
	  Filter.prototype.setIntensity = function setIntensity(intensity) {
	    this._intensity = intensity;
	    this._stack.setIntensity(intensity);
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	
	  Filter.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    this._stack.setDirtyForRenderer(dirty, renderer);
	  };
	
	  /**
	   * Cleans this instance up
	   */
	
	
	  Filter.prototype.dispose = function dispose() {
	    this._stack.dispose();
	  };
	
	  return Filter;
	}();
	
	/**
	 * A unique string that identifies this filter
	 * @type {String}
	 */
	/* jshint unused: false */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	Filter.identifier = null;
	
	/**
	 * If `isIdentity` is true, this filter does not do anything and can be seen as
	 * the default filter.
	 * @type {Boolean}
	 */
	Filter.isIdentity = false;
	
	/**
	 * This string is used by the UI
	 * @type {String}
	 */
	Filter.displayName = null;
	
	/**
	 * To create an {@link PhotoEditorSDK.Filter} class of your own, call this
	 * method and provide instance properties and functions.
	 * @function
	 */
	Filter.extend = __webpack_require__(72);
	
	// Exposed classes
	Filter.PrimitivesStack = _primitivesStack2.default;
	
	exports.default = Filter;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _brightness = __webpack_require__(141);
	
	Object.defineProperty(exports, 'Brightness', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_brightness).default;
	  }
	});
	
	var _contrast = __webpack_require__(142);
	
	Object.defineProperty(exports, 'Contrast', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_contrast).default;
	  }
	});
	
	var _desaturation = __webpack_require__(143);
	
	Object.defineProperty(exports, 'Desaturation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_desaturation).default;
	  }
	});
	
	var _glow = __webpack_require__(144);
	
	Object.defineProperty(exports, 'Glow', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_glow).default;
	  }
	});
	
	var _gobblin = __webpack_require__(145);
	
	Object.defineProperty(exports, 'Gobblin', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_gobblin).default;
	  }
	});
	
	var _grayscale = __webpack_require__(146);
	
	Object.defineProperty(exports, 'Grayscale', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_grayscale).default;
	  }
	});
	
	var _lookupTable = __webpack_require__(79);
	
	Object.defineProperty(exports, 'LookupTable', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_lookupTable).default;
	  }
	});
	
	var _saturation = __webpack_require__(147);
	
	Object.defineProperty(exports, 'Saturation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_saturation).default;
	  }
	});
	
	var _softColorOverlay = __webpack_require__(148);
	
	Object.defineProperty(exports, 'SoftColorOverlay', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_softColorOverlay).default;
	  }
	});
	
	var _toneCurve = __webpack_require__(149);
	
	Object.defineProperty(exports, 'ToneCurve', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_toneCurve).default;
	  }
	});
	
	var _x = __webpack_require__(150);
	
	Object.defineProperty(exports, 'X400', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_x).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Promise = exports.Log = exports.Constants = exports.Color = exports.Configurable = exports.Utils = exports.EventEmitter = exports.Engine = exports.cancelAnimationFrame = exports.requestAnimationFrame = undefined;
	
	var _animationFrame = __webpack_require__(167);
	
	Object.defineProperty(exports, 'requestAnimationFrame', {
	  enumerable: true,
	  get: function get() {
	    return _animationFrame.requestAnimationFrame;
	  }
	});
	Object.defineProperty(exports, 'cancelAnimationFrame', {
	  enumerable: true,
	  get: function get() {
	    return _animationFrame.cancelAnimationFrame;
	  }
	});
	
	var _math = __webpack_require__(62);
	
	Object.keys(_math).forEach(function (key) {
	  if (key === "default") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _math[key];
	    }
	  });
	});
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _constants = __webpack_require__(38);
	
	var Constants = _interopRequireWildcard(_constants);
	
	var _eventEmitter = __webpack_require__(21);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _utils = __webpack_require__(22);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _configurable = __webpack_require__(31);
	
	var _configurable2 = _interopRequireDefault(_configurable);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _log = __webpack_require__(24);
	
	var _log2 = _interopRequireDefault(_log);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.Engine = _engine2.default;
	exports.EventEmitter = _eventEmitter2.default;
	exports.Utils = _utils2.default;
	exports.Configurable = _configurable2.default;
	exports.Color = _color2.default;
	exports.Constants = Constants;
	exports.Log = _log2.default;
	exports.Promise = _promise2.default;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _log = __webpack_require__(24);
	
	var _log2 = _interopRequireDefault(_log);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _matrix = __webpack_require__(73);
	
	var _matrix2 = _interopRequireDefault(_matrix);
	
	var _rectangle = __webpack_require__(74);
	
	var _rectangle2 = _interopRequireDefault(_rectangle);
	
	var _vector = __webpack_require__(23);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _eventEmitter = __webpack_require__(21);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _utils = __webpack_require__(22);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.BATCH_SIZE = 2000; /*
	                            * This file is part of PhotoEditorSDK.
	                            *
	                            * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                            * All rights reserved.
	                            *
	                            * Redistribution and use in source and binary forms, without
	                            * modification, are permitted provided that the following license agreement
	                            * is approved and a legal/financial contract was signed by the user.
	                            * The license agreement can be found under following link:
	                            *
	                            * https://www.photoeditorsdk.com/LICENSE.txt
	                            */
	
	exports.VERTEX_SIZE = 5;
	exports.VERTEX_BYTE_SIZE = exports.VERTEX_SIZE * 4;
	
	exports.Color = _color2.default;
	exports.Matrix = _matrix2.default;
	exports.Vector2 = _vector2.default;
	exports.Rectangle = _rectangle2.default;
	exports.EventEmitter = _eventEmitter2.default;
	exports.Log = _log2.default;
	exports.Utils = _utils2.default;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _canvasRenderer = __webpack_require__(97);
	
	var _canvasRenderer2 = _interopRequireDefault(_canvasRenderer);
	
	var _webglRenderer = __webpack_require__(99);
	
	var _webglRenderer2 = _interopRequireDefault(_webglRenderer);
	
	var _canvasFilterManager = __webpack_require__(42);
	
	var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);
	
	var _webglFilterManager = __webpack_require__(43);
	
	var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);
	
	var _displayObject = __webpack_require__(41);
	
	var _displayObject2 = _interopRequireDefault(_displayObject);
	
	var _container = __webpack_require__(66);
	
	var _container2 = _interopRequireDefault(_container);
	
	var _baseTexture = __webpack_require__(46);
	
	var _baseTexture2 = _interopRequireDefault(_baseTexture);
	
	var _texture = __webpack_require__(69);
	
	var _texture2 = _interopRequireDefault(_texture);
	
	var _renderTexture = __webpack_require__(102);
	
	var _renderTexture2 = _interopRequireDefault(_renderTexture);
	
	var _webglRenderTarget = __webpack_require__(30);
	
	var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);
	
	var _canvasRenderTarget = __webpack_require__(29);
	
	var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);
	
	var _sprite = __webpack_require__(101);
	
	var _sprite2 = _interopRequireDefault(_sprite);
	
	var _shaders = __webpack_require__(100);
	
	var _shaders2 = _interopRequireDefault(_shaders);
	
	var _shader = __webpack_require__(44);
	
	var _shader2 = _interopRequireDefault(_shader);
	
	var _filter = __webpack_require__(96);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _pixelArrayImage = __webpack_require__(71);
	
	var _pixelArrayImage2 = _interopRequireDefault(_pixelArrayImage);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The heart of PhotoEditorSDK. Handles all the rendering in a scene-graph fashion
	 * @namespace PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Engine = {
	  WebGLRenderer: _webglRenderer2.default,
	  CanvasRenderer: _canvasRenderer2.default,
	  WebGLFilterManager: _webglFilterManager2.default,
	  CanvasFilterManager: _canvasFilterManager2.default,
	  DisplayObject: _displayObject2.default,
	  Container: _container2.default,
	  BaseTexture: _baseTexture2.default,
	  Texture: _texture2.default,
	  RenderTexture: _renderTexture2.default,
	  WebGLRenderTarget: _webglRenderTarget2.default,
	  CanvasRenderTarget: _canvasRenderTarget2.default,
	  Sprite: _sprite2.default,
	  Shaders: _shaders2.default,
	  Shader: _shader2.default,
	  Filter: _filter2.default,
	  PixelArrayImage: _pixelArrayImage2.default,
	
	  /**
	   * If WebGL is supported, this returns a WebGLRenderer and falls back to CanvasRenderer
	   * @param  {Number} width
	   * @param  {Number} height
	   * @param  {Object} [options = {} ]
	   * @return {(PhotoEditorSDK.Engine.WebGLRenderer|PhotoEditorSDK.Engine.CanvasRenderer)}
	   */
	  autoDetectRenderer: function autoDetectRenderer(width, height) {
	    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	
	    if (_webglRenderer2.default.isSupported()) {
	      return new _webglRenderer2.default(width, height, options);
	    } else {
	      return new _canvasRenderer2.default(width, height, options);
	    }
	  }
	};
	
	exports.default = Engine;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_RESULT__;"use strict";
	
	var _typeof2 = __webpack_require__(32);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	/*!
	 * Native Promise Only
	 * v0.8.0-a (c) Kyle Simpson
	 * MIT License: http://getify.mit-license.org
	 * @license
	 */
	/* istanbul ignore next */
	(function UMD(name, context, definition) {
	  // special form of UMD for polyfilling across evironments
	  context[name] = context[name] || definition();
	  if (typeof module != "undefined" && module.exports) {
	    module.exports = context[name];
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function $AMD$() {
	      return context[name];
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})("Promise", typeof global != "undefined" ? global : undefined, function DEF() {
	  /*jshint validthis:true */
	  "use strict";
	
	  var builtInProp,
	      cycle,
	      scheduling_queue,
	      ToString = Object.prototype.toString,
	      timer = typeof setImmediate != "undefined" ? function timer(fn) {
	    return setImmediate(fn);
	  } : setTimeout;
	
	  // dammit, IE8.
	  try {
	    Object.defineProperty({}, "x", {});
	    builtInProp = function builtInProp(obj, name, val, config) {
	      return Object.defineProperty(obj, name, {
	        value: val,
	        writable: true,
	        configurable: config !== false
	      });
	    };
	  } catch (err) {
	    builtInProp = function builtInProp(obj, name, val) {
	      obj[name] = val;
	      return obj;
	    };
	  }
	
	  // Note: using a queue instead of array for efficiency
	  scheduling_queue = function Queue() {
	    var first, last, item;
	
	    function Item(fn, self) {
	      this.fn = fn;
	      this.self = self;
	      this.next = void 0;
	    }
	
	    return {
	      add: function add(fn, self) {
	        item = new Item(fn, self);
	        if (last) {
	          last.next = item;
	        } else {
	          first = item;
	        }
	        last = item;
	        item = void 0;
	      },
	      drain: function drain() {
	        var f = first;
	        first = last = cycle = void 0;
	
	        while (f) {
	          f.fn.call(f.self);
	          f = f.next;
	        }
	      }
	    };
	  }();
	
	  function schedule(fn, self) {
	    scheduling_queue.add(fn, self);
	    if (!cycle) {
	      cycle = timer(scheduling_queue.drain);
	    }
	  }
	
	  // promise duck typing
	  function isThenable(o) {
	    var _then,
	        o_type = typeof o === "undefined" ? "undefined" : (0, _typeof3.default)(o);
	
	    if (o != null && (o_type == "object" || o_type == "function")) {
	      _then = o.then;
	    }
	    return typeof _then == "function" ? _then : false;
	  }
	
	  function notify() {
	    for (var i = 0; i < this.chain.length; i++) {
	      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
	    }
	    this.chain.length = 0;
	  }
	
	  // NOTE: This is a separate function to isolate
	  // the `try..catch` so that other code can be
	  // optimized better
	  function notifyIsolated(self, cb, chain) {
	    var ret, _then;
	    try {
	      if (cb === false) {
	        chain.reject(self.msg);
	      } else {
	        if (cb === true) {
	          ret = self.msg;
	        } else {
	          ret = cb.call(void 0, self.msg);
	        }
	
	        if (ret === chain.promise) {
	          chain.reject(TypeError("Promise-chain cycle"));
	        } else if (_then = isThenable(ret)) {
	          _then.call(ret, chain.resolve, chain.reject);
	        } else {
	          chain.resolve(ret);
	        }
	      }
	    } catch (err) {
	      chain.reject(err);
	    }
	  }
	
	  function resolve(msg) {
	    var _then,
	        self = this;
	
	    // already triggered?
	    if (self.triggered) {
	      return;
	    }
	
	    self.triggered = true;
	
	    // unwrap
	    if (self.def) {
	      self = self.def;
	    }
	
	    try {
	      if (_then = isThenable(msg)) {
	        schedule(function () {
	          var def_wrapper = new MakeDefWrapper(self);
	          try {
	            _then.call(msg, function $resolve$() {
	              resolve.apply(def_wrapper, arguments);
	            }, function $reject$() {
	              reject.apply(def_wrapper, arguments);
	            });
	          } catch (err) {
	            reject.call(def_wrapper, err);
	          }
	        });
	      } else {
	        self.msg = msg;
	        self.state = 1;
	        if (self.chain.length > 0) {
	          schedule(notify, self);
	        }
	      }
	    } catch (err) {
	      reject.call(new MakeDefWrapper(self), err);
	    }
	  }
	
	  function reject(msg) {
	    var self = this;
	
	    // already triggered?
	    if (self.triggered) {
	      return;
	    }
	
	    self.triggered = true;
	
	    // unwrap
	    if (self.def) {
	      self = self.def;
	    }
	
	    self.msg = msg;
	    self.state = 2;
	    if (self.chain.length > 0) {
	      schedule(notify, self);
	    }
	  }
	
	  function iteratePromises(Constructor, arr, resolver, rejecter) {
	    for (var idx = 0; idx < arr.length; idx++) {
	      (function IIFE(idx) {
	        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
	          resolver(idx, msg);
	        }, rejecter);
	      })(idx);
	    }
	  }
	
	  function MakeDefWrapper(self) {
	    this.def = self;
	    this.triggered = false;
	  }
	
	  function MakeDef(self) {
	    this.promise = self;
	    this.state = 0;
	    this.triggered = false;
	    this.chain = [];
	    this.msg = void 0;
	  }
	
	  function Promise(executor) {
	    if (typeof executor != "function") {
	      throw TypeError("Not a function");
	    }
	
	    if (this.__NPO__ !== 0) {
	      throw TypeError("Not a promise");
	    }
	
	    // instance shadowing the inherited "brand"
	    // to signal an already "initialized" promise
	    this.__NPO__ = 1;
	
	    var def = new MakeDef(this);
	
	    this["then"] = function then(success, failure) {
	      var o = {
	        success: typeof success == "function" ? success : true,
	        failure: typeof failure == "function" ? failure : false
	      };
	      // Note: `then(..)` itself can be borrowed to be used against
	      // a different promise constructor for making the chained promise,
	      // by substituting a different `this` binding.
	      o.promise = new this.constructor(function extractChain(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	
	        o.resolve = resolve;
	        o.reject = reject;
	      });
	      def.chain.push(o);
	
	      if (def.state !== 0) {
	        schedule(notify, def);
	      }
	
	      return o.promise;
	    };
	    this["catch"] = function $catch$(failure) {
	      return this.then(void 0, failure);
	    };
	
	    try {
	      executor.call(void 0, function publicResolve(msg) {
	        resolve.call(def, msg);
	      }, function publicReject(msg) {
	        reject.call(def, msg);
	      });
	    } catch (err) {
	      reject.call(def, err);
	    }
	  }
	
	  var PromisePrototype = builtInProp({}, "constructor", Promise,
	  /*configurable=*/false);
	
	  // Note: Android 4 cannot use `Object.defineProperty(..)` here
	  Promise.prototype = PromisePrototype;
	
	  // built-in "brand" to signal an "uninitialized" promise
	  builtInProp(PromisePrototype, "__NPO__", 0,
	  /*configurable=*/false);
	
	  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
	    var Constructor = this;
	
	    // spec mandated checks
	    // note: best "isPromise" check that's practical for now
	    if (msg && (typeof msg === "undefined" ? "undefined" : (0, _typeof3.default)(msg)) == "object" && msg.__NPO__ === 1) {
	      return msg;
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      resolve(msg);
	    });
	  });
	
	  builtInProp(Promise, "reject", function Promise$reject(msg) {
	    return new this(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      reject(msg);
	    });
	  });
	
	  builtInProp(Promise, "all", function Promise$all(arr) {
	    var Constructor = this;
	
	    // spec mandated checks
	    if (ToString.call(arr) != "[object Array]") {
	      return Constructor.reject(TypeError("Not an array"));
	    }
	    if (arr.length === 0) {
	      return Constructor.resolve([]);
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      var len = arr.length,
	          msgs = Array(len),
	          count = 0;
	
	      iteratePromises(Constructor, arr, function resolver(idx, msg) {
	        msgs[idx] = msg;
	        if (++count === len) {
	          resolve(msgs);
	        }
	      }, reject);
	    });
	  });
	
	  builtInProp(Promise, "race", function Promise$race(arr) {
	    var Constructor = this;
	
	    // spec mandated checks
	    if (ToString.call(arr) != "[object Array]") {
	      return Constructor.reject(TypeError("Not an array"));
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      iteratePromises(Constructor, arr, function resolver(idx, msg) {
	        resolve(msg);
	      }, reject);
	    });
	  });
	
	  return Promise;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(61).setImmediate))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _log = __webpack_require__(24);
	
	var _log2 = _interopRequireDefault(_log);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _configurable = __webpack_require__(31);
	
	var _configurable2 = _interopRequireDefault(_configurable);
	
	var _performanceTest = __webpack_require__(75);
	
	var _performanceTest2 = _interopRequireDefault(_performanceTest);
	
	var _extend = __webpack_require__(72);
	
	var _extend2 = _interopRequireDefault(_extend);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Base class for Operations
	 * @class
	 * @alias Operation
	 * @extends PhotoEditorSDK.Configurable
	 * @memberof PhotoEditorSDK
	 */
	
	var Operation = function (_Configurable) {
	  (0, _inherits3.default)(Operation, _Configurable);
	
	  /**
	   * Creates an Operation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function Operation(sdk) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    (0, _classCallCheck3.default)(this, Operation);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options, {
	      enabled: { type: 'boolean', default: true }
	    }));
	
	    _this._sdk = sdk;
	    _this._dirtiness = {};
	
	    _this._sprite = new _engine2.default.Sprite();
	    _this._container = new _engine2.default.Container();
	    _this._container.addChild(_this._sprite);
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when options have been changed. Sets this operation to dirty.
	   * @private
	   */
	
	
	  Operation.prototype._onOptionsChange = function _onOptionsChange() {
	    this.setDirty(true);
	  };
	
	  // -------------------------------------------------------------------------- RENDERING
	
	  /**
	   * Creates and returns a render texture
	   * @param  {PhotoEditorSDK} sdk
	   * @return {PhotoEditorSDK.Engine.RenderTexture}
	   * @protected
	   */
	
	
	  Operation.prototype._getRenderTexture = function _getRenderTexture(sdk) {
	    if (!this._renderTexture) {
	      this._renderTexture = sdk.createRenderTexture();
	    }
	    return this._renderTexture;
	  };
	
	  /**
	   * Applies this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   * @abstract
	   */
	
	
	  Operation.prototype.render = function render(sdk) {
	    var _this2 = this;
	
	    if (!this.getEnabled()) {
	      return _promise2.default.resolve();
	    }
	
	    var renderer = sdk.getRenderer();
	    var promise = void 0;
	    var perf = void 0;
	    if (_log2.default.canLog('info')) {
	      perf = new _performanceTest2.default(this.constructor.name, 'Rendering');
	    }
	
	    // Handle caching
	    if (this.isDirtyForRenderer(renderer)) {
	      promise = this._render(sdk).then(function () {
	        _this2.setDirtyForRenderer(false, renderer);
	      });
	    } else {
	      _log2.default.info(this.constructor.name, 'Rendering from cache');
	      promise = this.renderCached(sdk);
	    }
	
	    return promise.then(function () {
	      if (perf) perf.stop();
	    });
	  };
	
	  /**
	   * Renders the cached version of this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   */
	
	
	  Operation.prototype.renderCached = function renderCached(sdk) {
	    var outputSprite = sdk.getSprite();
	    outputSprite.setTexture(this._getRenderTexture(sdk));
	    return _promise2.default.resolve();
	  };
	
	  /**
	   * Renders this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   * @private
	   */
	
	
	  Operation.prototype._render = function _render(sdk) {
	    var renderFn = void 0;
	    if (sdk.getRenderer() instanceof _engine2.default.WebGLRenderer) {
	      /* istanbul ignore next */
	      renderFn = this._renderWebGL.bind(this);
	    } else {
	      renderFn = this._renderCanvas.bind(this);
	    }
	
	    return renderFn(sdk);
	  };
	
	  /**
	   * Applies this operation using WebGL
	   * @param  {PhotoEditorSDK} sdk
	   * @return {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @protected
	   * @abstract
	   */
	
	
	  Operation.prototype._renderWebGL = function _renderWebGL(sdk) {
	    throw new Error('Operation#_renderWebGL is abstract and not implemented in inherited class.');
	  };
	
	  /**
	   * Applies this operation using Canvas2D
	   * @param  {PhotoEditorSDK} sdk
	   * @return {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @protected
	   * @abstract
	   */
	
	
	  Operation.prototype._renderCanvas = function _renderCanvas(sdk) {
	    throw new Error('Operation#_renderCanvas is abstract and not implemented in inherited class.');
	  };
	
	  /**
	   * Returns the dimensions that an image with the given `dimensions`
	   * would have after this operation has been applied
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Operation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
	    return dimensions.clone();
	  };
	
	  /**
	   * Resets this operation
	   */
	
	
	  Operation.prototype.reset = function reset() {
	    this._dirty = true;
	    this._glslPrograms = {};
	  };
	
	  // -------------------------------------------------------------------------- DIRTINESS
	
	  /**
	   * Checks if this operation is dirty for the given renderer
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
	   * @return {Boolean}
	   */
	
	
	  Operation.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
	    if (!(renderer.id in this._dirtiness)) {
	      this._dirtiness[renderer.id] = true;
	    }
	    return this._dirtiness[renderer.id];
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	
	  Operation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    this._dirtiness[renderer.id] = dirty;
	  };
	
	  /**
	   * Sets the dirtiness for all renderers
	   * @param {Boolean} dirty
	   */
	
	
	  Operation.prototype.setDirty = function setDirty(dirty) {
	    for (var rendererId in this._dirtiness) {
	      this.setDirtyForRenderer(dirty, { id: rendererId });
	    }
	  };
	
	  /**
	   * Disposes the RenderTexture
	   */
	
	
	  Operation.prototype.disposeRenderTexture = function disposeRenderTexture() {
	    this._renderTexture = null;
	  };
	
	  /**
	   * Disposes this operation
	   */
	
	
	  Operation.prototype.dispose = function dispose() {};
	
	  return Operation;
	}(_configurable2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 */
	/* jshint unused:false */
	/* jshint -W083 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	Operation.identifier = null;
	
	/**
	 * To create an {@link PhotoEditorSDK.Operation} class of your own, call this
	 * method and provide instance properties and functions.
	 * @function
	 */
	
	Operation.extend = _extend2.default;
	
	exports.default = Operation;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _configurable = __webpack_require__(31);
	
	var _configurable2 = _interopRequireDefault(_configurable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Base class for filter primitives.
	 * @class
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Primitive = function (_Configurable) {
	  (0, _inherits3.default)(Primitive, _Configurable);
	
	  function Primitive() {
	    (0, _classCallCheck3.default)(this, Primitive);
	    return (0, _possibleConstructorReturn3.default)(this, _Configurable.apply(this, arguments));
	  }
	
	  /**
	   * Gets called before this primitive's filter is being applied
	   */
	
	  Primitive.prototype.update = function update() {};
	
	  /**
	   * Renders the primitive
	   * @param  {Renderer} renderer
	   * @param  {WebGLTexture} inputTexture
	   * @param  {WebGLFramebuffer} outputFBO
	   * @param  {WebGLTexture} outputTexture
	   * @return {Promise}
	   */
	
	
	  Primitive.prototype.render = function render(renderer, inputTexture, outputFBO, outputTexture) {
	    if (renderer.identifier === 'webgl') {
	      this.renderWebGL(renderer, inputTexture, outputFBO, outputTexture);
	    } else {
	      this.renderCanvas(renderer);
	    }
	  };
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {CanvasRenderer} renderer
	   * @param  {WebGLTexture} inputTexture
	   * @param  {WebGLFramebuffer} outputFBO
	   * @param  {WebGLTexture} outputTexture
	   */
	  /* istanbul ignore next */
	
	
	  Primitive.prototype.renderWebGL = function renderWebGL(renderer, inputTexture, outputFBO, outputTexture) {
	    /* istanbul ignore next */
	    throw new Error('Primitive#renderWebGL is abstract and not implemented in inherited class.');
	  };
	
	  /**
	   * Renders the primitive (Canvas2D)
	   * @param  {CanvasRenderer} renderer
	   */
	
	
	  Primitive.prototype.renderCanvas = function renderCanvas(renderer) {
	    /* istanbul ignore next */
	    throw new Error('Primitive#renderCanvas is abstract and not implemented in inherited class.');
	  };
	
	  /**
	   * Returns this primitive's filter
	   * @return {PhotoEditorSDK.Engine.Filter}
	   */
	
	
	  Primitive.prototype.getFilter = function getFilter() {
	    return this._filter;
	  };
	
	  /**
	   * Cleans up this instance
	   */
	
	
	  Primitive.prototype.dispose = function dispose() {
	    if (this._filter) {
	      this._filter.dispose();
	      this._filter = null;
	    }
	  };
	
	  return Primitive;
	}(_configurable2.default); /* jshint unused: false */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	exports.default = Primitive;

/***/ },
/* 11 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(82);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * Represents a color
	 * @class
	 * @memberof PhotoEditorSDK
	 */
	
	var Color = function () {
	  /**
	   * Creates a color
	   * @param  {Number} r
	   * @param  {Number} g
	   * @param  {Number} b
	   * @param  {Number} [a = 1]
	   */
	
	  function Color(r, g, b) {
	    var a = arguments.length <= 3 || arguments[3] === undefined ? 1.0 : arguments[3];
	    (0, _classCallCheck3.default)(this, Color);
	
	    this.r = r;
	    this.g = g;
	    this.b = b;
	    this.a = a;
	  }
	
	  /**
	   * Returns an rgba() representation of this color
	   * @return {String}
	   */
	
	
	  Color.prototype.toRGBA = function toRGBA() {
	    var colors = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.a];
	    return 'rgba(' + colors.join(',') + ')';
	  };
	
	  /**
	   * Returns a hex representation of this color
	   * @return {String}
	   */
	
	
	  Color.prototype.toHex = function toHex() {
	    var components = [this._componentToHex(Math.round(this.r * 255)), this._componentToHex(Math.round(this.g * 255)), this._componentToHex(Math.round(this.b * 255))];
	    return '#' + components.join('');
	  };
	
	  /**
	   * Returns an array with 4 values (0...1)
	   * @return {Number[]}
	   */
	
	
	  Color.prototype.toGLColor = function toGLColor() {
	    return [this.r, this.g, this.b, this.a];
	  };
	
	  /**
	   * Returns an array with 3 values (0...1)
	   * @return {Number[]}
	   */
	
	
	  Color.prototype.toRGBGLColor = function toRGBGLColor() {
	    return [this.r, this.g, this.b];
	  };
	
	  /**
	   * Converts the RGB value to HSV
	   * @return {Number[]}
	   */
	
	
	  Color.prototype.toHSV = function toHSV() {
	    var max = Math.max(this.r, this.g, this.b);
	    var min = Math.min(this.r, this.g, this.b);
	    var h = void 0;
	    var s = void 0;
	    var v = max;
	    var d = max - min;
	    s = max === 0 ? 0 : d / max;
	
	    if (max === min) {
	      h = 0; // achromatic
	    } else {
	        switch (max) {
	          case this.r:
	            h = (this.g - this.b) / d;
	            if (this.g < this.b) {
	              h += 6;
	            }
	            break;
	          case this.g:
	            h = (this.b - this.r) / d + 2;
	            break;
	          case this.b:
	            h = (this.r - this.g) / d + 4;
	            break;
	        }
	        h /= 6;
	      }
	
	    return [h, s, v];
	  };
	
	  /**
	   * Creates an RGBA color from the given HSV and alpha values
	   * @param {Number} h
	   * @param {Number} s
	   * @param {Number} v
	   * @param {Number} [a = 1]
	   */
	
	
	  Color.fromHSV = function fromHSV(h, s, v) {
	    var a = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];
	    var _ref = [];
	    var r = _ref[0];
	    var g = _ref[1];
	    var b = _ref[2];
	
	
	    var i = Math.floor(h * 6);
	    var f = h * 6 - i;
	    var p = v * (1 - s);
	    var q = v * (1 - f * s);
	    var t = v * (1 - (1 - f) * s);
	
	    switch (i % 6) {
	      case 0:
	        r = v;
	        g = t;
	        b = p;
	        break;
	      case 1:
	        r = q;
	        g = v;
	        b = p;
	        break;
	      case 2:
	        r = p;
	        g = v;
	        b = t;
	        break;
	      case 3:
	        r = p;
	        g = q;
	        b = v;
	        break;
	      case 4:
	        r = t;
	        g = p;
	        b = v;
	        break;
	      case 5:
	        r = v;
	        g = p;
	        b = q;
	        break;
	    }
	
	    var color = new Color();
	    color.r = r;
	    color.g = g;
	    color.b = b;
	    color.a = a;
	    return color;
	  };
	
	  /**
	   * Returns a clone of the current color
	   * @return {PhotoEditorSDK.Color}
	   */
	
	
	  Color.prototype.clone = function clone() {
	    return new Color(this.r, this.g, this.b, this.a);
	  };
	
	  /**
	   * Checks if this color equals the given one
	   * @param  {PhotoEditorSDK.Color} color
	   * @return {Boolean}
	   */
	
	
	  Color.prototype.equals = function equals(color) {
	    return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
	  };
	
	  /**
	   * Returns the given number as hex
	   * @param  {Number} component
	   * @return {String}
	   * @private
	   */
	
	
	  Color.prototype._componentToHex = function _componentToHex(component) {
	    var hex = component.toString(16);
	    return hex.length === 1 ? '0' + hex : hex;
	  };
	
	  /**
	   * Returns the string representation of this color
	   * @returns {String}
	   */
	
	
	  Color.prototype.toString = function toString() {
	    return 'Color(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.a + ')';
	  };
	
	  /**
	   * @type {PhotoEditorSDK.Color}
	   */
	
	
	  (0, _createClass3.default)(Color, null, [{
	    key: 'TRANSPARENT',
	    get: function get() {
	      return new Color(0, 0, 0, 0);
	    }
	
	    /**
	     * @type {PhotoEditorSDK.Color}
	     */
	
	  }, {
	    key: 'WHITE',
	    get: function get() {
	      return new Color(1, 1, 1, 1);
	    }
	
	    /**
	     * @type {PhotoEditorSDK.Color}
	     */
	
	  }, {
	    key: 'BLACK',
	    get: function get() {
	      return new Color(0, 0, 0, 1);
	    }
	  }]);
	  return Color;
	}();
	
	exports.default = Color;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(33)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 14 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(25)
	  , IE8_DOM_DEFINE = __webpack_require__(86)
	  , toPrimitive    = __webpack_require__(58)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(183)
	  , defined = __webpack_require__(48);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_17__;

/***/ },
/* 18 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.3.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(15)
	  , createDesc = __webpack_require__(35);
	module.exports = __webpack_require__(13) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(56)('wks')
	  , uid        = __webpack_require__(36)
	  , Symbol     = __webpack_require__(11).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _log = __webpack_require__(24);
	
	var _log2 = _interopRequireDefault(_log);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var DEFAULT_MAX_LISTENERS = 12;
	
	/**
	 * Receives and emits events
	 * @class
	 * @memberof PhotoEditorSDK
	 * @ignore
	 */
	/**
	 * EventEmitter (ES6) from:
	 * https://gist.github.com/bloodyowl/41b1de3388c626796eca
	 */
	
	var EventEmitter = function () {
	  /**
	   * Creates an EventEmitter
	   */
	
	  function EventEmitter() {
	    (0, _classCallCheck3.default)(this, EventEmitter);
	
	    this._maxListeners = DEFAULT_MAX_LISTENERS;
	    this._events = {};
	    this._pipeDestinations = [];
	  }
	
	  /**
	   * Pipes all events to the given EventEmitter
	   * @param  {EventEmitter} destination
	   */
	
	
	  EventEmitter.prototype.pipeEvents = function pipeEvents(destination) {
	    this._pipeDestinations.push(destination);
	  };
	
	  /**
	   * Stops piping events to the given EventEmitter
	   * @param  {EventEmitter} destination
	   */
	
	
	  EventEmitter.prototype.unpipeEvents = function unpipeEvents(destination) {
	    var i = this._pipeDestinations.indexOf(destination);
	    if (i === -1) {
	      return;
	    }
	    this._pipeDestinations.splice(i, 1);
	  };
	
	  /**
	   * Adds the given listener to the given type of events
	   * @param  {String} type
	   * @param  {Function} listener
	   */
	
	
	  EventEmitter.prototype.on = function on(type, listener) {
	    if (typeof listener !== 'function') {
	      throw new TypeError();
	    }
	
	    var listeners = this._events[type] || (this._events[type] = []);
	    if (listeners.indexOf(listener) !== -1) {
	      return this;
	    }
	    listeners.push(listener);
	
	    if (listeners.length > this._maxListeners) {
	      _log2.default.warn('EventEmitter', 'Possible memory leak detected, added ' + listeners.length + ' `' + type + '` listeners (current limit is ' + this._maxListeners + ')');
	      console.trace();
	    }
	    return this;
	  };
	
	  /**
	   * Adds the given listener to the given type of events and removes it
	   * once it has been triggered
	   * @param  {String} type
	   * @param  {Function} listener
	   */
	
	
	  EventEmitter.prototype.once = function once(type, listener) {
	    var eventsInstance = this;
	    function onceCallback() {
	      eventsInstance.off(type, onceCallback);
	      listener.apply(null, arguments);
	    }
	    return this.on(type, onceCallback);
	  };
	
	  /**
	   * Removes the given listener from the given type of events
	   * @param  {String} type
	   * @param  {*} ...args
	   */
	
	
	  EventEmitter.prototype.off = function off(type) {
	    if (arguments.length - 1 === 0) {
	      this._events[type] = null;
	      return this;
	    }
	
	    var listener = arguments.length <= 1 ? undefined : arguments[1];
	    if (typeof listener !== 'function') {
	      throw new TypeError();
	    }
	
	    var listeners = this._events[type];
	    if (!listeners || !listeners.length) {
	      return this;
	    }
	
	    var indexOfListener = listeners.indexOf(listener);
	    if (indexOfListener === -1) {
	      return this;
	    }
	
	    listeners.splice(indexOfListener, 1);
	    return this;
	  };
	
	  /**
	   * Emits an event with the given type and arguments
	   * @param  {String} type
	   * @param  {*} ...args
	   */
	
	
	  EventEmitter.prototype.emit = function emit(type) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    this._pipeDestinations.forEach(function (dest) {
	      dest.emit.apply(dest, [type].concat(args));
	    });
	
	    var listeners = this._events[type];
	    if (!listeners || !listeners.length) {
	      return false;
	    }
	
	    listeners.forEach(function (fn) {
	      return fn.apply(null, args);
	    });
	
	    return true;
	  };
	
	  /**
	   * Sets the maximum amonut of listeners before a warning is printed
	   * @param {Number} newMaxListeners
	   */
	
	
	  EventEmitter.prototype.setMaxListeners = function setMaxListeners(newMaxListeners) {
	    if (parseInt(newMaxListeners, 10) !== newMaxListeners) {
	      throw new TypeError();
	    }
	
	    this._maxListeners = newMaxListeners;
	  };
	
	  return EventEmitter;
	}();
	
	exports.default = EventEmitter;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof2 = __webpack_require__(32);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _base = __webpack_require__(39);
	
	var _base2 = _interopRequireDefault(_base);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Provides utility functions for internal use
	 * @class
	 * @memberof PhotoEditorSDK
	 * @private
	 */
	
	var Utils = function () {
	  function Utils() {
	    (0, _classCallCheck3.default)(this, Utils);
	  }
	
	  /**
	   * Checks if the given object is an Array
	   * @param  {Object}  object
	   * @return {Boolean}
	   */
	
	  Utils.isArray = function isArray(object) {
	    return Object.prototype.toString.call(object) === '[object Array]';
	  };
	
	  /**
	   * Returns the given object's values as an array
	   * @param {Object} object
	   * @returns {Array<*>}
	   */
	
	
	  Utils.values = function values(object) {
	    var values = [];
	    for (var key in object) {
	      values.push(object[key]);
	    }
	    return values;
	  };
	
	  /**
	   * Checks if the given object is a DOM element
	   * @param  {Object}  o
	   * @return {Boolean}
	   */
	  /* istanbul ignore next */
	
	
	  Utils.isDOMElement = function isDOMElement(o) {
	    return (typeof HTMLElement === 'undefined' ? 'undefined' : (0, _typeof3.default)(HTMLElement)) === 'object' ? o instanceof HTMLElement : o && (typeof o === 'undefined' ? 'undefined' : (0, _typeof3.default)(o)) === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
	  };
	
	  /**
	   * Checks if th given event is a touch event
	   * @param  {Event}  e
	   * @return {Boolean}
	   */
	
	
	  Utils.isTouchEvent = function isTouchEvent(e) {
	    return e.type.indexOf('touch') !== -1;
	  };
	
	  /**
	   * Resizes the given vector to fit inside the given max size while maintaining
	   * the aspect ratio
	   * @param  {Vector2} vector
	   * @param  {Vector2} max
	   * @return {Vector2}
	   */
	
	
	  Utils.resizeVectorToFit = function resizeVectorToFit(vector, max) {
	    var scale = Math.min(max.x / vector.x, max.y / vector.y);
	    var newSize = vector.clone().multiply(scale);
	    return newSize;
	  };
	
	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object for all destination properties that resolve to undefined. Once a
	   * property is set, additional values of the same property are ignored.
	   * @param  {Object} object
	   * @param  {Object} ...sources
	   * @return {Object}
	   */
	
	
	  Utils.defaults = function defaults(object) {
	    // Shallow clone
	    var newObject = {};
	    for (var key in object) {
	      newObject[key] = object[key];
	    }
	
	    // Clone sources
	
	    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      sources[_key - 1] = arguments[_key];
	    }
	
	    for (var i = 0; i < sources.length; i++) {
	      var source = sources[i];
	      for (var _key2 in source) {
	        if (typeof newObject[_key2] === 'undefined') {
	          newObject[_key2] = source[_key2];
	        }
	      }
	    }
	
	    return newObject;
	  };
	
	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object. Subsequent sources overwrite property assignments of previous
	   * sources.
	   * @param {Object} object
	   * @param {Object} ...sources
	   * @return {Object}
	   */
	
	
	  Utils.extend = function extend(object) {
	    // Shallow clone
	    var newObject = {};
	    for (var key in object) {
	      newObject[key] = object[key];
	    }
	
	    // Extend sources
	
	    for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	      sources[_key3 - 1] = arguments[_key3];
	    }
	
	    for (var i = 0; i < sources.length; i++) {
	      var source = sources[i];
	      for (var _key4 in source) {
	        newObject[_key4] = source[_key4];
	      }
	    }
	
	    return newObject;
	  };
	
	  /**
	   * Creates a shallow clone of the given object
	   * @param {Object} object
	   * @returns {Object}
	   */
	
	
	  Utils.clone = function clone(object) {
	    return this.extend({}, object);
	  };
	
	  /**
	   * Creates a Blob URI from the given Data URI
	   * @param {String} data
	   */
	
	
	  Utils.createBlobURIFromDataURI = function createBlobURIFromDataURI(data) {
	    if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
	      return data;
	    }
	
	    var rawData = _base2.default.decode(data.split(',')[1]);
	    var mimeString = data.split(',')[0].split(':')[1].split(';')[0];
	
	    // write the bytes of the string to an ArrayBuffer
	    var arrayBuffer = new ArrayBuffer(rawData.length);
	    var intArray = new Uint8Array(arrayBuffer);
	    for (var i = 0; i < rawData.length; i++) {
	      intArray[i] = rawData[i];
	    }
	
	    // write the ArrayBuffer to a blob, and you're done
	    var blob = new window.Blob([arrayBuffer], {
	      type: mimeString
	    });
	    return window.URL.createObjectURL(blob);
	  };
	
	  /**
	   * Vendor proxy for requestAnimationFrame
	   * @param  {Function} cb
	   * @return {Number}
	   */
	
	
	  Utils.requestAnimationFrame = function requestAnimationFrame(cb) {
	    var fallback = function fallback(callback) {
	      setTimeout(callback, 1000 / 60);
	    };
	
	    if (typeof window === 'undefined') {
	      return fallback(cb);
	    }
	
	    return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || fallback)(cb);
	  };
	
	  /**
	   * Generates a UUID
	   * @return {String}
	   */
	
	
	  Utils.getUUID = function getUUID() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0;
	      var v = c === 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	  };
	
	  /**
	   * Flattens the given multidimensional array
	   * @return {Array}
	   */
	
	
	  Utils.flatten = function flatten(array) {
	    return array.reduce(function (flat, toFlatten) {
	      return flat.concat(Array.isArray(toFlatten) ? Utils.flatten(toFlatten) : toFlatten);
	    }, []);
	  };
	
	  /**
	   * Creates a canvas DOM element (browser) or a node-canvas canvas (node)
	   * @return {Canvas}
	   */
	
	
	  Utils.createCanvas = function createCanvas() {
	    if (typeof window === 'undefined') {
	      var NodeCanvas = __webpack_require__(17);
	      return new NodeCanvas();
	    } else {
	      return document.createElement('canvas');
	    }
	  };
	
	  /**
	   * Checks if the given dimensions are POT
	   * @param  {PhotoEditorSDK.Math.Vector2}  dimensions
	   * @return {Boolean}
	   */
	
	
	  Utils.isPowerOfTwo = function isPowerOfTwo(dimensions) {
	    return (dimensions.x & dimensions.x - 1) === 0 && (dimensions.y & dimensions.y - 1) === 0;
	  };
	
	  /**
	   * Returns the next lowest power of two of the given number
	   * @param  {Number} x
	   * @return {Number}
	   */
	
	
	  Utils.nextLowestPOT = function nextLowestPOT(x) {
	    for (var i = 1; i < 32; i <<= 1) {
	      x = x | x >> i;
	    }
	    return x - (x >> 1);
	  };
	
	  /**
	   * Returns the next highest power of two of the given number
	   * @param  {Number} x
	   * @return {Number}
	   */
	
	
	  Utils.nextHighestPOT = function nextHighestPOT(x) {
	    x--;
	    for (var i = 1; i < 32; i <<= 1) {
	      x = x | x >> i;
	    }
	    return x + 1;
	  };
	
	  /**
	   * Moves the array item at `oldIndex` to `newIndex`
	   * @param  {Array} arr
	   * @param  {Number} oldIndex
	   * @param  {Number} newIndex
	   */
	
	
	  Utils.moveArrayItem = function moveArrayItem(arr, oldIndex, newIndex) {
	    if (newIndex >= arr.length) {
	      var k = newIndex - arr.length;
	      while (k-- + 1) {
	        arr.push(undefined);
	      }
	    }
	    arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
	  };
	
	  return Utils;
	}(); /* global HTMLElement */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	exports.default = Utils;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * Represents a 2-dimensional vector while providing math functions to
	 * modify / clone the vector. Fully chainable.
	 * @class
	 * @memberof PhotoEditorSDK.Math
	 */
	
	var Vector2 = function () {
	  /**
	   * Creates a Vector2
	   * @param  {Number} x
	   * @param  {Number} y
	   */
	
	  function Vector2(x, y) {
	    (0, _classCallCheck3.default)(this, Vector2);
	
	    this.x = x;
	    this.y = y;
	    if (typeof this.x === 'undefined') {
	      this.x = 0;
	    }
	    if (typeof this.y === 'undefined') {
	      this.y = 0;
	    }
	  }
	
	  /**
	   * Sets the given values
	   * @param {Number} x
	   * @param {Number} y
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.set = function set(x, y) {
	    this.x = x;
	    this.y = y;
	    return this;
	  };
	
	  /**
	   * Creates a clone of this vector
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.clone = function clone() {
	    return new Vector2(this.x, this.y);
	  };
	
	  /**
	   * Copies the values of the given vector
	   * @param  {PhotoEditorSDK.Math.Vector2} other
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.copy = function copy(other) {
	    this.x = other.x;
	    this.y = other.y;
	    return this;
	  };
	
	  /**
	   * Clamps this vector with the given Vector2 / Number
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} minimum
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} maximum
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.clamp = function clamp(minimum, maximum) {
	    var minimumSet = minimum !== null && typeof minimum !== 'undefined';
	    var maximumSet = maximum !== null && typeof maximum !== 'undefined';
	
	    /* istanbul ignore else  */
	    if (!(minimum instanceof Vector2) && minimumSet) {
	      minimum = new Vector2(minimum, minimum);
	    }
	    /* istanbul ignore else  */
	    if (!(maximum instanceof Vector2) && maximumSet) {
	      maximum = new Vector2(maximum, maximum);
	    }
	
	    if (minimumSet) {
	      this.x = Math.max(minimum.x, this.x);
	      this.y = Math.max(minimum.y, this.y);
	    }
	
	    if (maximumSet) {
	      this.x = Math.min(maximum.x, this.x);
	      this.y = Math.min(maximum.y, this.y);
	    }
	    return this;
	  };
	
	  /**
	   * Divides this vector by the given Vector2 / Number
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} divisor
	   * @param  {Number} [y]
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.divide = function divide(divisor, y) {
	    if (divisor instanceof Vector2) {
	      this.x /= divisor.x;
	      this.y /= divisor.y;
	    } else {
	      this.x /= divisor;
	      this.y /= typeof y === 'undefined' ? divisor : y;
	    }
	    return this;
	  };
	
	  /**
	   * Subtracts the given Vector2 / Number from this vector
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} subtrahend
	   * @param  {Number} [y]
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.subtract = function subtract(subtrahend, y) {
	    if (subtrahend instanceof Vector2) {
	      this.x -= subtrahend.x;
	      this.y -= subtrahend.y;
	    } else {
	      this.x -= subtrahend;
	      this.y -= typeof y === 'undefined' ? subtrahend : y;
	    }
	    return this;
	  };
	
	  /**
	   * Multiplies the given Vector2 / Number with this vector
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} subtrahend
	   * @param  {Number} [y]
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.multiply = function multiply(factor, y) {
	    if (factor instanceof Vector2) {
	      this.x *= factor.x;
	      this.y *= factor.y;
	    } else {
	      this.x *= factor;
	      this.y *= typeof y === 'undefined' ? factor : y;
	    }
	    return this;
	  };
	
	  /**
	   * Adds the given Vector2 / Numbers to this vector
	   * @param {(Number|PhotoEditorSDK.Math.Vector2)} addend
	   * @param {Number} [y]
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.add = function add(addend, y) {
	    if (addend instanceof Vector2) {
	      this.x += addend.x;
	      this.y += addend.y;
	    } else {
	      this.x += addend;
	      this.y += typeof y === 'undefined' ? addend : y;
	    }
	    return this;
	  };
	
	  /**
	   * Checks whether the x and y value are the same as the given ones
	   * @param  {(Number|PhotoEditorSDK.Math.Vector2)} vec
	   * @param  {Number} y
	   * @return {Boolean}
	   */
	
	
	  Vector2.prototype.equals = function equals(vec, y) {
	    if (vec instanceof Vector2) {
	      return vec.x === this.x && vec.y === this.y;
	    } else {
	      return vec === this.x && y === this.y;
	    }
	  };
	
	  /**
	   * Flips the x and y values of this vector
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.flip = function flip() {
	    var tempX = this.x;
	    this.x = this.y;
	    this.y = tempX;
	    return this;
	  };
	
	  /**
	   * Rounds the values of this vector
	   * @returns {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.round = function round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    return this;
	  };
	
	  /**
	   * Rounds up the values of this vector
	   * @returns {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.ceil = function ceil() {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    return this;
	  };
	
	  /**
	   * Rounds down the values of this vector
	   * @returns {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.floor = function floor() {
	    this.x = this.x | 0;
	    this.y = this.y | 0;
	    return this;
	  };
	
	  /**
	   * Makes both numbers of this vector positive
	   * @returns {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Vector2.prototype.abs = function abs() {
	    this.x = Math.abs(this.x);
	    this.y = Math.abs(this.y);
	    return this;
	  };
	
	  /**
	   * Returns the euclidean length of this vector
	   * @return {Number}
	   */
	
	
	  Vector2.prototype.len = function len() {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	  };
	
	  /**
	   * Returns a string representation of this vector
	   * @return {String}
	   */
	
	
	  Vector2.prototype.toString = function toString() {
	    return 'Vector2({ x: ' + this.x + ', y: ' + this.y + ' })';
	  };
	
	  return Vector2;
	}();
	
	exports.default = Vector2;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var maxLogLevel = 'warn';
	
	var LEVELS = [{ type: 'trace', background: '#EEEEEE', color: '#AAAAAA' }, { type: 'info', background: '#BDE5F8', color: '#00529B' }, { type: 'warn', background: '#FEEFB3', color: '#9F6000' }, { type: 'error', background: '#FFBABA', color: '#D8000C' }, { type: 'log', background: '#EEEEEE', color: '#1f4f6b' }];
	var LEVEL_TYPES = LEVELS.map(function (l) {
	  return l.type;
	});
	
	var Log = {};
	
	Log.setLevel = function (_level) {
	  maxLogLevel = _level;
	};
	Log.canLog = function (type) {
	  if (maxLogLevel === null) return false;
	  var currentLevelIndex = LEVEL_TYPES.indexOf(type);
	  var maxLevelIndex = LEVEL_TYPES.indexOf(maxLogLevel);
	  if (currentLevelIndex < maxLevelIndex) return false;
	  return true;
	};
	Log.hasColorfulOutput = function () {
	  return (!process || process && process.browser) && typeof navigator !== 'undefined' && navigator.userAgent.match(/Gecko|WebKit/i) && !navigator.userAgent.match(/Trident/);
	};
	
	Log.printError = function (e) {
	  var lines = e.stack.split('\n');
	  lines.forEach(function (line) {
	    Log.error('Error', line);
	  });
	};
	
	LEVELS.forEach(function (level) {
	  var type = level.type;
	  var background = level.background;
	  var color = level.color;
	
	  Log[type] = function (tag) {
	    if (!Log.canLog(type)) return;
	
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }
	
	    var output = args.map(function (a) {
	      return typeof a === 'string' ? a : a.toString();
	    }).join(' ');
	    if (!Log.hasColorfulOutput()) {
	      return console.log('PhotoEditorSDK | ' + tag + ' | ' + output);
	    }
	    console.log('%c  %c PhotoEditorSDK %c  %c ' + tag + ' %c  ' + output + '  %c  ', 'background: #43ADEB; padding: 5px 0', 'background: #2B2B2B; color: white; padding: 5px 0', 'background: #43ADEB; padding: 5px 0', 'background: ' + background + '; color: ' + color + '; padding: 5px 0; font-weight: bold', 'background: #2B2B2B; color: white; padding: 5px 0', 'background: #43ADEB; padding: 5px 0');
	  };
	});
	
	exports.default = Log;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(27);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , core      = __webpack_require__(18)
	  , ctx       = __webpack_require__(84)
	  , hide      = __webpack_require__(19)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_28__;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A canvas render target that you can render to.
	 * Canvas equivalent of {@link PhotoEditorSDK.Engine.WebGLRenderTarget}
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var CanvasRenderTarget = function () {
	  /**
	   * Creates a CanvasRenderTarget
	   * @param  {Number} width
	   * @param  {Number} height
	   * @param  {Number} pixelRatio
	   * @param  {HTMLCanvasElement} canvas
	   * @param  {CanvasRenderingContext2D} context
	   */
	
	  function CanvasRenderTarget(width, height, pixelRatio, canvas, context) {
	    (0, _classCallCheck3.default)(this, CanvasRenderTarget);
	
	    this._width = width;
	    this._height = height;
	    this._pixelRatio = pixelRatio;
	
	    this._canvas = canvas || this._createCanvas();
	    this._context = context || this._canvas.getContext('2d');
	
	    this._canvas.width = this._width * this._pixelRatio;
	    this._canvas.height = this._height * this._pixelRatio;
	    this._filterStack = [{
	      renderTarget: this,
	      filter: []
	    }];
	  }
	
	  /**
	   * Creates a canvas
	   * @return {Canvas}
	   * @private
	   */
	
	
	  CanvasRenderTarget.prototype._createCanvas = function _createCanvas() {
	    return _globals.Utils.createCanvas();
	  };
	
	  /**
	   * Clears this CanvasRenderTarget
	   */
	
	
	  CanvasRenderTarget.prototype.clear = function clear() {
	    var ctx = this._context;
	    ctx.setTransform(1, 0, 0, 1, 0, 0);
	    ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
	  };
	
	  /**
	   * Resizes this canvas buffer to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  CanvasRenderTarget.prototype.resizeTo = function resizeTo(dimensions) {
	    if (this._width !== dimensions.x) {
	      this._width = dimensions.x;
	      this._canvas.width = this._width * this._pixelRatio;
	    }
	
	    if (this._height !== dimensions.y) {
	      this._height = dimensions.y;
	      this._canvas.height = this._height * this._pixelRatio;
	    }
	  };
	
	  /**
	   * Returns the canvas
	   * @return {HTMLCanvasElement}
	   */
	
	
	  CanvasRenderTarget.prototype.getCanvas = function getCanvas() {
	    return this._canvas;
	  };
	
	  /**
	   * Returns the rendering context
	   * @return {CanvasRenderingContext2D} [description]
	   */
	
	
	  CanvasRenderTarget.prototype.getContext = function getContext() {
	    return this._context;
	  };
	
	  /**
	   * Returns the filter stack
	   * @return {Object[]}
	   */
	
	
	  CanvasRenderTarget.prototype.getFilterStack = function getFilterStack() {
	    return this._filterStack;
	  };
	
	  /**
	   * Returns the width
	   * @return {Number}
	   */
	
	
	  CanvasRenderTarget.prototype.getWidth = function getWidth() {
	    return this._width;
	  };
	
	  /**
	   * Returns the height
	   * @return {Number}
	   */
	
	
	  CanvasRenderTarget.prototype.getHeight = function getHeight() {
	    return this._height;
	  };
	
	  /**
	   * Returns the pixel ratio
	   * @return {Number}
	   */
	
	
	  CanvasRenderTarget.prototype.getPixelRatio = function getPixelRatio() {
	    return this._pixelRatio;
	  };
	
	  /**
	   * Sets the pixel ratio
	   * @param {Number} pixelRatio
	   */
	
	
	  CanvasRenderTarget.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
	    this._pixelRatio = pixelRatio;
	  };
	
	  /**
	   * Returns the dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  CanvasRenderTarget.prototype.getDimensions = function getDimensions() {
	    return new _globals.Vector2(this._width, this._height);
	  };
	
	  /**
	   * Cleans up this canvas buffer
	   */
	
	
	  CanvasRenderTarget.prototype.dispose = function dispose() {
	    this._canvas = null;
	    this._context = null;
	  };
	
	  return CanvasRenderTarget;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = CanvasRenderTarget;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An object that you can render to. WebGL equivalent of {@link PhotoEditorSDK.Engine.CanvasRenderTarget}
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	
	var WebGLRenderTarget = function () {
	  /**
	   * Creates a WebGLRenderTarget
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
	   * @param  {Number}  width
	   * @param  {Number}  height
	   * @param  {Number}  pixelRatio
	   * @param  {Boolean} [isRoot = false]
	   */
	
	  function WebGLRenderTarget(renderer, width, height, pixelRatio) {
	    var isRoot = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];
	    (0, _classCallCheck3.default)(this, WebGLRenderTarget);
	
	    this._renderer = renderer;
	    this._gl = renderer.getContext();
	    this._width = width;
	    this._height = height;
	    this._frame = null;
	    this._pixelRatio = pixelRatio;
	    this._projectionMatrix = new _globals.Matrix();
	
	    // `null` means render to canvas directly
	    this._framebuffer = null;
	    this._isRoot = isRoot;
	    this._filterStack = [{
	      renderTarget: this,
	      filter: []
	    }];
	
	    if (!isRoot) {
	      this._initFrameBuffer();
	    }
	  }
	
	  /**
	   * Resizes this WebGLRenderTarget to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  WebGLRenderTarget.prototype.resizeTo = function resizeTo(dimensions) {
	    this._width = dimensions.x | 0; // rounded
	    this._height = dimensions.y | 0; // rounded
	
	    if (!this._isRoot) {
	      this._resizeTexture(dimensions);
	    }
	
	    this._calculateProjectionMatrix();
	  };
	
	  /**
	   * Resizes the FBO's texture to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   * @private
	   */
	
	
	  WebGLRenderTarget.prototype._resizeTexture = function _resizeTexture(dimensions) {
	    var gl = this._gl;
	    gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	    var realWidth = this._width * this._pixelRatio;
	    var realHeight = this._height * this._pixelRatio;
	    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, realWidth, realHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	  };
	
	  /**
	   * Binds the framebuffer and resizes the viewport
	   */
	
	
	  WebGLRenderTarget.prototype.activate = function activate() {
	    var gl = this._gl;
	    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
	
	    this._calculateProjectionMatrix();
	
	    gl.viewport(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
	    gl.disable(gl.STENCIL_TEST);
	  };
	
	  /**
	   * Clears the framebuffer
	   */
	
	
	  WebGLRenderTarget.prototype.clear = function clear() {
	    var color = arguments.length <= 0 || arguments[0] === undefined ? _globals.Color.TRANSPARENT : arguments[0];
	
	    var gl = this._gl;
	    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
	
	    gl.clearColor.apply(gl, color.toGLColor());
	    gl.clear(gl.COLOR_BUFFER_BIT);
	  };
	
	  /**
	   * Calculates the projection matrix for this render target
	   * @private
	   */
	
	
	  WebGLRenderTarget.prototype._calculateProjectionMatrix = function _calculateProjectionMatrix() {
	    var projectionMatrix = this._projectionMatrix;
	    projectionMatrix.reset();
	
	    var frame = this._frame || new _globals.Rectangle(0, 0, this._width, this._height);
	
	    var x = frame.x;
	    var y = frame.y;
	
	    if (!this._isRoot) {
	      projectionMatrix.a = 1 / this._width * 2;
	      projectionMatrix.d = 1 / this._height * 2;
	
	      projectionMatrix.tx = -1 - x * projectionMatrix.a;
	      projectionMatrix.ty = -1 - y * projectionMatrix.d;
	    } else {
	      projectionMatrix.a = 1 / this._width * 2;
	      projectionMatrix.d = -1 / this._height * 2;
	
	      projectionMatrix.tx = -1 - x * projectionMatrix.a;
	      projectionMatrix.ty = 1 - y * projectionMatrix.d;
	    }
	  };
	
	  /**
	   * Initializes the WebGL FBO and Texture for this WebGLRenderTarget
	   * @private
	   */
	
	
	  WebGLRenderTarget.prototype._initFrameBuffer = function _initFrameBuffer() {
	    var gl = this._gl;
	
	    // Init the FBO
	    this._framebuffer = gl.createFramebuffer();
	
	    // Create the texture
	    this._texture = gl.createTexture();
	    gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	    // Set scale and repeat parameters
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	
	    // Bind texture to FBO
	    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
	    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture, 0);
	
	    this.resizeTo(new _globals.Vector2(this._width, this._height));
	  };
	
	  /**
	   * Returns the projection matrix
	   * @return {PhotoEditorSDK.Math.Matrix}
	   */
	
	
	  WebGLRenderTarget.prototype.getProjectionMatrix = function getProjectionMatrix() {
	    return this._projectionMatrix;
	  };
	
	  /**
	   * Returns the texture
	   * @return {PhotoEditorSDK.Engine.Texture}
	   */
	
	
	  WebGLRenderTarget.prototype.getTexture = function getTexture() {
	    return this._texture;
	  };
	
	  /**
	   * Returns the frame
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  WebGLRenderTarget.prototype.getFrame = function getFrame() {
	    return this._frame;
	  };
	
	  /**
	   * Sets the frame
	   * @param {PhotoEditorSDK.Math.Rectangle} frame
	   */
	
	
	  WebGLRenderTarget.prototype.setFrame = function setFrame(frame) {
	    this._frame = frame;
	  };
	
	  /**
	   * Returns the filter stack
	   * @return {Object[]}
	   */
	
	
	  WebGLRenderTarget.prototype.getFilterStack = function getFilterStack() {
	    return this._filterStack;
	  };
	
	  /**
	   * Disposes this WebGLRenderTarget
	   */
	
	
	  WebGLRenderTarget.prototype.dispose = function dispose() {
	    var gl = this._gl;
	    gl.deleteTexture(this._texture);
	    gl.deleteFramebuffer(this._framebuffer);
	  };
	
	  return WebGLRenderTarget;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = WebGLRenderTarget;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _defineProperty2 = __webpack_require__(172);
	
	var _defineProperty3 = _interopRequireDefault(_defineProperty2);
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _log = __webpack_require__(24);
	
	var _log2 = _interopRequireDefault(_log);
	
	var _eventEmitter = __webpack_require__(21);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _vector = __webpack_require__(23);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _utils = __webpack_require__(22);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Adds `set{OptionName}` and `get{OptionName}` methods to an object. Method names
	 * are specified via the `availableOptions` object.
	 * @class
	 * @extends EventEmitter
	 * @memberof PhotoEditorSDK
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Configurable = function (_EventEmitter) {
	  (0, _inherits3.default)(Configurable, _EventEmitter);
	
	  function Configurable() {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	    var additionalAvailableOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    (0, _classCallCheck3.default)(this, Configurable);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this.availableOptions = _this.availableOptions || {};
	    _this.availableOptions = _utils2.default.extend(_this.availableOptions, additionalAvailableOptions);
	
	    _this._onConfigurableUpdate = _this._onConfigurableUpdate.bind(_this);
	
	    _this._initOptions(options);
	    return _this;
	  }
	
	  /**
	   * Builds an error message from the given string
	   * @param  {String} message
	   * @return {Error}
	   * @private
	   */
	
	
	  Configurable.prototype._buildConfigError = function _buildConfigError(message) {
	    var errorMessage = '';
	    if (this.constructor.name) {
	      errorMessage = this.constructor.name + ': ';
	    }
	    errorMessage += message;
	    return new Error(errorMessage);
	  };
	
	  /**
	   * Gets called when options have been changed
	   * @protected
	   */
	
	
	  Configurable.prototype._onOptionsChange = function _onOptionsChange() {};
	
	  /**
	   * Checks whether all required options are specified
	   * @return {Promise}
	   */
	
	
	  Configurable.prototype.validateSettings = function validateSettings() {
	    var _this2 = this;
	
	    return new _promise2.default(function (resolve, reject) {
	      // Check for required options
	      for (var optionName in _this2.availableOptions) {
	        var optionConfig = _this2.availableOptions[optionName];
	        if (optionConfig.required && typeof _this2._options[optionName] === 'undefined') {
	          return reject(_this2._buildConfigError('Option `' + optionName + '` is required.'));
	        }
	      }
	
	      resolve();
	    });
	  };
	
	  /**
	   * Goes through the available options, sets _options defaults
	   * @param {Object} userOptions
	   * @protected
	   */
	
	
	  Configurable.prototype._initOptions = function _initOptions() {
	    var userOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    this._options = {};
	
	    // Set defaults, create getters and setters
	    var optionName, option, capitalized;
	    var self = this;
	    for (optionName in this.availableOptions) {
	      capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
	      option = this.availableOptions[optionName];
	
	      if (['string', 'number', 'boolean', 'object', 'vector2', 'color', 'configurable', 'array'].indexOf(option.type) === -1) {
	        throw this._buildConfigError('Unknown option type: `' + option.type + '`');
	      }
	
	      // Create setter and getter
	      var fn = function fn(optionName, option) {
	        self['set' + capitalized] = function (value, update, initial) {
	          self.setOption(optionName, value, update, initial);
	        };
	
	        // Default getter
	        self['get' + capitalized] = function () {
	          return self.getOption(optionName);
	        };
	      };
	      fn(optionName, option);
	
	      // Handle configurable initialization
	      if (option.type === 'configurable') {
	        this._options[optionName] = new Configurable(undefined, option.structure || {});
	        this._options[optionName].on('update', this._onConfigurableUpdate);
	      }
	
	      // Set default if available
	      if (typeof option.default !== 'undefined' && !(optionName in userOptions)) {
	        this['set' + capitalized](option.default, false, true);
	      }
	    }
	
	    // Overwrite options with the ones given by user
	    for (optionName in userOptions) {
	      // Check if option is available
	      if (typeof this.availableOptions[optionName] === 'undefined') {
	        throw new Error('Invalid option: ' + optionName);
	      }
	
	      // Call setter
	      capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
	      this['set' + capitalized](userOptions[optionName], false, true);
	    }
	  };
	
	  /**
	   * Sets the given options
	   * @param {Object} options
	   */
	
	
	  Configurable.prototype.set = function set(options) {
	    var emitUpdate = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    if (emitUpdate) {
	      this.emit('update', this, options);
	    }
	
	    for (var optionName in options) {
	      this.setOption(optionName, options[optionName], false);
	    }
	    this._onOptionsChange();
	  };
	
	  /**
	   * Returns the value for the given option
	   * @param {String} optionName
	   * @return {*}
	   */
	
	
	  Configurable.prototype.getOption = function getOption(optionName) {
	    return this._options[optionName];
	  };
	
	  /**
	   * Returns the default value for the given option
	   * @param  {String} optionName
	   * @return {*}
	   */
	
	
	  Configurable.prototype.getOptionDefault = function getOptionDefault(optionName) {
	    var option = this.availableOptions[optionName];
	    if (!option) {
	      return undefined;
	    }
	    return option.default;
	  };
	
	  /**
	   * Returns the options
	   * @return {Object}
	   */
	
	
	  Configurable.prototype.getOptions = function getOptions() {
	    return this._options;
	  };
	
	  /**
	   * Returns a hash with the default options
	   * @return {Object}
	   */
	
	
	  Configurable.prototype.getDefaultOptions = function getDefaultOptions() {
	    var options = {};
	    for (var optionName in this._options) {
	      var defaultValue = this.availableOptions[optionName].default;
	      if (typeof defaultValue === 'undefined') continue;
	
	      options[optionName] = defaultValue;
	    }
	    return options;
	  };
	
	  /**
	   * Check if the current options equal the given ones
	   * @param  {Object} options
	   * @return {Boolean}
	   */
	
	
	  Configurable.prototype.optionsEqual = function optionsEqual(options) {
	    for (var optionName in options) {
	      var value = options[optionName];
	      if (!this._optionEquals(optionName, value)) {
	        return false;
	      }
	    }
	    return true;
	  };
	
	  /**
	   * Checks if the given option has the given value
	   * @param  {String} optionName
	   * @param  {*} value
	   * @return {Boolean}
	   * @private
	   */
	
	
	  Configurable.prototype._optionEquals = function _optionEquals(optionName, value) {
	    var optionType = this.availableOptions[optionName].type;
	    var currentValue = this._options[optionName];
	    switch (optionType) {
	      case 'string':
	      case 'number':
	      case 'boolean':
	      case 'object':
	      case '*':
	        return currentValue === value;
	      case 'vector2':
	      case 'color':
	        return value.equals(currentValue);
	      case 'configurable':
	        return currentValue.optionsEqual(value);
	      case 'array':
	        return this._arrayOptionEquals(optionName, value);
	    }
	  };
	
	  /**
	   * Checks if the given option of type `array` matches the given value
	   * @param  {String} optionName
	   * @param  {Array} arr
	   * @return {Boolean}
	   * @private
	   */
	
	
	  Configurable.prototype._arrayOptionEquals = function _arrayOptionEquals(optionName, arr) {
	    var thisArr = this._options[optionName];
	    var equal = true;
	    for (var i = 0; i < thisArr.length; i++) {
	      var thisValue = thisArr[i];
	      var value = arr[i];
	      if (thisValue instanceof Configurable) {
	        if (typeof value === 'undefined' || !thisValue.optionsEqual(value)) {
	          equal = false;
	          break;
	        }
	      } else if (value !== thisValue) {
	        equal = false;
	        break;
	      }
	    }
	    return equal;
	  };
	
	  /**
	   * Returns a serialized version of this configurable
	   * @return {Object}
	   */
	
	
	  Configurable.prototype.serializeOptions = function serializeOptions() {
	    var options = {};
	    for (var optionName in this._options) {
	      options[optionName] = this._serializeOption(optionName);
	    }
	    return options;
	  };
	
	  /**
	   * Returns a serialized version of the given option
	   * @param {String} optionName
	   * @return {*} optionName
	   * @protected
	   */
	
	
	  Configurable.prototype._serializeOption = function _serializeOption(optionName) {
	    var optionType = this.availableOptions[optionName].type;
	    var value = this._options[optionName];
	    switch (optionType) {
	      case 'string':
	      case 'number':
	      case 'boolean':
	      case 'object':
	      case '*':
	        return value;
	      case 'vector2':
	      case 'color':
	        return value.clone();
	      case 'configurable':
	        return value.serializeOptions();
	      case 'array':
	        return value.slice(0);
	    }
	  };
	
	  /**
	   * Sets the value for the given option, validates it
	   * @param {String} optionName
	   * @param {*} value
	   * @param {Boolean} [update = true] - Should an `update` event be emitted?
	   * @param {Boolean} [initial = false] - Is this the first time this option is set?
	   */
	
	
	  Configurable.prototype.setOption = function setOption(optionName, value) {
	    var update = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	    var initial = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    if (update) {
	      this.emit('update', this, (0, _defineProperty3.default)({}, optionName, value));
	    }
	
	    var optionConfig = this.availableOptions[optionName];
	    if (!optionConfig) {
	      _log2.default.error(this.constructor.name, 'Unknown option `' + optionName + '`.');
	      return;
	    }
	
	    if (typeof optionConfig.setter !== 'undefined') {
	      value = optionConfig.setter.call(this, value, initial);
	    }
	
	    if (typeof optionConfig.validation !== 'undefined') {
	      optionConfig.validation(value);
	    }
	
	    switch (optionConfig.type) {
	      // String options
	      case 'string':
	        if (typeof value !== 'string') {
	          throw this._buildConfigError('Option `' + optionName + '` has to be a string.');
	        }
	
	        // String value restrictions
	        var available = optionConfig.available;
	        if (typeof available !== 'undefined' && available.indexOf(value) === -1) {
	          throw this._buildConfigError('Invalid value for `' + optionName + '` (valid values are: ' + optionConfig.available.join(', ') + ')');
	        }
	
	        this._options[optionName] = value;
	        break;
	
	      // Number options
	      case 'number':
	        if (typeof value !== 'number') {
	          throw this._buildConfigError('Option `' + optionName + '` has to be a number.');
	        }
	
	        this._options[optionName] = value;
	        break;
	
	      // Boolean options
	      case 'boolean':
	        if (typeof value !== 'boolean') {
	          throw this._buildConfigError('Option `' + optionName + '` has to be a boolean.');
	        }
	
	        this._options[optionName] = value;
	        break;
	
	      // Vector2 options
	      case 'vector2':
	        if (!(value instanceof _vector2.default)) {
	          throw this._buildConfigError('Option `' + optionName + '` has to be an instance of Vector2.');
	        }
	
	        this._options[optionName] = value.clone();
	
	        break;
	
	      // Color options
	      case 'color':
	        if (!(value instanceof _color2.default)) {
	          throw this._buildConfigError('Option `' + optionName + '` has to be an instance of Color.');
	        }
	
	        this._options[optionName] = value;
	        break;
	
	      // Object options
	      case 'object':
	      case '*':
	        this._options[optionName] = value;
	        break;
	
	      // Configurable options
	      case 'configurable':
	        this._options[optionName].set(value);
	        break;
	
	      // Array options
	      case 'array':
	        if (!(value instanceof Array)) {
	          throw this._buildConfigError('Option `' + optionName + '` has to be an Array.');
	        }
	        this._options[optionName] = value.slice(0);
	        break;
	
	      // Unknown option type
	      default:
	        throw this._buildConfigError('Unknown option type: `' + optionConfig.type + '`');
	    }
	
	    if (update) {
	      this._onOptionsChange();
	      this.emit('update', this, (0, _defineProperty3.default)({}, optionName, value));
	    }
	  };
	
	  /**
	   * Gets called when a `configurable` option has been updated
	   * @param  {*} ...args
	   * @private
	   */
	
	
	  Configurable.prototype._onConfigurableUpdate = function _onConfigurableUpdate() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    this.emit.apply(this, ['update'].concat(args));
	  };
	
	  return Configurable;
	}(_eventEmitter2.default);
	
	exports.default = Configurable;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(171);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(170);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(91)
	  , enumBugKeys = __webpack_require__(49);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 36 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 38 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * The available render types
	 * @enum {String}
	 * @alias RenderType
	 * @memberof PhotoEditorSDK
	 */
	var RenderType = exports.RenderType = {
	  IMAGE: 'image',
	  DATAURL: 'data-url',
	  BUFFER: 'buffer',
	  BLOB: 'blob',
	  MSBLOB: 'ms-blob'
	};
	
	/**
	 * The available image types
	 * @enum {String}
	 * @alias ImageFormat
	 * @memberof PhotoEditorSDK
	 */
	var ImageFormat = exports.ImageFormat = {
	  PNG: 'image/png',
	  JPEG: 'image/jpeg'
	};
	
	var Events = exports.Events = {
	  OPERATION_UPDATED: 'operation:update'
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*!
	 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
	 * https://github.com/hMatoba/MinifyJpeg
	 */
	
	var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	/**
	 * Provides Base64 encode and decode methods
	 * @type {Object}
	 * @ignore
	 */
	var Base64 = {
	  /**
	   * Encodes the given input into a Base64 string
	   * @param  {String} input
	   * @return {String}
	   */
	
	  encode: function encode(input) {
	    var output = '';
	    var chr1 = void 0,
	        chr2 = void 0,
	        chr3 = void 0;
	    var enc1 = void 0,
	        enc2 = void 0,
	        enc3 = void 0,
	        enc4 = void 0;
	    var i = 0;
	
	    do {
	      chr1 = input[i++];
	      chr2 = input[i++];
	      chr3 = input[i++];
	
	      enc1 = chr1 >> 2;
	      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	      enc4 = chr3 & 63;
	
	      if (isNaN(chr2)) {
	        enc3 = enc4 = 64;
	      } else if (isNaN(chr3)) {
	        enc4 = 64;
	      }
	
	      output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
	      chr1 = chr2 = chr3 = '';
	      enc1 = enc2 = enc3 = enc4 = '';
	    } while (i < input.length);
	
	    return output;
	  },
	
	
	  /**
	   * Decodes the given Base64 string
	   * @param  {String} input
	   * @return {String}
	   */
	  decode: function decode(input) {
	    var chr1 = void 0,
	        chr2 = void 0,
	        chr3 = void 0;
	    var enc1 = void 0,
	        enc2 = void 0,
	        enc3 = void 0,
	        enc4 = void 0;
	    var i = 0;
	    var buf = [];
	
	    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
	    var base64test = /[^A-Za-z0-9\+\/\=]/g;
	    if (base64test.exec(input)) {
	      throw new Error('There were invalid base64 characters in the input text.\n' + 'Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\n' + 'Expect errors in decoding.');
	    }
	    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
	
	    do {
	      enc1 = KEY_STR.indexOf(input.charAt(i++));
	      enc2 = KEY_STR.indexOf(input.charAt(i++));
	      enc3 = KEY_STR.indexOf(input.charAt(i++));
	      enc4 = KEY_STR.indexOf(input.charAt(i++));
	
	      chr1 = enc1 << 2 | enc2 >> 4;
	      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
	      chr3 = (enc3 & 3) << 6 | enc4;
	
	      buf.push(chr1);
	
	      if (enc3 !== 64) {
	        buf.push(chr2);
	      }
	      if (enc4 !== 64) {
	        buf.push(chr3);
	      }
	
	      chr1 = chr2 = chr3 = '';
	      enc1 = enc2 = enc3 = enc4 = '';
	    } while (i < input.length);
	
	    return buf;
	  }
	};
	
	exports.default = Base64;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _base = __webpack_require__(39);
	
	var _base2 = _interopRequireDefault(_base);
	
	var _arrayStream = __webpack_require__(107);
	
	var _arrayStream2 = _interopRequireDefault(_arrayStream);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var EXIF_TAGS = {
	  0x0100: 'ImageWidth',
	  0x0101: 'ImageHeight',
	  0x8769: 'ExifIFDPointer',
	  0x8825: 'GPSInfoIFDPointer',
	  0xA005: 'InteroperabilityIFDPointer',
	  0x0102: 'BitsPerSample',
	  0x0103: 'Compression',
	  0x0106: 'PhotometricInterpretation',
	  0x0112: 'Orientation',
	  0x0115: 'SamplesPerPixel',
	  0x011C: 'PlanarConfiguration',
	  0x0212: 'YCbCrSubSampling',
	  0x0213: 'YCbCrPositioning',
	  0x011A: 'XResolution',
	  0x011B: 'YResolution',
	  0x0128: 'ResolutionUnit',
	  0x0111: 'StripOffsets',
	  0x0116: 'RowsPerStrip',
	  0x0117: 'StripByteCounts',
	  0x0201: 'JPEGInterchangeFormat',
	  0x0202: 'JPEGInterchangeFormatLength',
	  0x012D: 'TransferFunction',
	  0x013E: 'WhitePoint',
	  0x013F: 'PrimaryChromaticities',
	  0x0211: 'YCbCrCoefficients',
	  0x0214: 'ReferenceBlackWhite',
	  0x0132: 'DateTime',
	  0x010E: 'ImageDescription',
	  0x010F: 'Make',
	  0x0110: 'Model',
	  0x0131: 'Software',
	  0x013B: 'Artist',
	  0x8298: 'Copyright'
	}; /*!
	    * Based on https://github.com/exif-js/exif-js by Jacob Seidelin
	    * Licensed under MIT
	    */
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var DATA_JPEG_PREFIX = 'data:image/jpeg;base64,';
	var JPEG_REGEX = new RegExp('^' + DATA_JPEG_PREFIX, 'i');
	
	/**
	 * Reads EXIF tags from the given byte array and restores them
	 * @class
	 * @memberof PhotoEditorSDK
	 * @ignore
	 */
	
	var EXIF = function () {
	  /**
	   * Creates an EXIF object
	   * @param  {Array} buf
	   */
	
	  function EXIF(buf) {
	    (0, _classCallCheck3.default)(this, EXIF);
	
	    this._buf = buf;
	    this._stream = new _arrayStream2.default(this._buf);
	    this._stream.setHead(0);
	
	    this._segments = this._sliceIntoSegments(this._buf);
	    this._exifBuffer = this._getExifBuffer();
	    this._exifStream = new _arrayStream2.default(this._exifBuffer);
	    this._parseExif();
	  }
	
	  /**
	   * Restores the exif tags into the given data url
	   * @return {String} base64String
	   */
	
	
	  EXIF.prototype.restoreExifTags = function restoreExifTags(base64String) {
	    // First, make the given string a data array
	    var raw = base64String.replace(DATA_JPEG_PREFIX, '');
	    var data = _base2.default.decode(raw);
	
	    var segments = this._sliceIntoSegments(data);
	    var segmentStart = segments[1][0];
	    var dataBefore = data.slice(0, segmentStart);
	    var dataAfter = data.slice(segmentStart);
	
	    var newData = dataBefore.concat(this._exifBuffer);
	    newData = newData.concat(dataAfter);
	
	    // Make it a base64 string again
	    return DATA_JPEG_PREFIX + _base2.default.encode(newData);
	  };
	
	  /**
	   * Overwrites the orientation with the given 16 bit integer
	   * @param {Number} orientation
	   */
	
	
	  EXIF.prototype.setOrientation = function setOrientation(orientation) {
	    if (this._tagData.Orientation) {
	      var entryOffset = this._tagData.Orientation.entryOffset;
	      // Replace value in buffer
	
	      this._exifStream.setHead(entryOffset + 8);
	      this._exifStream.writeInt16(orientation);
	    }
	  };
	
	  /**
	   * Checks whether the given base64 data url is a jpeg image
	   * @param  {String}  base64String
	   * @return {Boolean}
	   */
	
	
	  EXIF.isJPEG = function isJPEG(base64String) {
	    return JPEG_REGEX.test(base64String);
	  };
	
	  /**
	   * Creates a new instance of Exif from the given base64-encoded
	   * string
	   * @param  {String} base64String
	   * @return {PhotoEditorSDK.Exif}
	   */
	
	
	  EXIF.fromBase64String = function fromBase64String(base64String) {
	    var raw = base64String.replace(DATA_JPEG_PREFIX, '');
	    var data = _base2.default.decode(raw);
	    return new EXIF(data);
	  };
	
	  /**
	   * Parses the exif tags
	   * @return {Object}
	   * @private
	   */
	
	
	  EXIF.prototype._parseExif = function _parseExif() {
	    this._exifStream.setHead(0);
	    // Skip marker
	    this._exifStream.readInt16();
	    // Skip length
	    this._exifStream.readInt16();
	
	    var header = this._exifStream.readString(4);
	    if (header !== 'Exif') {
	      return;
	    }
	
	    // Skip 2 bytes
	    this._exifStream.readInt16();
	
	    var tiffOffset = this._exifStream.getHead();
	
	    // Find endian type
	    var bigEndian = false;
	    var endian = this._exifStream.readInt16();
	    if (endian === 0x4949) {
	      bigEndian = false;
	    } else if (endian === 0x4d4d) {
	      bigEndian = true;
	    } else {
	      throw new Error('Invalid TIFF data: No endian type found');
	    }
	
	    if (this._exifStream.readInt16(!bigEndian) !== 0x002A) {
	      throw new Error('Invalid TIFF data: No 0x002A');
	    }
	
	    var firstIFDOffset = this._exifStream.readInt32(!bigEndian);
	    if (firstIFDOffset < 8) {
	      throw new Error('Invalid TIFF data: First IFD offset < 8');
	    }
	
	    var ifdOffset = tiffOffset + firstIFDOffset;
	    var tags = this._readTags(this._exifStream, tiffOffset, ifdOffset, bigEndian);
	    this._tags = tags.tags;
	    this._tagData = tags.tagData;
	  };
	
	  /**
	   * Reads the TIFF tags from the stream
	   * @param  {ArrayBuffer} stream
	   * @param  {Number} tiffStart The position where tiff data starts
	   * @param  {Number} ifdStart  The position where the IFD starts
	   * @param  {Boolean} bigEndian
	   * @return {Object}
	   * @private
	   */
	
	
	  EXIF.prototype._readTags = function _readTags(stream, tiffStart, ifdStart, bigEndian) {
	    stream.setHead(ifdStart);
	    var entriesCount = stream.readInt16(!bigEndian);
	    var tags = {};
	    var tagData = [];
	
	    for (var i = 0; i < entriesCount; i++) {
	      var entryOffset = ifdStart + i * 12 + 2;
	      stream.setHead(entryOffset);
	      var tag = stream.readInt16(!bigEndian);
	      var type = void 0;
	      var numValues = void 0;
	      var valueOffset = void 0;
	      if (EXIF_TAGS[tag]) {
	        tag = EXIF_TAGS[tag];
	        type = stream.readInt16(!bigEndian);
	        numValues = stream.readInt32(!bigEndian);
	        valueOffset = stream.readInt32(!bigEndian) + tiffStart;
	        var value = null;
	
	        switch (type) {
	          case 1: // byte, 8-bit unsigned int
	          case 7:
	            // undefined, 8-bit byte, value depending on field
	            if (numValues === 1) {
	              value = stream.readInt8(!bigEndian);
	            } else {
	              value = [];
	              for (var _i = 0; _i < numValues; _i++) {
	                value.push(stream.readInt8(!bigEndian));
	              }
	            }
	            break;
	          case 2:
	            // 8-bit ascii char
	            stream.setHead(numValues > 4 ? valueOffset : entryOffset + 8);
	            value = stream.readString(numValues);
	            break;
	          case 3:
	            // short
	            stream.setHead(numValues > 2 ? valueOffset : entryOffset + 8);
	            if (numValues === 1) {
	              value = stream.readInt16(!bigEndian);
	            } else {
	              value = [];
	              for (var _i2 = 0; _i2 < numValues; _i2++) {
	                value.push(stream.readInt16(!bigEndian));
	              }
	            }
	            break;
	          case 4: // long
	          case 9:
	            // slong
	            stream.setHead(numValues > 1 ? valueOffset : entryOffset + 8);
	            if (numValues === 1) {
	              value = stream.readInt32(!bigEndian);
	            } else {
	              value = [];
	              for (var _i3 = 0; _i3 < numValues; _i3++) {
	                value.push(stream.readInt32(!bigEndian));
	              }
	            }
	            break;
	          case 5: // rational (two long values, first numerator, second denominator)
	          case 10:
	            // rational (two slongs)
	            stream.setHead(valueOffset);
	            if (numValues === 1) {
	              var numerator = stream.readInt32(!bigEndian);
	              var denominator = stream.readInt32(!bigEndian);
	              value = numerator / denominator;
	            } else {
	              value = [];
	              for (var _i4 = 0; _i4 < numValues; _i4++) {
	                var _numerator = stream.readInt32(!bigEndian);
	                var _denominator = stream.readInt32(!bigEndian);
	                var val = _numerator / _denominator;
	                value.push(val);
	              }
	            }
	            break;
	        }
	
	        tags[tag] = value;
	        tagData[tag] = {
	          value: value,
	          numValues: numValues,
	          entryOffset: entryOffset,
	          valueOffset: valueOffset,
	          type: type
	        };
	      }
	    }
	
	    return { tags: tags, tagData: tagData };
	  };
	
	  /**
	   * Returns a new buffer containing the Exif segment
	   * @return {Array}
	   * @private
	   */
	
	
	  EXIF.prototype._getExifBuffer = function _getExifBuffer() {
	    var segments = this._segments;
	    for (var i = 0; i < segments.length; i++) {
	      var offset = segments[i][0];
	      var end = segments[i][1];
	      this._stream.setHead(offset);
	      var marker = this._stream.peekInt16();
	      if (marker === 0xffe1) {
	        return this._buf.slice(offset, end);
	      }
	    }
	    return false;
	  };
	
	  /**
	   * Slices the array into segments
	   * @param  {Array.<Number>} buf
	   * @return {Array}
	   * @private
	   */
	
	
	  EXIF.prototype._sliceIntoSegments = function _sliceIntoSegments(buf) {
	    var stream = new _arrayStream2.default(buf);
	    var segments = [];
	    while (stream.getHead() < buf.length) {
	      var marker = stream.readInt16();
	      if (marker === 0xffd8) {
	        continue;
	      } // SOI
	      if (marker === 0xffda) {
	        break;
	      } // SOS Marker
	
	      if (marker >= 0xff00 && marker <= 0xffff) {
	        // Marker (FF-XX-HL-LL)
	        var length = stream.readInt16();
	        var end = stream.getHead() + length - 2;
	        segments.push([stream.getHead() - 4, end]);
	        stream.setHead(end);
	      } else {
	        throw new Error('Invalid marker: 0x' + marker.toString(16));
	      }
	    }
	
	    this._stream.setHead(0);
	
	    return segments;
	  };
	
	  /**
	   * Returns the tags
	   * @return {Object}
	   */
	
	
	  EXIF.prototype.getTags = function getTags() {
	    return this._tags;
	  };
	
	  /**
	   * Returns the tag data (key, value, byte position etc.)
	   * @return {Object[]}
	   */
	
	
	  EXIF.prototype.getTagData = function getTagData() {
	    return this._tagData;
	  };
	
	  /**
	   * Disposes this EXIF object
	   */
	
	
	  EXIF.prototype.dispose = function dispose() {
	    this._buf = [];
	    this._exifBuffer = [];
	    this._segments = [];
	  };
	
	  return EXIF;
	}();
	
	exports.default = EXIF;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The base class for all objects that can be displayed
	 * on the screen
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var DisplayObject = function () {
	  /**
	   * Creates a DisplayObject
	   */
	
	  function DisplayObject() {
	    (0, _classCallCheck3.default)(this, DisplayObject);
	
	    this._position = new _globals.Vector2(0, 0);
	    this._scale = new _globals.Vector2(1, 1);
	    this._pivot = new _globals.Vector2(0, 0);
	    this._rotation = 0;
	    this._lastRotation = null;
	    this._alpha = 1;
	    this._visible = true;
	    this._worldTransform = new _globals.Matrix();
	    this._parent = null;
	    this._shaders = [];
	    this._boundsNeedUpdate = true;
	    this._bounds = new _globals.Rectangle(0, 0, 1, 1);
	    this._localBoundsNeedUpdate = true;
	    this._localBounds = new _globals.Rectangle(0, 0, 1, 1);
	    this._tint = 0xffffff;
	  }
	
	  /**
	   * Renders this DisplayObject using the given WebGLRenderer
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @abstract
	   */
	
	
	  DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) {
	    _globals.Log.warn(this.constructor.name, '`renderWebGL` is abstract and not implemented in inherited class');
	  };
	
	  /**
	   * Renders this DisplayObject using the given CanvasRenderer
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @abstract
	   */
	
	
	  DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) {
	    _globals.Log.warn(this.constructor.name, '`renderCanvas` is abstract and not implemented in inherited class');
	  };
	
	  /**
	   * Updates the world transform for this DisplayObject
	   */
	
	
	  DisplayObject.prototype.updateTransform = function updateTransform() {
	    var parentTransform = this._parent ? this._parent.getWorldTransform() : _globals.Matrix.IDENTITY;
	    var worldTransform = this._worldTransform;
	
	    // Only build rotation matrix if rotation has changed since last update
	    var rotationChanged = this._rotation !== this._lastRotation;
	    if (rotationChanged) {
	      this._sinRotation = Math.sin(this._rotation);
	      this._cosRotation = Math.cos(this._rotation);
	      this._lastRotation = this._rotation;
	    }
	
	    worldTransform.a = this._cosRotation * this._scale.x;
	    worldTransform.b = this._sinRotation * this._scale.x;
	    worldTransform.c = -this._sinRotation * this._scale.y;
	    worldTransform.d = this._cosRotation * this._scale.y;
	    worldTransform.tx = this._position.x;
	    worldTransform.ty = this._position.y;
	
	    if (this._pivot.x || this._pivot.y) {
	      worldTransform.tx -= this._pivot.x * worldTransform.a + this._pivot.y * worldTransform.c;
	      worldTransform.ty -= this._pivot.x * worldTransform.b + this._pivot.y * worldTransform.d;
	    }
	
	    worldTransform.multiply(parentTransform);
	
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  // -------------------------------------------------------------------------- SHADERS
	
	  /**
	   * Pushes the given shader to the list of shaders
	   * @param {PhotoEditorSDK.Engine.Shader} shader
	   */
	
	
	  DisplayObject.prototype.addShader = function addShader(shader) {
	    this._shaders.push(shader);
	  };
	
	  /**
	   * Removes the given shader from the list of shaders
	   * @param  {PhotoEditorSDK.Engine.Shader} shader
	   * @return {Boolean}
	   */
	
	
	  DisplayObject.prototype.removeShader = function removeShader(shader) {
	    var index = this._shaders.indexOf(shader);
	    if (index !== -1) {
	      this._shaders.splice(index, 1);
	      return true;
	    }
	    return false;
	  };
	
	  /**
	   * Removes the shader at the given index from the list of shaders
	   * @param  {Number} index
	   * @return {Boolean}
	   */
	
	
	  DisplayObject.prototype.removeShaderAt = function removeShaderAt(index) {
	    if (!this._shaders[index]) {
	      return false;
	    }
	    this._shaders.splice(index, 1);
	    return true;
	  };
	
	  /**
	   * Returns the bounds for this DisplayObject
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  DisplayObject.prototype.getBounds = function getBounds() {
	    return this._bounds.clone();
	  };
	
	  // -------------------------------------------------------------------------- GETTERS / SETTERS
	
	  /**
	   * Returns the current position
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  DisplayObject.prototype.getPosition = function getPosition() {
	    return this._position;
	  };
	
	  /**
	   * Sets the position to the given one
	   * @param {PhotoEditorSDK.Math.Vector2|Number} x
	   * @param {Number} [y]
	   */
	
	
	  DisplayObject.prototype.setPosition = function setPosition(position, y) {
	    if (position instanceof _globals.Vector2) {
	      this._position.copy(position);
	    } else {
	      this._position.set(position, y);
	    }
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the current scale
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  DisplayObject.prototype.getScale = function getScale() {
	    return this._scale;
	  };
	
	  /**
	   * Sets the scale to the given one
	   * @param {PhotoEditorSDK.Math.Vector2|Number} x
	   * @param {Number} [y]
	   */
	
	
	  DisplayObject.prototype.setScale = function setScale(scale, y) {
	    if (scale instanceof _globals.Vector2) {
	      this._scale.copy(scale);
	    } else {
	      this._scale.set(scale, y);
	    }
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the current pivot (The point that this Displayobject rotates around)
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  DisplayObject.prototype.getPivot = function getPivot() {
	    return this._pivot;
	  };
	
	  /**
	   * Sets the pivot (The point that this DisplayObject rotates around)
	   * @param {PhotoEditorSDK.Math.Vector2|Number} pivot
	   * @param {Number} [y]
	   */
	
	
	  DisplayObject.prototype.setPivot = function setPivot(pivot, y) {
	    if (pivot instanceof _globals.Vector2) {
	      this._pivot.copy(pivot);
	    } else {
	      this._pivot.set(pivot, y);
	    }
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the current rotation in radians
	   * @return {Number}
	   */
	
	
	  DisplayObject.prototype.getRotation = function getRotation() {
	    return this._rotation;
	  };
	
	  /**
	   * Sets this object's rotation (in radians)
	   * @param {Number} rotation
	   */
	
	
	  DisplayObject.prototype.setRotation = function setRotation(rotation) {
	    this._rotation = rotation;
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the current alpha (0...1)
	   * @return {Number}
	   */
	
	
	  DisplayObject.prototype.getAlpha = function getAlpha() {
	    return this._alpha;
	  };
	
	  /**
	   * Sets the alpha (0...1)
	   * @param {Number} alpha
	   */
	
	
	  DisplayObject.prototype.setAlpha = function setAlpha(alpha) {
	    this._alpha = alpha;
	  };
	
	  /**
	   * Returns the computed alpha of this DisplayObject
	   * @return {Number}
	   */
	
	
	  DisplayObject.prototype.getWorldAlpha = function getWorldAlpha() {
	    if (this._parent) {
	      return this._parent.getAlpha() * this._alpha;
	    } else {
	      return this._alpha;
	    }
	  };
	
	  /**
	   * Returns the current world transformation matrix
	   * @return {PhotoEditorSDK.Math.Matrix}
	   */
	
	
	  DisplayObject.prototype.getWorldTransform = function getWorldTransform() {
	    return this._worldTransform;
	  };
	
	  /**
	   * Returns the parent object
	   * @return {PhotoEditorSDK.Engine.DisplayObject}
	   */
	
	
	  DisplayObject.prototype.getParent = function getParent() {
	    return this._parent;
	  };
	
	  /**
	   * Sets this object's parent object
	   * @param {PhotoEditorSDK.Engine.DisplayObject} parent
	   */
	
	
	  DisplayObject.prototype.setParent = function setParent(parent) {
	    this._parent = parent;
	  };
	
	  /**
	   * Returns the current tint color
	   * @return {Number}
	   */
	
	
	  DisplayObject.prototype.getTint = function getTint() {
	    return this._tint;
	  };
	
	  /**
	   * Sets the tint color
	   * @param {Number} tint
	   */
	
	
	  DisplayObject.prototype.setTint = function setTint(tint) {
	    this._tint = tint;
	  };
	
	  /**
	   * Checks whether this object is currently visible
	   * @return {Boolean} [description]
	   */
	
	
	  DisplayObject.prototype.isVisible = function isVisible() {
	    return this._visible;
	  };
	
	  /**
	   * Sets this object's visibility
	   * @param {Boolean} visible
	   */
	
	
	  DisplayObject.prototype.setVisible = function setVisible(visible) {
	    this._visible = visible;
	  };
	
	  return DisplayObject;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = DisplayObject;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	var _canvasRenderTarget = __webpack_require__(29);
	
	var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Manages the filters for a {@link PhotoEditorSDK.Engine.CanvasRenderer}
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var CanvasFilterManager = function () {
	  function CanvasFilterManager(renderer) {
	    (0, _classCallCheck3.default)(this, CanvasFilterManager);
	
	    this._renderer = renderer;
	    this._filterStack = [{
	      renderTarget: renderer.getCurrentRenderTarget(),
	      filters: []
	    }];
	
	    this._currentFrame = null;
	    this._textures = [];
	    this._textureFrame = new _globals.Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());
	  }
	
	  /**
	   * Resizes this FilterManager and its textures to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  CanvasFilterManager.prototype.resizeTo = function resizeTo(dimensions) {
	    this._textureFrame.width = dimensions.x;
	    this._textureFrame.height = dimensions.y;
	
	    this._textures.forEach(function (texture) {
	      return texture.resizeTo(dimensions);
	    });
	  };
	
	  /**
	   * Pushes the given filters to the
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @param  {Array.<Filter>} filters
	   */
	
	
	  CanvasFilterManager.prototype.pushFilters = function pushFilters(displayObject, filters) {
	    var bounds = displayObject.getBounds();
	    this._currentFrame = bounds;
	
	    var renderTarget = this._getOrCreateRenderTarget();
	    this._renderer.setRenderTarget(renderTarget);
	    this._filterStack.push({ renderTarget: renderTarget, filters: filters });
	  };
	
	  /**
	   * Removes, applies and returns the last filters from the stack
	   * @return {Object}
	   */
	
	
	  CanvasFilterManager.prototype.popFilters = function popFilters() {
	    var _filterStack$pop = this._filterStack.pop();
	
	    var filters = _filterStack$pop.filters;
	    var renderTarget = _filterStack$pop.renderTarget;
	
	    var lastFilter = this._filterStack[this._filterStack.length - 1];
	
	    var inputRenderTarget = renderTarget;
	    var outputRenderTarget = lastFilter.renderTarget;
	
	    if (filters.length === 1) {
	      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
	      this._textures.push(inputRenderTarget);
	    } else {
	      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
	    }
	    return filters;
	  };
	
	  /**
	   * Applies the given filters to the given inputRenderTarget and outputs
	   * the filtered content to the outputRenderTarget
	   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderTarget} inputRenderTarget
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderTarget} outputRenderTarget
	   * @private
	   */
	
	
	  CanvasFilterManager.prototype._applyFilters = function _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
	    var _this = this;
	
	    var flipRenderTarget = inputRenderTarget;
	    var flopRenderTarget = this._getOrCreateRenderTarget(true);
	
	    var lastFilter = filters[filters.length - 1];
	    filters.forEach(function (filter, i) {
	      var isLastFilter = filter === lastFilter;
	
	      if (!isLastFilter) {
	        // Render from flip to flop with filter
	        filter.apply(_this._renderer, flipRenderTarget, flopRenderTarget);
	
	        // Flip the render buffers
	        var temp = flipRenderTarget;
	        flipRenderTarget = flopRenderTarget;
	        flopRenderTarget = temp;
	      } else {
	        // Render to output
	        filter.apply(_this._renderer, flipRenderTarget, outputRenderTarget);
	      }
	    });
	
	    // Push the textures back into the texture pool to use them again later
	    this._textures.push(flipRenderTarget);
	    this._textures.push(flopRenderTarget);
	  };
	
	  /**
	   * Returns a render buffer from the pool or creates a new one
	   * @param  {Boolean} clear
	   * @return {PhotoEditorSDK.Engine.RenderTexture}
	   * @private
	   */
	
	
	  CanvasFilterManager.prototype._getOrCreateRenderTarget = function _getOrCreateRenderTarget(clear) {
	    var renderTarget = this._textures.pop();
	    if (!renderTarget) {
	      renderTarget = new _canvasRenderTarget2.default(this._textureFrame.width, this._textureFrame.height, this._renderer.getPixelRatio());
	    }
	
	    if (clear) {
	      renderTarget.clear();
	    }
	
	    return renderTarget;
	  };
	
	  /**
	   * Sets the filter stack to the given stack
	   * @param {Object[]} filterStack
	   */
	
	
	  CanvasFilterManager.prototype.setFilterStack = function setFilterStack(filterStack) {
	    this._filterStack = filterStack;
	  };
	
	  /**
	   * Disposes this CanvasFilterManager
	   */
	
	
	  CanvasFilterManager.prototype.dispose = function dispose() {};
	
	  return CanvasFilterManager;
	}();
	
	exports.default = CanvasFilterManager;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	var _webglRenderTarget = __webpack_require__(30);
	
	var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);
	
	var _quad = __webpack_require__(103);
	
	var _quad2 = _interopRequireDefault(_quad);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Manages the filters for a {@link PhotoEditorSDK.Engine.WebGLRenderer}
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	
	var WebGLFilterManager = function () {
	  function WebGLFilterManager(renderer) {
	    (0, _classCallCheck3.default)(this, WebGLFilterManager);
	
	    this._renderer = renderer;
	    this._filterStack = [{
	      renderTarget: renderer.getCurrentRenderTarget(),
	      filters: []
	    }];
	
	    this._currentFrame = null;
	    this._textures = [];
	    this._textureFrame = new _globals.Rectangle(0, 0, renderer.getWidth(), renderer.getHeight());
	
	    this._onContextChange = this._onContextChange.bind(this);
	    this._renderer.on('context', this._onContextChange);
	
	    // Initial context
	    this._onContextChange();
	  }
	
	  /**
	   * Resizes this FilterManager and its textures to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  WebGLFilterManager.prototype.resizeTo = function resizeTo(dimensions) {
	    this._textureFrame.width = dimensions.x;
	    this._textureFrame.height = dimensions.y;
	
	    this._textures.forEach(function (texture) {
	      return texture.resizeTo(dimensions);
	    });
	  };
	
	  /**
	   * Sets the filter stack to the given stack
	   * @param {Object[]} filterStack
	   */
	
	
	  WebGLFilterManager.prototype.setFilterStack = function setFilterStack(filterStack) {
	    this._filterStack = filterStack;
	  };
	
	  /**
	   * Returns a render target from the pool or creates a new one
	   * @param  {Boolean} clear
	   * @return {PhotoEditorSDK.Engine.WebGLRenderTarget}
	   * @private
	   */
	
	
	  WebGLFilterManager.prototype._getOrCreateRenderTarget = function _getOrCreateRenderTarget(clear) {
	    var renderTarget = this._textures.pop();
	    if (!renderTarget) {
	      renderTarget = new _webglRenderTarget2.default(this._renderer, this._textureFrame.width, this._textureFrame.height, this._renderer.getPixelRatio());
	    }
	    renderTarget.setFrame(this._currentFrame);
	
	    if (clear) {
	      renderTarget.clear();
	    }
	
	    return renderTarget;
	  };
	
	  /**
	   * Pushes the given filters to the
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
	   */
	
	
	  WebGLFilterManager.prototype.pushFilters = function pushFilters(displayObject, filters) {
	    var bounds = displayObject.getBounds();
	    this._currentFrame = bounds;
	
	    var renderTarget = this._getOrCreateRenderTarget();
	    this._renderer.setRenderTarget(renderTarget);
	    renderTarget.clear();
	
	    this._filterStack.push({ renderTarget: renderTarget, filters: filters });
	  };
	
	  /**
	   * Removes, applies and returns the last filters from the stack
	   * @return {Object}
	   */
	
	
	  WebGLFilterManager.prototype.popFilters = function popFilters() {
	    var _filterStack$pop = this._filterStack.pop();
	
	    var filters = _filterStack$pop.filters;
	    var renderTarget = _filterStack$pop.renderTarget;
	
	    var lastFilter = this._filterStack[this._filterStack.length - 1];
	
	    var inputRenderTarget = renderTarget;
	    var outputRenderTarget = lastFilter.renderTarget;
	
	    // Update the Quad's buffers
	    this._quad.map(this._textureFrame, inputRenderTarget.getFrame());
	
	    var shader = filters[0].getShaderForRenderer(this._renderer);
	    var vertexBuffer = this._quad.getVertexBuffer();
	    var indexBuffer = this._quad.getIndexBuffer();
	
	    var gl = this._renderer.getContext();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	
	    var attributeLocations = shader.getAttributeLocations();
	    gl.vertexAttribPointer(attributeLocations.a_position, 2, gl.FLOAT, false, 0, 0);
	    gl.vertexAttribPointer(attributeLocations.a_texCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);
	    gl.vertexAttribPointer(attributeLocations.a_color, 4, gl.FLOAT, false, 0, 4 * 4 * 4);
	
	    if (filters.length === 1) {
	      filters[0].apply(this._renderer, inputRenderTarget, outputRenderTarget);
	      this._textures.push(inputRenderTarget);
	    } else {
	      this._applyFilters(filters, inputRenderTarget, outputRenderTarget);
	    }
	
	    return filters;
	  };
	
	  /**
	   * Applies the given filters to the given inputRenderTarget and outputs
	   * the filtered content to the outputRenderTarget
	   * @param  {PhotoEditorSDK.Engine.Filter[]} filters
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} inputRenderTarget
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} outputRenderTarget
	   */
	
	
	  WebGLFilterManager.prototype._applyFilters = function _applyFilters(filters, inputRenderTarget, outputRenderTarget) {
	    var _this = this;
	
	    var flipRenderTarget = inputRenderTarget;
	    var flopRenderTarget = this._getOrCreateRenderTarget(true);
	
	    var lastFilter = filters[filters.length - 1];
	    filters.forEach(function (filter, i) {
	      var isLastFilter = filter === lastFilter;
	
	      if (!isLastFilter) {
	        // Render from flip to flop with filter
	        filter.apply(_this._renderer, flipRenderTarget, flopRenderTarget);
	
	        // Flip the render targets
	        var temp = flipRenderTarget;
	        flipRenderTarget = flopRenderTarget;
	        flopRenderTarget = temp;
	      } else {
	        // Render to output
	        filter.apply(_this._renderer, flipRenderTarget, outputRenderTarget);
	      }
	    });
	
	    // Push the textures back into the texture pool to use them again later
	    this._textures.push(flipRenderTarget);
	    this._textures.push(flopRenderTarget);
	  };
	
	  /**
	   * Gets called when the WebGL context has been changed
	   * @private
	   */
	
	
	  WebGLFilterManager.prototype._onContextChange = function _onContextChange() {
	    this._textures.length = 0;
	    /* istanbul ignore next */
	    if (this._renderer.isOfType('webgl')) {
	      this._quad = new _quad2.default(this._renderer);
	    }
	  };
	
	  /**
	   * Disposes this WebGLFilterManager
	   */
	
	
	  WebGLFilterManager.prototype.dispose = function dispose() {
	    this._renderer.off('context', this._onContextChange);
	    if (this._quad) {
	      this._quad.dispose();
	    }
	  };
	
	  return WebGLFilterManager;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = WebGLFilterManager;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	var _globals2 = _interopRequireDefault(_globals);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Log = _globals2.default.Log;
	
	/**
	 * Represents a WebGL shader with a vertex shader, a fragment shader, uniforms and attributes
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Shader = function () {
	  /**
	   * Creates a Shader
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @param  {String} vertexSource
	   * @param  {String} fragmentSource
	   * @param  {Object} uniforms
	   * @param  {String[]} attributes
	   */
	
	  function Shader(renderer, vertexSource, fragmentSource, uniforms, attributes) {
	    (0, _classCallCheck3.default)(this, Shader);
	
	    this._renderer = renderer;
	    this._vertexSource = vertexSource;
	    this._fragmentSource = fragmentSource;
	    this._uniforms = uniforms || {};
	    this._uniformLocations = {};
	    this._attributes = attributes || [];
	    this._attributeLocations = {};
	
	    this._onContextChange = this._onContextChange.bind(this);
	    this._renderer.on('context', this._onContextChange);
	
	    this._init();
	  }
	
	  /**
	   * Compiles this shader and caches the uniform locations
	   * @private
	   */
	
	
	  Shader.prototype._init = function _init() {
	    this._compile();
	
	    var gl = this._renderer.getContext();
	    gl.useProgram(this._program);
	
	    this._cacheUniformLocations();
	    this._cacheAttributeLocations();
	  };
	
	  /**
	   * Gets called when the attached Renderer changes its context
	   * @private
	   */
	
	
	  Shader.prototype._onContextChange = function _onContextChange() {
	    this._init();
	  };
	
	  /**
	   * Binds the given buffers for this shader
	   * @param {WebGLBuffer} vertexBuffer
	   * @param {WebGLBuffer} indexBuffer
	   */
	
	
	  Shader.prototype.setupBuffers = function setupBuffers(vertexBuffer, indexBuffer) {
	    var gl = this._renderer.getContext();
	    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	
	    gl.vertexAttribPointer(this._attributeLocations.a_position, 2, gl.FLOAT, false, _globals2.default.VERTEX_BYTE_SIZE, 0);
	    gl.vertexAttribPointer(this._attributeLocations.a_texCoord, 2, gl.FLOAT, false, _globals2.default.VERTEX_BYTE_SIZE, 2 * 4);
	    gl.vertexAttribPointer(this._attributeLocations.a_color, 4, gl.UNSIGNED_BYTE, true, _globals2.default.VERTEX_BYTE_SIZE, 4 * 4);
	  };
	
	  /**
	   * Synchronizes all uniforms with WebGL
	   */
	
	
	  Shader.prototype.syncUniforms = function syncUniforms() {
	    var _this = this;
	
	    Object.keys(this._uniforms).forEach(function (key) {
	      _this.syncUniform(key);
	    });
	  };
	
	  /**
	   * Synchronizes the uniform with the given name
	   * @param  {String} name
	   */
	
	
	  Shader.prototype.syncUniform = function syncUniform(name) {
	    var gl = this._renderer.getContext();
	    var uniform = this._uniforms[name];
	    var location = this._uniformLocations[name];
	
	    switch (uniform.type) {
	      case 'sampler2d':
	      case 'i':
	      case '1i':
	        gl.uniform1i(location, uniform.value);
	        break;
	      case 'f':
	      case '1f':
	        gl.uniform1f(location, uniform.value);
	        break;
	      case '2f':
	        gl.uniform2f(location, uniform.value[0], uniform.value[1]);
	        break;
	      case '3f':
	        gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
	        break;
	      case '4f':
	        gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
	        break;
	      case '2fv':
	        gl.uniform2fv(location, uniform.value);
	        break;
	      case 'mat3':
	      case 'mat3fv':
	        gl.uniformMatrix3fv(location, false, uniform.value);
	        break;
	      default:
	        Log.warn(this.constructor.name, 'Unknown uniform type: ' + uniform.type);
	    }
	  };
	
	  /**
	   * Caches the locations for all attributes
	   * @private
	   */
	
	
	  Shader.prototype._cacheAttributeLocations = function _cacheAttributeLocations() {
	    var _this2 = this;
	
	    var gl = this._renderer.getContext();
	    this._attributes.forEach(function (name) {
	      _this2._attributeLocations[name] = gl.getAttribLocation(_this2._program, name);
	    });
	  };
	
	  /**
	   * Caches the locations for all uniforms
	   * @private
	   */
	
	
	  Shader.prototype._cacheUniformLocations = function _cacheUniformLocations() {
	    var _this3 = this;
	
	    var gl = this._renderer.getContext();
	    var keys = Object.keys(this._uniforms);
	    keys.forEach(function (key) {
	      _this3._uniformLocations[key] = gl.getUniformLocation(_this3._program, key);
	    });
	  };
	
	  /**
	   * Compiles the vertex and fragment sources of this shader
	   * @private
	   */
	
	
	  Shader.prototype._compile = function _compile() {
	    var gl = this._renderer.getContext();
	
	    var vertexShader = this._compileShader(gl.VERTEX_SHADER, this._vertexSource);
	    var fragmentShader = this._compileShader(gl.FRAGMENT_SHADER, this._fragmentSource);
	
	    // Create the WebGL program and attach the shaders
	    var program = gl.createProgram();
	    gl.attachShader(program, vertexShader);
	    gl.attachShader(program, fragmentShader);
	
	    // Link the program
	    gl.linkProgram(program);
	
	    // Check linking status
	    // Check linking status
	    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
	    if (!linked) {
	      var errorMessage = gl.getProgramInfoLog(program);
	      if (gl.isContextLost()) errorMessage = 'WebGL context lost';
	      gl.deleteProgram(program);
	      Log.error(this.constructor.name, 'WebGL program linking error: ' + errorMessage);
	    }
	
	    this._program = program;
	  };
	
	  /**
	   * Creates and compiles a shader with the given type and source
	   * @param  {Number} shaderType
	   * @param  {String} shaderSource
	   * @return {WebGLShader}
	   * @private
	   */
	
	
	  Shader.prototype._compileShader = function _compileShader(shaderType, shaderSource) {
	    var gl = this._renderer.getContext();
	
	    // Create the shader and compile it
	    var shader = gl.createShader(shaderType);
	    gl.shaderSource(shader, shaderSource);
	    gl.compileShader(shader);
	
	    // Check compilation status
	    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	    if (!compiled) {
	      var errorMessage = gl.getShaderInfoLog(shader);
	      if (gl.isContextLost()) errorMessage = 'WebGL context lost';
	      gl.deleteShader(shader);
	      Log.error(this.constructor.name, 'WebGL shader compilation error: ' + errorMessage);
	    }
	
	    return shader;
	  };
	
	  /**
	   * Sets the given uniform to the given value
	   * @param {String} name
	   * @param {*} value
	   * @param {Boolean} sync = false
	   */
	
	
	  Shader.prototype.setUniform = function setUniform(name, value) {
	    var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	    this._uniforms[name].value = value;
	    if (sync) {
	      this.syncUniform(name);
	    }
	  };
	
	  /**
	   * Sets the given uniforms to their values
	   * @param {Object}  uniforms
	   * @param {Boolean} sync = false
	   */
	
	
	  Shader.prototype.setUniforms = function setUniforms(uniforms) {
	    var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    for (var name in uniforms) {
	      this._uniforms[name].value = uniforms[name];
	      if (sync) {
	        this.syncUniform(name);
	      }
	    }
	  };
	
	  /**
	   * Returns the uniforms
	   * @return {Object}
	   */
	
	
	  Shader.prototype.getUniforms = function getUniforms() {
	    return this._uniforms;
	  };
	
	  /**
	   * Returns the attributes
	   * @return {String[]}
	   */
	
	
	  Shader.prototype.getAttributes = function getAttributes() {
	    return this._attributes;
	  };
	
	  /**
	   * Returns the attribute locations
	   * @return {Object}
	   */
	
	
	  Shader.prototype.getAttributeLocations = function getAttributeLocations() {
	    return this._attributeLocations;
	  };
	
	  /**
	   * Returns this shader's WebGL program
	   * @return {WebGLProgram}
	   */
	
	
	  Shader.prototype.getProgram = function getProgram() {
	    return this._program;
	  };
	
	  /**
	   * Cleans up this shader
	   */
	
	
	  Shader.prototype.dispose = function dispose() {
	    var gl = this._renderer.getContext();
	    gl.deleteProgram(this._program);
	
	    this._uniforms = null;
	    this._uniformLocations = null;
	    this._attributes = null;
	    this._attributeLocations = null;
	
	    this._renderer.off('context', this._onContextChange);
	  };
	
	  return Shader;
	}();
	
	exports.default = Shader;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _shader = __webpack_require__(44);
	
	var _shader2 = _interopRequireDefault(_shader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The default texture shader
	 * @class
	 * @extends PhotoEditorSDK.Engine.Shader
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var TextureShader = function (_Shader) {
	  (0, _inherits3.default)(TextureShader, _Shader);
	
	  /**
	   * Creates a TextureShader
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @param  {String} vertexSource
	   * @param  {String} fragmentSource
	   */
	
	  function TextureShader(renderer, vertexSource, fragmentSource) {
	    (0, _classCallCheck3.default)(this, TextureShader);
	
	    vertexSource = vertexSource || TextureShader.defaultVertexSource;
	    fragmentSource = fragmentSource || TextureShader.defaultFragmentSource;
	
	    return (0, _possibleConstructorReturn3.default)(this, _Shader.call(this, renderer, vertexSource, fragmentSource, TextureShader.defaultUniforms, TextureShader.defaultAttributes));
	  }
	
	  return TextureShader;
	}(_shader2.default);
	
	/**
	 * The default vertex shader source code
	 * @type {String}
	 */
	
	
	TextureShader.defaultVertexSource = __webpack_require__(208);
	
	/**
	 * The default fragment shader source code
	 * @type {String}
	 */
	TextureShader.defaultFragmentSource = __webpack_require__(207);
	
	var matrix = new _globals.Matrix();
	
	/**
	 * The default uniforms
	 * @type {Object}
	 */
	TextureShader.defaultUniforms = {
	  u_image: {
	    type: 'sampler2d',
	    value: 0
	  },
	  u_projMatrix: {
	    type: 'mat3',
	    value: matrix.toArray()
	  }
	};
	
	/**
	 * The default WebGL attributes
	 * @type {String[]}
	 */
	TextureShader.defaultAttributes = ['a_position', 'a_texCoord', 'a_color'];
	
	exports.default = TextureShader;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A BaseTexture holds and handles the raw source of a texture
	 * @class
	 * @extends EventEmitter
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var BaseTexture = function (_EventEmitter) {
	  (0, _inherits3.default)(BaseTexture, _EventEmitter);
	
	  /**
	   * Creates a BaseTexture
	   * @param  {*} source
	   */
	
	  function BaseTexture(source) {
	    (0, _classCallCheck3.default)(this, BaseTexture);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this._onSourceLoaded = _this._onSourceLoaded.bind(_this);
	
	    _this._glTextures = {};
	    _this._source = source;
	
	    _this._glUnit = 0;
	    _this._mipMapping = false;
	    _this._magFilter = BaseTexture.NearestFilter;
	    _this._minFilter = BaseTexture.LinearFilter;
	    _this._pixelRatio = 1;
	    _this._loaded = false;
	    _this._frame = new _globals.Rectangle(0, 0, 100, 100);
	
	    if (source) {
	      _this._loadSource();
	    }
	    return _this;
	  }
	
	  /**
	   * Resizes this BaseTexture to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  BaseTexture.prototype.resizeTo = function resizeTo(dimensions) {
	    this._frame.width = dimensions.x;
	    this._frame.height = dimensions.y;
	  };
	
	  /**
	   * Loads the source
	   * @private
	   */
	
	
	  BaseTexture.prototype._loadSource = function _loadSource() {
	    var source = this._source;
	
	    var sourceLoaded = source.complete;
	    var sourceIsCanvas = source.constructor.name === 'Canvas' || source.tagName && source.tagName.toUpperCase() === 'CANVAS';
	    if (sourceLoaded || sourceIsCanvas) {
	      return this._onSourceLoaded();
	    }
	
	    source.addEventListener('load', this._onSourceLoaded);
	  };
	
	  /**
	   * Gets called when the source of this BaseTexture has been loaded
	   * @private
	   */
	
	
	  BaseTexture.prototype._onSourceLoaded = function _onSourceLoaded() {
	    this._loaded = true;
	    this._updateGLFilters();
	    this.emit('loaded');
	    this.update();
	  };
	
	  /**
	   * If mip-mapping is available, update GL filters accordingly
	   * @private
	   */
	
	
	  BaseTexture.prototype._updateGLFilters = function _updateGLFilters() {
	    var sourceDimensions = new _globals.Vector2(this._source.width, this._source.height);
	    if (_globals.Utils.isPowerOfTwo(sourceDimensions)) {
	      _globals.Log.info(this.constructor.name, 'Mip-mapping enabled');
	      this._minFilter = BaseTexture.BilinearFilter;
	      this._mipMapping = true;
	    }
	  };
	
	  /**
	   * Updates the cached dimensions of this BaseTexture's source
	   */
	
	
	  BaseTexture.prototype.update = function update() {
	    this._frame = new _globals.Rectangle(0, 0, this._source.width, this._source.height);
	    this.emit('update');
	  };
	
	  /**
	   * Returns the filter for the given direction from the given WebGL context
	   * @param  {WebGLRenderingContext} gl
	   * @param  {String} minOrMag
	   * @return {Number}
	   */
	
	
	  BaseTexture.prototype.getGLFilter = function getGLFilter(gl, minOrMag) {
	    var filter = function filter(value) {
	      switch (value) {
	        case BaseTexture.LinearFilter:
	          return gl.LINEAR;
	        case BaseTexture.NearestFilter:
	          return gl.NEAREST;
	        case BaseTexture.BilinearFilter:
	          return gl.LINEAR_MIPMAP_NEAREST;
	        case BaseTexture.TrilinearFilter:
	          return gl.LINEAR_MIPMAP_LINEAR;
	      }
	    };
	
	    switch (minOrMag) {
	      case 'min':
	        return filter(this._minFilter);
	      case 'mag':
	        return filter(this._magFilter);
	    }
	  };
	
	  /**
	   * Checks if this BaseTexture has been loaded
	   * @return {Boolean}
	   */
	
	
	  BaseTexture.prototype.isLoaded = function isLoaded() {
	    return this._loaded;
	  };
	
	  /**
	   * Sets the loaded state
	   * @param {Boolean} loaded
	   */
	
	
	  BaseTexture.prototype.setLoaded = function setLoaded(loaded) {
	    this._loaded = loaded;
	  };
	
	  /**
	   * Returns the source
	   * @return {*} s
	   */
	
	
	  BaseTexture.prototype.getSource = function getSource() {
	    return this._source;
	  };
	
	  /**
	   * Sets the source
	   * @param {*} source
	   */
	
	
	  BaseTexture.prototype.setSource = function setSource(source) {
	    this._source = source;
	  };
	
	  /**
	   * Returns the WebGL texture for the given renderer ID
	   * @param  {Number} id
	   * @return {WebGLTexture}
	   */
	
	
	  BaseTexture.prototype.getGLTextureForId = function getGLTextureForId(id) {
	    return this._glTextures[id];
	  };
	
	  /**
	   * Sets the WebGLTexture for the given renderer ID
	   * @param {WebGLTexture} texture
	   * @param {Number} id
	   */
	
	
	  BaseTexture.prototype.setGLTextureForId = function setGLTextureForId(texture, id) {
	    this._glTextures[id] = texture;
	  };
	
	  /**
	   * Returns the frame
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  BaseTexture.prototype.getFrame = function getFrame() {
	    return this._frame;
	  };
	
	  /**
	   * Sets the frame
	   * @param {PhotoEditorSDK.Math.Rectangle} frame
	   */
	
	
	  BaseTexture.prototype.setFrame = function setFrame(frame) {
	    this._frame = frame;
	  };
	
	  /**
	   * Returns the pixel ratio
	   * @return {Number}
	   */
	
	
	  BaseTexture.prototype.getPixelRatio = function getPixelRatio() {
	    return this._pixelRatio;
	  };
	
	  /**
	   * Sets the pixel ratio
	   * @param {Number} pixelRatio
	   */
	
	
	  BaseTexture.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
	    this._pixelRatio = pixelRatio;
	  };
	
	  /**
	   * Returns the WebGL texture unit
	   * @return {Number}
	   */
	
	
	  BaseTexture.prototype.getGLUnit = function getGLUnit() {
	    return this._glUnit;
	  };
	
	  /**
	   * Sets the WebGL texture unit
	   * @param {Number} glUnit
	   */
	
	
	  BaseTexture.prototype.setGLUnit = function setGLUnit(glUnit) {
	    this._glUnit = glUnit;
	  };
	
	  /**
	   * Sets the min filter to the given one
	   * @param {Number} minFilter
	   */
	
	
	  BaseTexture.prototype.setMinFilter = function setMinFilter(minFilter) {
	    this._minFilter = minFilter;
	  };
	
	  /**
	   * Returns this texture's min filter
	   * @return {Number}
	   */
	
	
	  BaseTexture.prototype.getMinFilter = function getMinFilter() {
	    return this._minFilter;
	  };
	
	  /**
	   * Sets the mag filter to the given one
	   * @param {Number} magFilter
	   */
	
	
	  BaseTexture.prototype.setMagFilter = function setMagFilter(magFilter) {
	    this._magFilter = magFilter;
	  };
	
	  /**
	   * Returns this texture's mag filter
	   * @return {Number}
	   */
	
	
	  BaseTexture.prototype.getMagFilter = function getMagFilter() {
	    return this._magFilter;
	  };
	
	  /**
	   * Disposes the WebGL textures for the given renderer ID
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	
	  BaseTexture.prototype.disposeGLTextures = function disposeGLTextures(renderer) {
	    if (renderer.isOfType('webgl')) {
	      var gl = renderer.getContext();
	      gl.deleteTexture(this._glTextures[gl.id]);
	      delete this._glTextures[gl.id];
	    }
	  };
	
	  /**
	   * Checks if mip-mapping is enabled for this texture
	   * @return {Boolean}
	   */
	
	
	  BaseTexture.prototype.isMipMappingEnabled = function isMipMappingEnabled() {
	    return this._mipMapping;
	  };
	
	  /**
	   * Cleans up this object
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   */
	
	
	  BaseTexture.prototype.dispose = function dispose(renderer) {
	    this.disposeGLTextures(renderer);
	  };
	
	  return BaseTexture;
	}(_globals.EventEmitter); /*
	                           * This file is part of PhotoEditorSDK.
	                           *
	                           * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                           * All rights reserved.
	                           *
	                           * Redistribution and use in source and binary forms, without
	                           * modification, are permitted provided that the following license agreement
	                           * is approved and a legal/financial contract was signed by the user.
	                           * The license agreement can be found under following link:
	                           *
	                           * https://www.photoeditorsdk.com/LICENSE.txt
	                           */
	
	BaseTexture.NearestFilter = 0;
	BaseTexture.LinearFilter = 1;
	BaseTexture.BilinearFilter = 2;
	BaseTexture.TrilinearFilter = 3;
	
	exports.default = BaseTexture;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Sprite = function (_Configurable) {
	  (0, _inherits3.default)(Sprite, _Configurable);
	
	  function Sprite(operation, options) {
	    (0, _classCallCheck3.default)(this, Sprite);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Configurable.call(this, options));
	
	    _this._operation = operation;
	    _this._dirtiness = {};
	    _this.id = _globals.Utils.getUUID();
	
	    _this._identitySprite = new _globals.Engine.Sprite();
	    _this._sprite = new _globals.Engine.Sprite();
	
	    if (_this._options.adjustments) {
	      _this._onOptionsChange = _this._onOptionsChange.bind(_this);
	      _this._options.adjustments.on('updated', _this._onOptionsChange);
	    }
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when options have been changed. Sets this operation to dirty.
	   * @private
	   */
	
	
	  Sprite.prototype._onOptionsChange = function _onOptionsChange() {
	    var dirtiness = this._dirtiness;
	    for (var id in dirtiness) {
	      dirtiness[id] = true;
	    }
	  };
	
	  /**
	   * Returns the DisplayObject of this Sprite
	   * @return {PhotoEditorSDK.Engine.Sprite}
	   */
	
	
	  Sprite.prototype.getDisplayObject = function getDisplayObject() {
	    return this._sprite;
	  };
	
	  /**
	   * Renders this sprite
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   */
	
	
	  Sprite.prototype.update = function update(sdk) {
	    this._sprite.setAnchor(this._options.anchor);
	    this._sprite.setPosition(this._options.position.clone());
	
	    if (this._options.scale) {
	      this._sprite.setScale(this._options.scale.clone());
	    }
	    this._sprite.updateTransform();
	
	    var frame = this._sprite.getTexture().getFrame();
	    var spriteDimensions = new _globals.Vector2(frame.width, frame.height);
	
	    this._sprite.setPivot(this._options.pivot.clone().multiply(spriteDimensions));
	    this._sprite.setRotation(this._options.rotation);
	
	    return _globals.Promise.resolve();
	  };
	
	  /**
	   * Applies a flip in the given direction
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {String} direction
	   */
	
	
	  Sprite.prototype.applyFlip = function applyFlip(sdk, direction) {
	    var finalDimensions = sdk.getFinalDimensions();
	    var position = this._options.position;
	    switch (direction) {
	      case 'horizontal':
	        position.x = finalDimensions.x - position.x;
	        this.set({
	          flipHorizontally: !this._options.flipHorizontally,
	          position: position
	        });
	        break;
	      case 'vertical':
	        position.y = finalDimensions.y - position.y;
	        this.set({
	          flipVertically: !this._options.flipVertically,
	          position: position
	        });
	        break;
	    }
	  };
	
	  /**
	   * Checks if this operation is dirty for the given renderer
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
	   * @return {Boolean}
	   */
	
	
	  Sprite.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
	    if (!(renderer.id in this._dirtiness)) {
	      this._dirtiness[renderer.id] = true;
	    }
	    return this._dirtiness[renderer.id];
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	
	  Sprite.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    this._dirtiness[renderer.id] = dirty;
	  };
	
	  /**
	   * Sets the dirtiness for all renderers
	   * @param {Boolean} dirty
	   */
	
	
	  Sprite.prototype.setDirty = function setDirty(dirty) {
	    for (var rendererId in this._dirtiness) {
	      this._dirtiness[rendererId] = dirty;
	    }
	  };
	
	  /**
	   * Cleans up this Sprite
	   */
	
	
	  Sprite.prototype.dispose = function dispose() {
	    if (this._options.adjustments) {
	      this._options.adjustments.off('updated', this._onOptionsChange);
	    }
	  };
	
	  return Sprite;
	}(_globals.Configurable); /*
	                           * This file is part of PhotoEditorSDK.
	                           *
	                           * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                           * All rights reserved.
	                           *
	                           * Redistribution and use in source and binary forms, without
	                           * modification, are permitted provided that the following license agreement
	                           * is approved and a legal/financial contract was signed by the user.
	                           * The license agreement can be found under following link:
	                           *
	                           * https://www.photoeditorsdk.com/LICENSE.txt
	                           */
	
	exports.default = Sprite;

/***/ },
/* 48 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 49 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(25)
	  , dPs         = __webpack_require__(189)
	  , enumBugKeys = __webpack_require__(49)
	  , IE_PROTO    = __webpack_require__(55)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(85)('iframe')
	    , i      = enumBugKeys.length
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(182).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write('<script>document.F=Object</script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};

/***/ },
/* 53 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(15).f
	  , has = __webpack_require__(14)
	  , TAG = __webpack_require__(20)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(56)('keys')
	  , uid    = __webpack_require__(36);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 57 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(27);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(11)
	  , core           = __webpack_require__(18)
	  , LIBRARY        = __webpack_require__(51)
	  , wksExt         = __webpack_require__(60)
	  , defineProperty = __webpack_require__(15).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(20);

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(37).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(61).setImmediate, __webpack_require__(61).clearImmediate))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Matrix = exports.Rectangle = exports.Vector2 = undefined;
	
	var _vector = __webpack_require__(23);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _rectangle = __webpack_require__(74);
	
	var _rectangle2 = _interopRequireDefault(_rectangle);
	
	var _matrix = __webpack_require__(73);
	
	var _matrix2 = _interopRequireDefault(_matrix);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Some classes that help us do the math
	 * @namespace PhotoEditorSDK.Math
	 */
	exports.Vector2 = _vector2.default;
	exports.Rectangle = _rectangle2.default;
	exports.Matrix = _matrix2.default; /*
	                                    * This file is part of PhotoEditorSDK.
	                                    *
	                                    * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                                    * All rights reserved.
	                                    *
	                                    * Redistribution and use in source and binary forms, without
	                                    * modification, are permitted provided that the following license agreement
	                                    * is approved and a legal/financial contract was signed by the user.
	                                    * The license agreement can be found under following link:
	                                    *
	                                    * https://www.photoeditorsdk.com/LICENSE.txt
	                                    */

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _eventEmitter = __webpack_require__(21);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Holds an array of {@link PhotoEditorSDK.Operation} instances and handles their dirtiness
	 * @class
	 * @memberof PhotoEditorSDK
	 */
	
	var OperationsStack = function (_EventEmitter) {
	  (0, _inherits3.default)(OperationsStack, _EventEmitter);
	
	  /**
	   * Creates an OperationsStack
	   * @param  {PhotoEditorSDK.Operation[]} [operations = []]
	   */
	
	  function OperationsStack() {
	    var operations = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	    (0, _classCallCheck3.default)(this, OperationsStack);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	
	    _this._stack = operations;
	    _this._stack.forEach(function (operation) {
	      operation.on('update', _this._onOperationUpdate);
	    });
	    return _this;
	  }
	
	  /**
	   * Clears this operations stack
	   */
	
	
	  OperationsStack.prototype.clear = function clear() {
	    var _this2 = this;
	
	    this.forEach(function (operation) {
	      return _this2.remove(operation);
	    });
	    this._stack = [];
	  };
	
	  /**
	   * Gets called when an operation is about to be updated
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  OperationsStack.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    this.emit(_globals.Constants.Events.OPERATION_UPDATED, operation, options);
	  };
	
	  /**
	   * Passes Array#forEach
	   * @param  {Function} iterator
	   * @return {Array}
	   */
	
	
	  OperationsStack.prototype.forEach = function forEach(iterator) {
	    return this._stack.filter(function (op) {
	      return !!op;
	    }).forEach(iterator);
	  };
	
	  /**
	   * Renders all operations
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   */
	
	
	  OperationsStack.prototype.render = function render(sdk) {
	    var operations = this._stack.filter(function (op) {
	      return !!op;
	    });
	
	    // Find first operation from end of array that is not dirty
	    operations.reverse();
	    var firstUndirtyOperation = operations.filter(function (o) {
	      return !o.isDirtyForRenderer(sdk.getRenderer());
	    })[0];
	    var firstUndirtyIndex = operations.indexOf(firstUndirtyOperation);
	
	    operations.reverse();
	
	    // Skip operations that would be overwritten by succeeding operations
	    var startIndex = 0;
	    if (firstUndirtyIndex !== -1) {
	      startIndex = operations.length - firstUndirtyIndex - 1;
	    }
	
	    for (var index = 0; index < startIndex; index++) {
	      _globals.Log.info(this.constructor.name, 'Skipping ' + operations[index].constructor.name);
	    }
	
	    var promise = _promise2.default.resolve();
	
	    var _loop = function _loop(_index) {
	      var operation = operations[_index];
	      promise = promise.then(function () {
	        return operation.render(sdk);
	      });
	    };
	
	    for (var _index = startIndex; _index < operations.length; _index++) {
	      _loop(_index);
	    }
	
	    return promise;
	  };
	
	  /**
	   * Validates the settings of all operations
	   * @return {Promise}
	   */
	
	
	  OperationsStack.prototype.validateSettings = function validateSettings() {
	    return _promise2.default.all(this._stack.filter(function (op) {
	      return !!op;
	    }).map(function (op) {
	      return op.validateSettings();
	    }));
	  };
	
	  /**
	   * Sets all operations to dirty
	   */
	
	
	  OperationsStack.prototype.setAllToDirty = function setAllToDirty() {
	    this.forEach(function (op) {
	      return op.setDirty(true);
	    });
	  };
	
	  /**
	   * Finds the first dirty operation and sets all following operations to dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	
	  OperationsStack.prototype.updateDirtinessForRenderer = function updateDirtinessForRenderer(renderer) {
	    var dirtyFound = false;
	    for (var i = 0; i < this._stack.length; i++) {
	      var _operation = this._stack[i];
	      if (!_operation) continue;
	      if (_operation.isDirtyForRenderer(renderer)) {
	        dirtyFound = true;
	      }
	
	      if (dirtyFound) {
	        _operation.setDirtyForRenderer(true, renderer);
	      }
	    }
	  };
	
	  /**
	   * Adds the given operation to this stack
	   * @return {PhotoEditorSDK.Operation}
	   */
	
	
	  OperationsStack.prototype.push = function push(operation) {
	    this._stack.push(operation);
	    operation.on('update', this._onOperationUpdate);
	  };
	
	  /**
	   * Returns a cloned instance of this stack
	   * @return {PhotoEditorSDK.OperationsStack}
	   */
	
	
	  OperationsStack.prototype.clone = function clone() {
	    return new OperationsStack(this._stack.slice(0));
	  };
	
	  /**
	   * Returns the operation at the given index
	   * @param  {Number} index
	   * @return {PhotoEditorSDK.Operation}
	   */
	
	
	  OperationsStack.prototype.get = function get(index) {
	    return this._stack[index];
	  };
	
	  /**
	   * Sets the operation at the given index to the given one
	   * @param  {Number} index
	   * @param  {PhotoEditorSDK.Operation} operation
	   */
	
	
	  OperationsStack.prototype.set = function set(index, operation) {
	    if (this._stack[index]) {
	      this._stack[index].off('update', this._onOperationUpdate);
	      this._stack[index].dispose();
	    }
	    this._stack[index] = operation;
	    operation.on('update', this._onOperationUpdate);
	  };
	
	  /**
	   * Removes the given operation
	   * @param  {PhotoEditorSDK.Operation} operation
	   */
	
	
	  OperationsStack.prototype.remove = function remove(operation) {
	    var index = this._stack.indexOf(operation);
	    if (index === -1) {
	      return;
	    }
	    if (this._stack[index]) {
	      this._stack[index].off('update', this._onOperationUpdate);
	      this._stack[index].dispose();
	    }
	    this._stack.splice(index, 1);
	  };
	
	  /**
	   * Removes the operation at the given index
	   * @param  {Number} index
	   */
	
	
	  OperationsStack.prototype.removeAt = function removeAt(index) {
	    if (this._stack[index]) {
	      this._stack[index].off('update', this._onOperationUpdate);
	      this._stack[index].dispose();
	    }
	    this._stack[index] = undefined;
	  };
	
	  /**
	   * Returns the stack
	   * @return {PhotoEditorSDK.Operation[]}
	   */
	
	
	  OperationsStack.prototype.getStack = function getStack() {
	    return this._stack;
	  };
	
	  return OperationsStack;
	}(_eventEmitter2.default); /*
	                            * This file is part of PhotoEditorSDK.
	                            *
	                            * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                            * All rights reserved.
	                            *
	                            * Redistribution and use in source and binary forms, without
	                            * modification, are permitted provided that the following license agreement
	                            * is approved and a legal/financial contract was signed by the user.
	                            * The license agreement can be found under following link:
	                            *
	                            * https://www.photoeditorsdk.com/LICENSE.txt
	                            */
	
	exports.default = OperationsStack;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _filterOperation = __webpack_require__(116);
	
	Object.defineProperty(exports, 'FilterOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_filterOperation).default;
	  }
	});
	
	var _cropOperation = __webpack_require__(115);
	
	Object.defineProperty(exports, 'CropOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_cropOperation).default;
	  }
	});
	
	var _orientationOperation = __webpack_require__(159);
	
	Object.defineProperty(exports, 'OrientationOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_orientationOperation).default;
	  }
	});
	
	var _adjustmentsOperation = __webpack_require__(111);
	
	Object.defineProperty(exports, 'AdjustmentsOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_adjustmentsOperation).default;
	  }
	});
	
	var _linearFocusOperation = __webpack_require__(158);
	
	Object.defineProperty(exports, 'LinearFocusOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_linearFocusOperation).default;
	  }
	});
	
	var _radialFocusOperation = __webpack_require__(160);
	
	Object.defineProperty(exports, 'RadialFocusOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_radialFocusOperation).default;
	  }
	});
	
	var _borderOperation = __webpack_require__(112);
	
	Object.defineProperty(exports, 'BorderOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_borderOperation).default;
	  }
	});
	
	var _spriteOperation = __webpack_require__(161);
	
	Object.defineProperty(exports, 'SpriteOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_spriteOperation).default;
	  }
	});
	
	var _watermarkOperation = __webpack_require__(166);
	
	Object.defineProperty(exports, 'WatermarkOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_watermarkOperation).default;
	  }
	});
	
	var _brushOperation = __webpack_require__(113);
	
	Object.defineProperty(exports, 'BrushOperation', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_brushOperation).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = {
		"name": "photoeditorsdk",
		"version": "3.2.0",
		"description": "The most comprehensive photo editor SDK for HTML5",
		"repository": "http://github.com/imgly/imgly-sdk-html5",
		"author": "Photo Editor SDK <contact@photoeditorsdk.com>",
		"license": "SEE LICENSE IN LICENSE.md",
		"scripts": {
			"release": "node scripts/release",
			"render-filter-previews": "babel-node scripts/render-filter-previews",
			"release:dry": "ENV=production UPLOAD=false node_modules/.bin/gulp release",
			"test": "node_modules/.bin/mocha",
			"test-webgl": "node_modules/.bin/mocha test-webgl",
			"coveralls": "npm run coverage && cat ./coverage/lcov.info | node_modules/.bin/coveralls && rm -rf ./coverage",
			"coverage": "NODE_ENV=test node_modules/.bin/istanbul cover node_modules/.bin/_mocha -x **/ui/**"
		},
		"devDependencies": {
			"canvas": "^1.3.12",
			"gl": "^3.0.3",
			"babel-core": "^6.6.4",
			"babel-loader": "^6.2.4",
			"babel-plugin-external-helpers-2": "^6.3.13",
			"babel-plugin-transform-es2015-classes": "^6.6.4",
			"babel-plugin-transform-runtime": "^6.6.0",
			"babel-preset-es2015": "^6.6.0",
			"babel-preset-react": "^6.5.0",
			"babel-register": "^6.6.0",
			"babel-runtime": "^6.6.1",
			"chai": "^3.4.0",
			"chai-as-promised": "^5.1.0",
			"classnames": "^2.1.3",
			"compass-mixins": "git://github.com/xzyfer/compass-mixins.git#patch-1",
			"coveralls": "^2.11.2",
			"del": "^2.0.0",
			"gulp": "^3.8.10",
			"gulp-9e-sass-lint": "0.0.8",
			"gulp-changed": "^1.3.0",
			"gulp-github-release": "^1.1.2",
			"gulp-jsdoc3": "^0.2.0",
			"gulp-notify": "^1.3.1",
			"gulp-rename": "~1.2.0",
			"gulp-sass": "^2.0.4",
			"gulp-sequence": "^0.4.1",
			"gulp-sourcemaps": "^1.5.2",
			"gulp-standard": "^6.0.5",
			"gulp-uglify": "^1.4.2",
			"gulp-util": "~2.2.16",
			"gulp-watch": "^4.3.5",
			"gulp-webserver": "^0.9.1",
			"gulp-yuicompressor": "0.0.3",
			"gulp-zip": "^3.2.0",
			"istanbul": "^1.0.0-alpha.2",
			"jaguarjs-jsdoc": "git://github.com/imgly/jaguarjs-jsdoc.git#master",
			"jsdoc": "git://github.com/jsdoc3/jsdoc.git#master",
			"json-loader": "^0.5.2",
			"mocha": "^2.3.3",
			"mocha-lcov-reporter": "0.0.1",
			"performance-now": "^0.2.0",
			"prompt": "^1.0.0",
			"raw-loader": "^0.5.1",
			"react": "^0.14.7",
			"react-dom": "^0.14.7",
			"require-dir": "^0.3.0",
			"run-sequence": "~0.3.6",
			"should": "^4.3.0",
			"sinon": "^1.17.3",
			"sinon-chai": "^2.8.0",
			"transform-loader": "^0.2.2",
			"vinyl-source-stream": "0.1.1",
			"webpack": "^2.1.0-beta.6",
			"webpack-notifier": "^1.2.1",
			"webpack-stream": "^3.2.0"
		},
		"standard": {
			"globals": [
				"describe",
				"context",
				"before",
				"beforeEach",
				"after",
				"afterEach",
				"it",
				"expect"
			]
		}
	};

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _displayObject = __webpack_require__(41);
	
	var _displayObject2 = _interopRequireDefault(_displayObject);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A container for DisplayObject instances
	 * @class
	 * @extends PhotoEditorSDK.Engine.DisplayObject
	 * @memberof PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Container = function (_DisplayObject) {
	  (0, _inherits3.default)(Container, _DisplayObject);
	
	  /**
	   * Creates a Container
	   * @override
	   */
	
	  function Container() {
	    (0, _classCallCheck3.default)(this, Container);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _DisplayObject.call.apply(_DisplayObject, [this].concat(args)));
	
	    _this._children = [];
	    _this._filters = [];
	    return _this;
	  }
	
	  /**
	   * Adds the given filter to the filter stack
	   * @param {PhotoEditorSDK.Engine.Filter} filter
	   */
	
	
	  Container.prototype.addFilter = function addFilter(filter) {
	    this._filters.push(filter);
	  };
	
	  /**
	   * Removes the given filter from the filter stack
	   * @param  {PhotoEditorSDK.Engine.Filter} filter
	   * @return {Boolean} - Whether the filter has been removed
	   */
	
	
	  Container.prototype.removeFilter = function removeFilter(filter) {
	    var index = this._filters.indexOf(filter);
	    if (index !== -1) {
	      this._filters.splice(index, 1);
	      return true;
	    }
	    return false;
	  };
	
	  /**
	   * Sets the filters
	   * @param {Array.<PhotoEditorSDK.Engine.Filter>} filters
	   */
	
	
	  Container.prototype.setFilters = function setFilters(filters) {
	    this._filters = filters;
	  };
	
	  /**
	   * Adds the given DisplayObject to the list of children
	   * @param {PhotoEditorSDK.Engine.DisplayObject} child
	   */
	
	
	  Container.prototype.addChild = function addChild(child) {
	    // Remove from previous parent
	    var originalParent = child.getParent();
	    if (originalParent !== null) {
	      originalParent.removeChild(child);
	    }
	    child.setParent(this);
	
	    this._children.push(child);
	  };
	
	  /**
	   * Prepends the given DisplayObject to the list of children
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} child
	   */
	
	
	  Container.prototype.prependChild = function prependChild(child) {
	    // Remove from previous parent
	    var originalParent = child.getParent();
	    if (originalParent !== null) {
	      originalParent.removeChild(child);
	    }
	    child.setParent(this);
	
	    this._children.unshift(child);
	  };
	
	  /**
	   * Checks whether this container has the given child
	   * @param  {PhotoEditorSDK.Engine.DisplayObject}  child
	   * @return {Boolean}
	   */
	
	
	  Container.prototype.hasChild = function hasChild(child) {
	    var index = this._children.indexOf(child);
	    return index !== -1;
	  };
	
	  /**
	   * Removes the given object from the list of children
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} child
	   */
	
	
	  Container.prototype.removeChild = function removeChild(child) {
	    var index = this._children.indexOf(child);
	    if (index !== -1) {
	      this._children.splice(index, 1);
	      child.setParent(null);
	    } else {
	      _globals.Log.info(this.constructor.name, 'Tried to remove a child that does not exist');
	    }
	  };
	
	  /**
	   * Removes all children
	   */
	
	
	  Container.prototype.clearChildren = function clearChildren() {
	    this._children = [];
	  };
	
	  /**
	   * Renders this DisplayObject using the given WebGLRenderer
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @override
	   */
	
	
	  Container.prototype.renderWebGL = function renderWebGL(renderer) {
	    if (!this._visible) {
	      return;
	    }
	
	    var filterManager = renderer.getFilterManager();
	    if (this._filters && this._filters.length) {
	      filterManager.pushFilters(this, this._filters);
	    }
	
	    renderer.getCurrentObjectRenderer().start();
	
	    this._renderWebGL(renderer);
	
	    this._children.forEach(function (child) {
	      child.renderWebGL(renderer);
	    });
	
	    renderer.getCurrentObjectRenderer().flush();
	
	    if (this._filters && this._filters.length) {
	      filterManager.popFilters();
	    }
	    renderer.getCurrentObjectRenderer().start();
	  };
	
	  /**
	   * Renders the contents of this container
	   * @param {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @protected
	   */
	
	
	  Container.prototype._renderWebGL = function _renderWebGL(renderer) {};
	
	  /**
	   * Renders this DisplayObject using the given CanvasRenderer
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @override
	   */
	
	
	  Container.prototype.renderCanvas = function renderCanvas(renderer) {
	    if (!this._visible) {
	      return;
	    }
	
	    var filterManager = renderer.getFilterManager();
	    if (this._filters && this._filters.length) {
	      filterManager.pushFilters(this, this._filters);
	    }
	
	    this._renderCanvas(renderer);
	    this._children.forEach(function (child) {
	      child.renderCanvas(renderer);
	    });
	
	    if (this._filters && this._filters.length) {
	      filterManager.popFilters();
	    }
	  };
	
	  /**
	   * Renders the contents of this container
	   * @param {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @protected
	   */
	
	
	  Container.prototype._renderCanvas = function _renderCanvas(renderer) {};
	
	  /**
	   * Updates the world transform for this DisplayObject
	   */
	
	
	  Container.prototype.updateTransform = function updateTransform() {
	    _DisplayObject.prototype.updateTransform.call(this);
	    this._children.forEach(function (child) {
	      child.updateTransform();
	    });
	  };
	
	  /**
	   * Returns the non-global bounds of this DisplayObject
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Container.prototype.getLocalBounds = function getLocalBounds() {
	    if (this._localBoundsNeedUpdate) {
	      // @TODO Calculate bounds by looking at children
	      this._localBoundsNeedUpdate = false;
	    }
	    return this._localBounds.clone();
	  };
	
	  /**
	   * Returns the bounds for this DisplayObject
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Container.prototype.getBounds = function getBounds() {
	    if (this._boundsNeedUpdate) {
	      // @TODO Calculate bounds by looking at children
	      this._boundsNeedUpdate = false;
	    }
	    return this._bounds.clone();
	  };
	
	  /**
	   * Returns this Container's children
	   * @return {PhotoEditorSDK.Engine.DisplayObject[]}
	   */
	
	
	  Container.prototype.getChildren = function getChildren() {
	    return this._children;
	  };
	
	  /**
	   * Returns this Container's filters
	   * @return {PhotoEditorSDK.Engine.Filter[]}
	   */
	
	
	  Container.prototype.getFilters = function getFilters() {
	    return this._filters;
	  };
	
	  /**
	   * Disposes this Container
	   */
	
	
	  Container.prototype.dispose = function dispose() {};
	
	  return Container;
	}(_displayObject2.default);
	
	exports.default = Container;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _utils = __webpack_require__(105);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The base class for all renderers
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BaseRenderer = function (_EventEmitter) {
	  (0, _inherits3.default)(BaseRenderer, _EventEmitter);
	
	  /**
	   * Create a BaseRenderer instance
	   * @param  {Number} width
	   * @param  {Number} height
	   * @param  {Object} options = {}
	   * @param  {Number} [options.pixelRatio = 1]
	   * @param  {PhotoEditorSDK.Color} [options.clearColor = PhotoEditorSDK.Color.TRANSPARENT]
	   * @param  {Boolean} [options.debug = false]
	   */
	
	  function BaseRenderer(width, height) {
	    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
	    (0, _classCallCheck3.default)(this, BaseRenderer);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this._options = _utils2.default.defaults(options, {
	      pixelRatio: 1,
	      transparent: false,
	      clearColor: _globals.Color.BLACK,
	      debug: false
	    });
	
	    _this.setMaxListeners(25);
	    _this._width = width || 800;
	    _this._height = height || 600;
	    _this._dimensions = new _globals.Vector2(_this._width, _this._height);
	    _this._maxTextureSize = null;
	    _this._pixelRatio = _this._options.pixelRatio;
	    _this._clearColor = _this._options.transparent ? _globals.Color.TRANSPARENT : _this._options.clearColor || _globals.Color.BLACK;
	    return _this;
	  }
	
	  /**
	   * Sets the canvas to the given one
	   * @param {HTMLCanvasElement} canvas
	   */
	
	
	  BaseRenderer.prototype.setCanvas = function setCanvas(canvas) {
	    this._canvas = canvas;
	
	    this._createContext();
	    this._onBeforeContext();
	    this._setupContext();
	
	    this.resizeTo(new _globals.Vector2(this._width, this._height));
	  };
	
	  /**
	   * Returns the current canvas
	   * @return {HTMLCanvasElement}
	   */
	
	
	  BaseRenderer.prototype.getCanvas = function getCanvas() {
	    return this._canvas;
	  };
	
	  /**
	   * Gets called before the context has been set up
	   * @protected
	   */
	
	
	  BaseRenderer.prototype._onBeforeContext = function _onBeforeContext() {};
	
	  /**
	   * Resizes the context and view to the given size
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  BaseRenderer.prototype.resizeTo = function resizeTo(dimensions) {
	    var pixelRatio = this._options.pixelRatio;
	
	    this._width = dimensions.x * pixelRatio;
	    this._height = dimensions.y * pixelRatio;
	
	    this._canvas.width = this._width;
	    this._canvas.height = this._height;
	
	    if (this._canvas.style) {
	      this._canvas.style.width = this._width / pixelRatio + 'px';
	      this._canvas.style.height = this._height / pixelRatio + 'px';
	    }
	
	    this._dimensions = dimensions.clone();
	  };
	
	  /**
	   * Gets the rendering context for this renderer
	   * @returns {Object}
	   * @protected
	   * @abstract
	   */
	
	
	  BaseRenderer.prototype._createContext = function _createContext() {
	    _globals.Log.warn(this.constructor.name, '`_createContext` is abstract and not implemented in inherited class');
	  };
	
	  /**
	   * Sets up the rendering context for this renderer
	   * @protected
	   * @abstract
	   */
	
	
	  BaseRenderer.prototype._setupContext = function _setupContext() {
	    _globals.Log.warn(this.constructor.name, '`_setupContext` is abstract and not implemented in inherited class');
	  };
	
	  /**
	   * Renders the given displayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @abstract
	   */
	
	
	  BaseRenderer.prototype.render = function render(displayObject) {
	    _globals.Log.warn(this.constructor.name, '`render` is abstract and not implemented in inherited class');
	  };
	
	  /**
	   * Returns the maximum dimensions
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.getMaxDimensions = function getMaxDimensions() {
	    return null;
	  };
	
	  /**
	   * Returns the current rendering context
	   * @return {RenderingContext}
	   */
	
	
	  BaseRenderer.prototype.getContext = function getContext() {
	    return this._context;
	  };
	
	  /**
	   * Returns the current width
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.getWidth = function getWidth() {
	    return this._dimensions.x;
	  };
	
	  /**
	   * Returns the current height
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.getHeight = function getHeight() {
	    return this._dimensions.y;
	  };
	
	  /**
	   * Returns the current dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  BaseRenderer.prototype.getDimensions = function getDimensions() {
	    return this._dimensions;
	  };
	
	  /**
	   * Returns the current pixel ratio
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.getPixelRatio = function getPixelRatio() {
	    return this._pixelRatio;
	  };
	
	  /**
	   * Sets the pixel ratio
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.setPixelRatio = function setPixelRatio(pixelRatio) {
	    this._pixelRatio = pixelRatio;
	  };
	
	  /**
	   * Returns the maximum texture size
	   * @return {Number}
	   */
	
	
	  BaseRenderer.prototype.getMaxTextureSize = function getMaxTextureSize() {
	    return this._maxTextureSize;
	  };
	
	  /**
	   * Returns the current filter manager
	   * @return {PhotoEditorSDK.Engine.FilterManager}
	   */
	
	
	  BaseRenderer.prototype.getFilterManager = function getFilterManager() {
	    return this._filterManager;
	  };
	
	  /**
	   * Sets the filter manager
	   * @param {PhotoEditorSDK.Engine.FilterManager} filterManager
	   */
	
	
	  BaseRenderer.prototype.setFilterManager = function setFilterManager(filterManager) {
	    this._filterManager = filterManager;
	  };
	
	  /**
	   * Checks if this renderer is supported on the current device and browser
	   * @return {Boolean}
	   */
	
	
	  BaseRenderer.isSupported = function isSupported() {
	    return true;
	  };
	
	  /**
	   * Checks if this renderer's type is equal to the given one
	   * @param  {String}  type
	   * @return {Boolean}
	   */
	
	
	  BaseRenderer.prototype.isOfType = function isOfType(type) {
	    return this._type === type;
	  };
	
	  /**
	   * Disposes this Renderer
	   * @abstract
	   */
	
	
	  BaseRenderer.prototype.dispose = function dispose() {
	    _globals.Log.warn(this.constructor.name, '`dispose` is abstract and not implemented in inherited class');
	  };
	
	  return BaseRenderer;
	}(_globals.EventEmitter);
	
	exports.default = BaseRenderer;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * The base class for all ObjectRenderer classes
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	
	var ObjectRenderer = function () {
	  /**
	   * Creates an ObjectRenderer
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	  function ObjectRenderer(renderer) {
	    (0, _classCallCheck3.default)(this, ObjectRenderer);
	
	    this._renderer = renderer;
	
	    this._onContextChange = this._onContextChange.bind(this);
	    this._renderer.on('context', this._onContextChange);
	  }
	
	  /**
	   * Gets called when the rendering context changes
	   * @private
	   */
	
	
	  ObjectRenderer.prototype._onContextChange = function _onContextChange() {};
	
	  /**
	   * Gets called when this object renderer is activated
	   */
	
	
	  ObjectRenderer.prototype.start = function start() {};
	
	  /**
	   * Gets called when this object renderer is deactivated
	   */
	
	
	  ObjectRenderer.prototype.stop = function stop() {
	    this.flush();
	  };
	
	  /**
	   * Renders whatever has been queued
	   */
	
	
	  ObjectRenderer.prototype.flush = function flush() {};
	
	  /**
	   * Disposes this ObjectRenderer
	   */
	
	
	  ObjectRenderer.prototype.dispose = function dispose() {
	    this._renderer.off('context', this._onContextChange);
	    this._renderer = null;
	  };
	
	  return ObjectRenderer;
	}();
	
	exports.default = ObjectRenderer;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _baseTexture = __webpack_require__(46);
	
	var _baseTexture2 = _interopRequireDefault(_baseTexture);
	
	var _textureUvs = __webpack_require__(104);
	
	var _textureUvs2 = _interopRequireDefault(_textureUvs);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A texture that can be applied to a {@link PhotoEditorSDK.Engine.Sprite}
	 * @class
	 * @extends EventEmitter
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var Texture = function (_EventEmitter) {
	  (0, _inherits3.default)(Texture, _EventEmitter);
	
	  function Texture(baseTexture, frame) {
	    (0, _classCallCheck3.default)(this, Texture);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    if (!(baseTexture instanceof _baseTexture2.default)) {
	      throw new Error('\`baseTexture\` should be an instance of BaseTexture');
	    }
	    _this._baseTexture = baseTexture;
	    _this._uvs = new _textureUvs2.default();
	    _this._frame = frame ? frame.clone() : null;
	    _this._frameLocked = !!frame;
	
	    // Bind event handlers
	    _this._onBaseTextureLoaded = _this._onBaseTextureLoaded.bind(_this);
	    _this._onBaseTextureUpdated = _this._onBaseTextureUpdated.bind(_this);
	
	    if (!_this._baseTexture.isLoaded()) {
	      _this._baseTexture.once('loaded', _this._onBaseTextureLoaded);
	    } else {
	      var _baseTexture$getFrame = baseTexture.getFrame();
	
	      var width = _baseTexture$getFrame.width;
	      var height = _baseTexture$getFrame.height;
	
	      if (!_this._frameLocked) {
	        _this._frame = new _globals.Rectangle(0, 0, width, height);
	      }
	      _this._onBaseTextureLoaded();
	    }
	    return _this;
	  }
	
	  /**
	   * Creates a texture from the given image
	   * @param  {Image} image
	   */
	
	
	  Texture.fromImage = function fromImage(image) {
	    var baseTexture = new _baseTexture2.default(image);
	    return new Texture(baseTexture);
	  };
	
	  /**
	   * Creates a texture from the given canvas
	   * @param  {HTMLCanvasElement} canvas
	   */
	
	
	  Texture.fromCanvas = function fromCanvas(canvas) {
	    var baseTexture = new _baseTexture2.default(canvas);
	    return new Texture(baseTexture);
	  };
	
	  /**
	   * Gets called when the base texture has been loaded
	   * @private
	   */
	
	
	  Texture.prototype._onBaseTextureLoaded = function _onBaseTextureLoaded() {
	    if (!this._frameLocked) {
	      var frame = this._baseTexture.getFrame().clone();
	      this.setFrame(frame);
	    }
	
	    this._baseTexture.on('update', this._onBaseTextureUpdated);
	  };
	
	  /**
	   * Gets called when the base texture has been updated
	   * @private
	   */
	
	
	  Texture.prototype._onBaseTextureUpdated = function _onBaseTextureUpdated() {
	    var _baseTexture$getFrame2 = this._baseTexture.getFrame();
	
	    var width = _baseTexture$getFrame2.width;
	    var height = _baseTexture$getFrame2.height;
	
	    this._frame.width = width;
	    this._frame.height = height;
	    this.emit('update');
	  };
	
	  /**
	   * Updates the UV coordinates of this texture
	   * @private
	   */
	
	
	  Texture.prototype._updateUVs = function _updateUVs() {
	    this._uvs.update(this._frame, this._baseTexture.getFrame());
	  };
	
	  /**
	   * Returns the base texture
	   * @return {PhotoEditorSDK.Engine.BaseTexture}
	   */
	
	
	  Texture.prototype.getBaseTexture = function getBaseTexture() {
	    return this._baseTexture;
	  };
	
	  /**
	   * Sets the base texture
	   * @param {PhotoEditorSDK.Engine.BaseTexture} baseTexture
	   */
	
	
	  Texture.prototype.setBaseTexture = function setBaseTexture(baseTexture) {
	    this._baseTexture = baseTexture;
	  };
	
	  /**
	   * Returns the frame
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Texture.prototype.getFrame = function getFrame() {
	    return this._frame;
	  };
	
	  /**
	   * Sets the frame
	   * @param {PhotoEditorSDK.Math.Rectangle} frame
	   */
	
	
	  Texture.prototype.setFrame = function setFrame(frame) {
	    this._frame = frame;
	    this._updateUVs();
	  };
	
	  /**
	   * Returns the width
	   * @return {Number}
	   */
	
	
	  Texture.prototype.getWidth = function getWidth() {
	    return this._frame.width;
	  };
	
	  /**
	   * Returns the height
	   * @return {Number}
	   */
	
	
	  Texture.prototype.getHeight = function getHeight() {
	    return this._frame.height;
	  };
	
	  /**
	   * Returns the texture UVs
	   * @return {PhotoEditorSDK.Engine.TextureUVs}
	   */
	
	
	  Texture.prototype.getUVs = function getUVs() {
	    return this._uvs;
	  };
	
	  /**
	   * Returns the dimensions of this texture
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Texture.prototype.getDimensions = function getDimensions() {
	    return new _globals.Vector2(this._frame.width, this._frame.height);
	  };
	
	  return Texture;
	}(_globals.EventEmitter); /*
	                           * This file is part of PhotoEditorSDK.
	                           *
	                           * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                           * All rights reserved.
	                           *
	                           * Redistribution and use in source and binary forms, without
	                           * modification, are permitted provided that the following license agreement
	                           * is approved and a legal/financial contract was signed by the user.
	                           * The license agreement can be found under following link:
	                           *
	                           * https://www.photoeditorsdk.com/LICENSE.txt
	                           */
	
	exports.default = Texture;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var now = typeof window !== 'undefined' && window.performance ? window.performance.now.bind(window.performance) : __webpack_require__(93);
	
	/**
	 * Hooks into a rendering context (WebGLRenderingContext or CanvasRenderingContext2D),
	 * mocks its methods and measures the time consumed by the method calls. When `endFrame`
	 * is called, it prints a performance report
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 * @ignore
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var ContextPerformanceHook = function () {
	  function ContextPerformanceHook(context) {
	    var _this = this;
	
	    (0, _classCallCheck3.default)(this, ContextPerformanceHook);
	
	    this._context = context;
	    this._tracking = false;
	
	    var self = this;
	
	    var _loop = function _loop(key) {
	      var value = context[key];
	      if (typeof value === 'function') {
	        value = function value() {
	          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	          }
	
	          var fn = context[key];
	          if (!self._tracking) {
	            return fn.apply(context, args);
	          }
	
	          var start = now();
	          var result = fn.apply(context, args);
	          var time = now() - start;
	
	          var call = {
	            functionName: key,
	            arguments: args,
	            duration: time
	          };
	          self._trackedCalls.push(call);
	
	          return result;
	        };
	      }
	      _this[key] = value;
	    };
	
	    for (var key in context) {
	      _loop(key);
	    }
	  }
	
	  /**
	   * Starts tracking a frame
	   */
	
	
	  ContextPerformanceHook.prototype.startFrame = function startFrame() {
	    this._tracking = true;
	    this._trackedCalls = [];
	  };
	
	  /**
	   * Stops tracking a frame and prints a performance report
	   */
	
	
	  ContextPerformanceHook.prototype.endFrame = function endFrame() {
	    var tag = 'Rendering';
	    _globals.Log.log(tag, 'Frame rendering results:');
	    _globals.Log.log(tag, 'Context calls: ' + this._trackedCalls.length);
	
	    var groupedCalls = {};
	    this._trackedCalls.forEach(function (_ref) {
	      var functionName = _ref.functionName;
	      var duration = _ref.duration;
	
	      groupedCalls[functionName] = groupedCalls[functionName] || {
	        totalDuration: 0,
	        calls: 0
	      };
	
	      groupedCalls[functionName].totalDuration += duration;
	      groupedCalls[functionName].calls++;
	    });
	
	    var callsArray = [];
	    for (var key in groupedCalls) {
	      var data = groupedCalls[key];
	      data.averageDuration = data.totalDuration / data.calls;
	
	      callsArray.push({ functionName: key, data: data });
	    }
	
	    callsArray.sort(function (a, b) {
	      return b.data.totalDuration - a.data.totalDuration;
	    });
	    callsArray = callsArray.slice(0, 3);
	
	    callsArray.forEach(function (item) {
	      _globals.Log.log(tag, item.functionName + ': ' + item.data.calls + ' calls, ' + item.data.totalDuration.toFixed(2) + 'ms');
	    });
	  };
	
	  return ContextPerformanceHook;
	}();
	
	exports.default = ContextPerformanceHook;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _canvas = __webpack_require__(17);
	
	var _canvas2 = _interopRequireDefault(_canvas);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * This class represents an image in pixel array form.
	 */
	
	var PixelArrayImage = function () {
	  /**
	   * @param  {Number} width
	   * @param  {Number} height
	   * @param  {UInt8Array} data
	   * @constructor
	   */
	
	  function PixelArrayImage(width, height, data) {
	    (0, _classCallCheck3.default)(this, PixelArrayImage);
	
	    this.width = width;
	    this.height = height;
	    this.data = data;
	  }
	
	  /**
	   * Creates a PixelArrayImage from the given `node-canvas` Image object by rendering the image
	   * to a canvas and reading the pixel data
	   * @param  {Canvas.Image} image
	   * @return {PixelArrayImage}
	   */
	
	
	  PixelArrayImage.fromNodeCanvasImage = function fromNodeCanvasImage(image) {
	    var canvas = new _canvas2.default(image.width, image.height);
	    var context = canvas.getContext('2d');
	
	    context.drawImage(image, 0, 0);
	    var imageData = context.getImageData(0, 0, image.width, image.height);
	    return new PixelArrayImage(image.width, image.height, imageData.data);
	  };
	
	  return PixelArrayImage;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = PixelArrayImage;

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * Helper function to correctly set up the prototype chain
	 * Based on the backbone.js extend function:
	 * https://github.com/jashkenas/backbone/blob/master/backbone.js
	 * @param  {Object} prototypeProperties
	 * @param  {Object} classProperties
	 * @return {Object}
	 * @ignore
	 */
	module.exports = function (prototypeProperties, classProperties) {
	  /* jshint validthis:true */
	  var parent = this;
	  var child;
	
	  // The constructor function for the new subclass is either defined by you
	  // (the 'constructor' property in your `extend` definition), or defaulted
	  // by us to simply call the parent's constructor.
	  if (prototypeProperties && prototypeProperties.hasOwnProperty('constructor')) {
	    child = prototypeProperties.constructor;
	  } else {
	    child = function child() {
	      return parent.apply(this, arguments);
	    };
	  }
	
	  // Add static properties to the constructor function, if supplied.
	  var key;
	  for (key in parent) {
	    child[key] = parent[key];
	  }
	  if (typeof classProperties !== 'undefined') {
	    for (key in classProperties) {
	      child[key] = classProperties[key];
	    }
	  }
	
	  // Set the prototype chain to inherit from `parent`, without calling
	  // `parent`'s constructor function.
	  var Surrogate = function Surrogate() {
	    this.constructor = child;
	  };
	  Surrogate.prototype = parent.prototype;
	  child.prototype = new Surrogate();
	
	  // Add prototype properties (instance properties) to the subclass,
	  // if supplied.
	  if (prototypeProperties) {
	    for (key in prototypeProperties) {
	      child.prototype[key] = prototypeProperties[key];
	    }
	  }
	
	  // Set a convenience property in case the parent's prototype is needed
	  // later.
	  child.__super__ = parent.prototype;
	
	  return child;
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(82);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	var _vector = __webpack_require__(23);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Represents a 3-dimensional matrix
	 * @class
	 * @memberof PhotoEditorSDK.Math
	 */
	
	var Matrix = function () {
	  /**
	   * Creates a Matrix
	   */
	
	  function Matrix() {
	    (0, _classCallCheck3.default)(this, Matrix);
	
	    this.reset();
	  }
	
	  /**
	   * Multiplies this matrix with the given one
	   * @param  {PhotoEditorSDK.Math.Matrix} matrix
	   * @return {PhotoEditorSDK.Math.Matrix}
	   */
	
	
	  Matrix.prototype.multiply = function multiply(matrix) {
	    var a = void 0,
	        b = void 0,
	        c = void 0,
	        d = void 0,
	        tx = void 0,
	        ty = void 0;
	    a = this.a * matrix.a + this.b * matrix.c;
	    b = this.a * matrix.b + this.b * matrix.d;
	    c = this.c * matrix.a + this.d * matrix.c;
	    d = this.c * matrix.b + this.d * matrix.d;
	    tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
	    ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
	
	    this.a = a;
	    this.b = b;
	    this.c = c;
	    this.d = d;
	    this.tx = tx;
	    this.ty = ty;
	    return this;
	  };
	
	  /**
	   * Applies this matrix to the given vector
	   * @param  {PhotoEditorSDK.Math.Vector2} position
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Matrix.prototype.applyToVector = function applyToVector(position) {
	    var _position = position;
	    var x = _position.x;
	    var y = _position.y;
	
	    position = position.clone();
	    position.x = this.a * x + this.c * y + this.tx;
	    position.y = this.b * x + this.d * y + this.tx;
	    return position;
	  };
	
	  /**
	   * Applies the inverse of this matrix to the given vector
	   * @param  {PhotoEditorSDK.Math.Vector2} position
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Matrix.prototype.applyInverseToVector = function applyInverseToVector(position) {
	    var determinant = 1 / (this.a * this.d + this.c * -this.b);
	
	    var _position2 = position;
	    var x = _position2.x;
	    var y = _position2.y;
	
	    position = position.clone();
	    position.x = this.d * determinant * x + -this.c * determinant * y + (this.ty * this.c - this.tx * this.d) * determinant;
	    position.y = this.a * determinant * y + -this.b * determinant * x + (-this.ty * this.a + this.tx * this.b) * determinant;
	
	    return position;
	  };
	
	  /**
	   * Turns the given rectangle into vector coordinates by applying this Matrix
	   * @param  {PhotoEditorSDK.Math.Rectangle} rectangle
	   * @param  {PhotoEditorSDK.Math.Vector2} anchor
	   * @return {PhotoEditorSDK.Math.Vector2[]}
	   */
	
	
	  Matrix.prototype.rectangleToCoordinates = function rectangleToCoordinates(rectangle) {
	    var anchor = arguments.length <= 1 || arguments[1] === undefined ? new _vector2.default(0, 0) : arguments[1];
	
	    // Anchor offsets (w0 = right, w1 = left, h0 = up, h1 = down)
	    var w0 = rectangle.width * (1 - anchor.x);
	    var w1 = rectangle.width * -anchor.x;
	    var h0 = rectangle.height * (1 - anchor.y);
	    var h1 = rectangle.height * -anchor.y;
	
	    var positions = [];
	
	    // Bottom Left
	    positions.push(new _vector2.default(this.a * w1 + this.c * h1 + this.tx, this.d * h1 + this.b * w1 + this.ty));
	
	    // Bottom Right
	    positions.push(new _vector2.default(this.a * w0 + this.c * h1 + this.tx, this.d * h1 + this.b * w0 + this.ty));
	
	    // Top Right
	    positions.push(new _vector2.default(this.a * w0 + this.c * h0 + this.tx, this.d * h0 + this.b * w0 + this.ty));
	
	    // Top Left
	    positions.push(new _vector2.default(this.a * w1 + this.c * h0 + this.tx, this.d * h0 + this.b * w1 + this.ty));
	
	    return positions;
	  };
	
	  /**
	   * Resets this matrix to the identity matrix
	   */
	
	
	  Matrix.prototype.reset = function reset() {
	    this.a = 1;
	    this.b = 0;
	    this.c = 0;
	    this.d = 1;
	    this.tx = 0;
	    this.ty = 0;
	  };
	
	  /**
	   * Returns an array representation of this matrix
	   * @return {Float32Array}
	   */
	
	
	  Matrix.prototype.toArray = function toArray() {
	    var arr = [this.a, this.b, 0, this.c, this.d, 0, this.tx, this.ty, 1];
	    if (typeof Float32Array === 'undefined') {
	      return arr;
	    }
	    return new Float32Array(arr);
	  };
	
	  /**
	   * The identity matrix
	   * @static
	   * @type {PhotoEditorSDK.Math.Matrix}
	   */
	
	
	  (0, _createClass3.default)(Matrix, null, [{
	    key: 'IDENTITY',
	    get: function get() {
	      return new Matrix();
	    }
	  }]);
	  return Matrix;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = Matrix;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * Represents a Rectangle
	 * @class
	 * @memberof PhotoEditorSDK.Math
	 */
	
	var Rectangle = function () {
	  /**
	   * Creartes a Rectangle
	   * @param {Number} [x = 0]
	   * @param {Number} [y = 0]
	   * @param {Number} [width  = 0]
	   * @param {Number} [height = 0]
	   */
	
	  function Rectangle() {
	    var x = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	    var y = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	    var width = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var height = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
	    (0, _classCallCheck3.default)(this, Rectangle);
	
	    this.x = x;
	    this.y = y;
	    this.width = width;
	    this.height = height;
	  }
	
	  /**
	   * Sets the given values
	   * @param {Number} x
	   * @param {Number} y
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Rectangle.prototype.set = function set(x, y, width, height) {
	    this.x = x;
	    this.y = y;
	    this.width = width;
	    this.height = height;
	    return this;
	  };
	
	  /**
	   * Creates a clone of this rectangle
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Rectangle.prototype.clone = function clone() {
	    return new Rectangle(this.x, this.y, this.width, this.height);
	  };
	
	  /**
	   * Copies the values of the given rectangle
	   * @param  {PhotoEditorSDK.Math.Rectangle} other
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Rectangle.prototype.copy = function copy(other) {
	    this.x = other.x;
	    this.y = other.y;
	    this.width = other.width;
	    this.height = other.height;
	    return this;
	  };
	
	  /**
	   * Checks whether this rectangle's values are the same as the given ones
	   * @param  {(Number|PhotoEditorSDK.Math.Rectangle)} rect
	   * @param  {Number} y
	   * @param  {Number} width
	   * @param  {Number} height
	   * @return {Boolean}
	   */
	
	
	  Rectangle.prototype.equals = function equals(rect, y, width, height) {
	    if (rect instanceof Rectangle) {
	      return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
	    } else {
	      var x = rect;
	      return x === this.x && y === this.y && width === this.width && height === this.height;
	    }
	  };
	
	  /**
	   * Rounds this rectangle's values
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Rectangle.prototype.round = function round() {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.width = Math.round(this.width);
	    this.height = Math.round(this.height);
	    return this;
	  };
	
	  /**
	   * Returns a string representation of this rectangle
	   * @return {String}
	   */
	
	
	  Rectangle.prototype.toString = function toString() {
	    return "Rectangle({ x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + " })";
	  };
	
	  return Rectangle;
	}();
	
	exports.default = Rectangle;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var now = typeof window !== 'undefined' && window.performance ? window.performance.now.bind(window.performance) : __webpack_require__(93);
	
	/**
	 * A simple class that tracks the time between start and end and renders it as FPS
	 * @class
	 * @memberof PhotoEditorSDK
	 * @ignore
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var PerformanceTest = function () {
	  /**
	   * Creates a PerformanceTest
	   * @param  {String} tag
	   * @param  {String} name
	   */
	
	  function PerformanceTest(tag, name) {
	    (0, _classCallCheck3.default)(this, PerformanceTest);
	
	    this._tag = tag;
	    this._name = name;
	    this._start = now();
	  }
	
	  /**
	   * Stops the performance test and prints the result
	   */
	
	
	  PerformanceTest.prototype.stop = function stop() {
	    var end = now();
	    var ms = end - this._start;
	    var fps = Math.round(1000 / ms);
	    _globals.Log.info(this._tag, this._name + ' took ' + ms.toFixed(2) + 'ms (' + fps + ' FPS)');
	  };
	
	  return PerformanceTest;
	}();
	
	exports.default = PerformanceTest;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var AdjustmentsFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(AdjustmentsFilter, _Engine$Filter);
	
	  function AdjustmentsFilter() {
	    (0, _classCallCheck3.default)(this, AdjustmentsFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(211);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  AdjustmentsFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var _options = this._options;
	    var brightness = _options.brightness;
	    var saturation = _options.saturation;
	    var contrast = _options.contrast;
	
	
	    var applyBrightness = brightness !== 0;
	    var applySaturation = saturation !== 1;
	    var applyContrast = contrast !== 1;
	
	    brightness = brightness * 255;
	
	    for (var i = 0; i < canvas.width * canvas.height; i++) {
	      var index = i * 4;
	      var r = imageData.data[index];
	      var g = imageData.data[index + 1];
	      var b = imageData.data[index + 2];
	
	      // Brightness
	      if (applyBrightness) {
	        r = r + brightness;
	        g = g + brightness;
	        b = b + brightness;
	      }
	
	      // Saturation
	      if (applySaturation) {
	        var luminance = r * 0.2125 + g * 0.7154 + b * 0.0721;
	        r = luminance * (1 - saturation) + r * saturation;
	        g = luminance * (1 - saturation) + g * saturation;
	        b = luminance * (1 - saturation) + b * saturation;
	      }
	
	      // Contrast
	      if (applyContrast) {
	        r = (r - 127) * contrast + 127;
	        g = (g - 127) * contrast + 127;
	        b = (b - 127) * contrast + 127;
	      }
	
	      imageData.data[index] = r;
	      imageData.data[index + 1] = g;
	      imageData.data[index + 2] = b;
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return AdjustmentsFilter;
	}(_globals.Engine.Filter); /*
	                            * This file is part of PhotoEditorSDK.
	                            *
	                            * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                            * All rights reserved.
	                            *
	                            * Redistribution and use in source and binary forms, without
	                            * modification, are permitted provided that the following license agreement
	                            * is approved and a legal/financial contract was signed by the user.
	                            * The license agreement can be found under following link:
	                            *
	                            * https://www.photoeditorsdk.com/LICENSE.txt
	                            */
	
	AdjustmentsFilter.prototype.availableOptions = {
	  brightness: { type: 'number', default: 0, uniformType: 'f' },
	  saturation: { type: 'number', default: 1, uniformType: 'f' },
	  contrast: { type: 'number', default: 1, uniformType: 'f' }
	};
	
	exports.default = AdjustmentsFilter;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * A ControlPoint is a part of a {@link PhotoEditorSDK.Operations.BrushOperation.Path}, so a Path
	 * consists of multiple ControlPoints. Should only be created using {@link PhotoEditorSDK.Operations.BrushOperation.Path#addControlPoint}
	 * @class
	 * @memberof PhotoEditorSDK.Operations.BrushOperation
	 */
	
	var ControlPoint = function () {
	  /**
	   * Creates a ControlPoint
	   * @param  {PhotoEditorSDK.Operations.BrushOperation.Path} path
	   * @param  {PhotoEditorSDK.Math.Vector2} position
	   */
	
	  function ControlPoint(path, position) {
	    (0, _classCallCheck3.default)(this, ControlPoint);
	
	    this._path = path;
	    this._drawnCanvases = [];
	    this._position = position;
	  }
	
	  /**
	   * Renders this ControlPoint to the given canvas
	   * @param  {HTMLCanvasElement} canvas
	   * @param  {PhotoEditorSDK.Operations.BrushOperation.ControlPoint} lastControlPoint
	   */
	
	
	  ControlPoint.prototype.renderToCanvas = function renderToCanvas(canvas, lastControlPoint) {
	    if (this._drawnCanvases.indexOf(canvas) !== -1) {
	      // This control point has already been drawn on this canvas. Ignore.
	      return;
	    }
	
	    var context = canvas.getContext('2d');
	    var position = this._position;
	    var lastPosition = lastControlPoint.getPosition();
	
	    context.beginPath();
	    context.lineJoin = 'round';
	    context.strokeStyle = this._path.getColor().toRGBA();
	    context.lineWidth = this._path.getThickness();
	    context.moveTo(lastPosition.x, lastPosition.y);
	    context.lineTo(position.x, position.y);
	    context.closePath();
	    context.stroke();
	    this._drawnCanvases.push(canvas);
	  };
	
	  /**
	   * Sets the position
	   * @param {PhotoEditorSDK.Math.Vector2} position
	   */
	
	
	  ControlPoint.prototype.setPosition = function setPosition(position) {
	    this._position = position;
	  };
	
	  /**
	   * Returns the position
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  ControlPoint.prototype.getPosition = function getPosition() {
	    return this._position.clone();
	  };
	
	  /**
	   * Sets this ControlPoint to dirty
	   */
	
	
	  ControlPoint.prototype.setDirty = function setDirty() {
	    this._drawnCanvases = [];
	  };
	
	  return ControlPoint;
	}();
	
	exports.default = ControlPoint;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Identity Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var IdentityFilter = function (_Filter) {
	  (0, _inherits3.default)(IdentityFilter, _Filter);
	
	  function IdentityFilter() {
	    (0, _classCallCheck3.default)(this, IdentityFilter);
	    return (0, _possibleConstructorReturn3.default)(this, _Filter.apply(this, arguments));
	  }
	
	  /**
	   * Renders the filter
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Engine.RenderTexture}
	   * @return {Promise}
	   */
	
	  IdentityFilter.prototype.render = function render(sdk, renderTexture) {
	    return _globals.Promise.resolve();
	  };
	
	  return IdentityFilter;
	}(_filter2.default);
	
	IdentityFilter.isIdentity = true;
	IdentityFilter.displayName = 'Original';
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	IdentityFilter.identifier = 'identity';
	
	exports.default = IdentityFilter;

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var TEXTURE_GL_UNIT = 3;
	
	var LookupTableFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(LookupTableFilter, _Engine$Filter);
	
	  function LookupTableFilter() {
	    (0, _classCallCheck3.default)(this, LookupTableFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(220);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  LookupTableFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var table = this._options.lookupTableData;
	    for (var i = 0; i < canvas.width * canvas.height; i++) {
	      var index = i * 4;
	
	      var r = imageData.data[index];
	      imageData.data[index] = table[r * 4];
	      var g = imageData.data[index + 1];
	      imageData.data[index + 1] = table[1 + g * 4];
	      var b = imageData.data[index + 2];
	      imageData.data[index + 2] = table[2 + b * 4];
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return LookupTableFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	
	
	LookupTableFilter.prototype.availableOptions = {
	  lookupTable: { type: 'number', default: TEXTURE_GL_UNIT, uniformType: 'i' },
	  lookupTableData: { type: 'array', default: [] }
	};
	
	/**
	 * Stores a 256 byte long lookup table in a 2d texture which will be
	 * used to look up the corresponding value for each channel.
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var LookupTable = function (_Primitive) {
	  (0, _inherits3.default)(LookupTable, _Primitive);
	
	  function LookupTable() {
	    (0, _classCallCheck3.default)(this, LookupTable);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new LookupTableFilter();
	    _this2._textures = [];
	    return _this2;
	  }
	
	  /**
	   * Gets called before this primitive's filter is being applied
	   * @param {PhotoEditorSDK} sdk
	   */
	
	
	  LookupTable.prototype.update = function update(sdk) {
	    var renderer = sdk.getRenderer();
	    /* istanbul ignore if */
	    if (renderer.isOfType('webgl')) {
	      this._updateWebGLTexture(sdk);
	    } else if (renderer.isOfType('canvas')) {
	      this._filter.setLookupTableData(this._options.data);
	    }
	  };
	
	  /**
	   * Updates the lookup table texture (WebGL only)
	   * @param {PhotoEditorSDK} sdk
	   * @private
	   */
	  /* istanbul ignore next */
	
	
	  LookupTable.prototype._updateWebGLTexture = function _updateWebGLTexture(sdk) {
	    if (typeof this._options.data === 'undefined') {
	      throw new Error('LookupTable: No data specified.');
	    }
	
	    var data = new Uint8Array(this._options.data);
	
	    var renderer = sdk.getRenderer();
	    var id = renderer.id;
	
	    if (!this._textures[id]) {
	      this._textures[id] = new _engine2.default.BaseTexture();
	    }
	
	    var texture = this._textures[id];
	    var pixelArrayImage = new _engine2.default.PixelArrayImage(256, 1, data);
	    texture.setSource(pixelArrayImage);
	    texture.setGLUnit(TEXTURE_GL_UNIT);
	
	    /* istanbul ignore next */
	    if (renderer.isOfType('webgl')) {
	      renderer.updateTexture(texture);
	    }
	  };
	
	  /**
	   * Cleans up this primitive
	   */
	
	
	  LookupTable.prototype.dispose = function dispose() {
	    _Primitive.prototype.dispose.call(this);
	    for (var id in this._textures) {
	      delete this._textures[id];
	    }
	    delete this._options.data;
	  };
	
	  return LookupTable;
	}(_primitive2.default);
	
	exports.default = LookupTable;

/***/ },
/* 80 */
/***/ function(module, exports) {

	/* eslint-disable */
	"use strict";
	/*!
	
	StackBlur - a fast almost Gaussian Blur For Canvas
	
	Version:  0.5
	Author:   Mario Klingemann
	Contact:  mario@quasimondo.com
	Website:  http://www.quasimondo.com/StackBlurForCanvas
	Twitter:  @quasimondo
	
	In case you find this class useful - especially in commercial projects -
	I am not totally unhappy for a small donation to my PayPal account
	mario@quasimondo.de
	
	Or support me on flattr:
	https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript
	
	Copyright (c) 2010 Mario Klingemann
	
	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
	
	var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
	
	function stackBlurCanvasRGBA(imageData, top_x, top_y, width, height, radius) {
	  if (isNaN(radius) || radius < 1) {
	    return;
	  }
	  radius |= 0;
	
	  var pixels = imageData.data;
	
	  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
	
	  var div = radius + radius + 1;
	  var widthMinus1 = width - 1;
	  var heightMinus1 = height - 1;
	  var radiusPlus1 = radius + 1;
	  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
	
	  var stackStart = new BlurStack();
	  var stackEnd;
	  var stack = stackStart;
	  for (i = 1; i < div; i++) {
	    stack = stack.next = new BlurStack();
	    if (i == radiusPlus1) stackEnd = stack;
	  }
	  stack.next = stackStart;
	  var stackIn = null;
	  var stackOut = null;
	
	  yw = yi = 0;
	
	  var mul_sum = mul_table[radius];
	  var shg_sum = shg_table[radius];
	
	  for (y = 0; y < height; y++) {
	    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
	
	    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	
	    r_sum += sumFactor * pr;
	    g_sum += sumFactor * pg;
	    b_sum += sumFactor * pb;
	    a_sum += sumFactor * pa;
	
	    stack = stackStart;
	
	    for (i = 0; i < radiusPlus1; i++) {
	      stack.r = pr;
	      stack.g = pg;
	      stack.b = pb;
	      stack.a = pa;
	      stack = stack.next;
	    }
	
	    for (i = 1; i < radiusPlus1; i++) {
	      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
	      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
	      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
	      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
	      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
	
	      r_in_sum += pr;
	      g_in_sum += pg;
	      b_in_sum += pb;
	      a_in_sum += pa;
	
	      stack = stack.next;
	    }
	
	    stackIn = stackStart;
	    stackOut = stackEnd;
	    for (x = 0; x < width; x++) {
	      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
	      if (pa !== 0) {
	        pa = 255 / pa;
	        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
	        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
	        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
	      } else {
	        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
	      }
	
	      r_sum -= r_out_sum;
	      g_sum -= g_out_sum;
	      b_sum -= b_out_sum;
	      a_sum -= a_out_sum;
	
	      r_out_sum -= stackIn.r;
	      g_out_sum -= stackIn.g;
	      b_out_sum -= stackIn.b;
	      a_out_sum -= stackIn.a;
	
	      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
	
	      r_in_sum += stackIn.r = pixels[p];
	      g_in_sum += stackIn.g = pixels[p + 1];
	      b_in_sum += stackIn.b = pixels[p + 2];
	      a_in_sum += stackIn.a = pixels[p + 3];
	
	      r_sum += r_in_sum;
	      g_sum += g_in_sum;
	      b_sum += b_in_sum;
	      a_sum += a_in_sum;
	
	      stackIn = stackIn.next;
	
	      r_out_sum += pr = stackOut.r;
	      g_out_sum += pg = stackOut.g;
	      b_out_sum += pb = stackOut.b;
	      a_out_sum += pa = stackOut.a;
	
	      r_in_sum -= pr;
	      g_in_sum -= pg;
	      b_in_sum -= pb;
	      a_in_sum -= pa;
	
	      stackOut = stackOut.next;
	
	      yi += 4;
	    }
	    yw += width;
	  }
	
	  for (x = 0; x < width; x++) {
	    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
	
	    yi = x << 2;
	    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	
	    r_sum += sumFactor * pr;
	    g_sum += sumFactor * pg;
	    b_sum += sumFactor * pb;
	    a_sum += sumFactor * pa;
	
	    stack = stackStart;
	
	    for (i = 0; i < radiusPlus1; i++) {
	      stack.r = pr;
	      stack.g = pg;
	      stack.b = pb;
	      stack.a = pa;
	      stack = stack.next;
	    }
	
	    yp = width;
	
	    for (i = 1; i <= radius; i++) {
	      yi = yp + x << 2;
	
	      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
	      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
	      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
	      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
	
	      r_in_sum += pr;
	      g_in_sum += pg;
	      b_in_sum += pb;
	      a_in_sum += pa;
	
	      stack = stack.next;
	
	      if (i < heightMinus1) {
	        yp += width;
	      }
	    }
	
	    yi = x;
	    stackIn = stackStart;
	    stackOut = stackEnd;
	    for (y = 0; y < height; y++) {
	      p = yi << 2;
	      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
	      if (pa > 0) {
	        pa = 255 / pa;
	        pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
	        pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
	        pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
	      } else {
	        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
	      }
	
	      r_sum -= r_out_sum;
	      g_sum -= g_out_sum;
	      b_sum -= b_out_sum;
	      a_sum -= a_out_sum;
	
	      r_out_sum -= stackIn.r;
	      g_out_sum -= stackIn.g;
	      b_out_sum -= stackIn.b;
	      a_out_sum -= stackIn.a;
	
	      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
	
	      r_sum += r_in_sum += stackIn.r = pixels[p];
	      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
	      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
	      a_sum += a_in_sum += stackIn.a = pixels[p + 3];
	
	      stackIn = stackIn.next;
	
	      r_out_sum += pr = stackOut.r;
	      g_out_sum += pg = stackOut.g;
	      b_out_sum += pb = stackOut.b;
	      a_out_sum += pa = stackOut.a;
	
	      r_in_sum -= pr;
	      g_in_sum -= pg;
	      b_in_sum -= pb;
	      a_in_sum -= pa;
	
	      stackOut = stackOut.next;
	
	      yi += width;
	    }
	  }
	}
	
	function BlurStack() {
	  this.r = 0;
	  this.g = 0;
	  this.b = 0;
	  this.a = 0;
	  this.next = null;
	}
	
	module.exports = {
	  stackBlurCanvasRGBA: stackBlurCanvasRGBA
	};

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(174), __esModule: true };

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(81);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 83 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(178);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(27)
	  , document = __webpack_require__(11).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(13) && !__webpack_require__(33)(function(){
	  return Object.defineProperty(__webpack_require__(85)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(51)
	  , $export        = __webpack_require__(26)
	  , redefine       = __webpack_require__(92)
	  , hide           = __webpack_require__(19)
	  , has            = __webpack_require__(14)
	  , Iterators      = __webpack_require__(50)
	  , $iterCreate    = __webpack_require__(185)
	  , setToStringTag = __webpack_require__(54)
	  , getPrototypeOf = __webpack_require__(191)
	  , ITERATOR       = __webpack_require__(20)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(53)
	  , createDesc     = __webpack_require__(35)
	  , toIObject      = __webpack_require__(16)
	  , toPrimitive    = __webpack_require__(58)
	  , has            = __webpack_require__(14)
	  , IE8_DOM_DEFINE = __webpack_require__(86)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(91)
	  , hiddenKeys = __webpack_require__(49).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 90 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(14)
	  , toIObject    = __webpack_require__(16)
	  , arrayIndexOf = __webpack_require__(180)(false)
	  , IE_PROTO     = __webpack_require__(55)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(19);

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Generated by CoffeeScript 1.7.1
	(function() {
	  var getNanoSeconds, hrtime, loadTime;
	
	  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
	    module.exports = function() {
	      return performance.now();
	    };
	  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
	    module.exports = function() {
	      return (getNanoSeconds() - loadTime) / 1e6;
	    };
	    hrtime = process.hrtime;
	    getNanoSeconds = function() {
	      var hr;
	      hr = hrtime();
	      return hr[0] * 1e9 + hr[1];
	    };
	    loadTime = getNanoSeconds();
	  } else if (Date.now) {
	    module.exports = function() {
	      return Date.now() - loadTime;
	    };
	    loadTime = Date.now();
	  } else {
	    module.exports = function() {
	      return new Date().getTime() - loadTime;
	    };
	    loadTime = new Date().getTime();
	  }
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _identityFilter = __webpack_require__(78);
	
	Object.defineProperty(exports, 'IdentityFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_identityFilter).default;
	  }
	});
	
	var _a15Filter = __webpack_require__(117);
	
	Object.defineProperty(exports, 'A15Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_a15Filter).default;
	  }
	});
	
	var _breezeFilter = __webpack_require__(118);
	
	Object.defineProperty(exports, 'BreezeFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_breezeFilter).default;
	  }
	});
	
	var _bwFilter = __webpack_require__(119);
	
	Object.defineProperty(exports, 'BWFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_bwFilter).default;
	  }
	});
	
	var _bwhardFilter = __webpack_require__(120);
	
	Object.defineProperty(exports, 'BWHardFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_bwhardFilter).default;
	  }
	});
	
	var _celsiusFilter = __webpack_require__(121);
	
	Object.defineProperty(exports, 'CelsiusFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_celsiusFilter).default;
	  }
	});
	
	var _chestFilter = __webpack_require__(122);
	
	Object.defineProperty(exports, 'ChestFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_chestFilter).default;
	  }
	});
	
	var _fixieFilter = __webpack_require__(123);
	
	Object.defineProperty(exports, 'FixieFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_fixieFilter).default;
	  }
	});
	
	var _foodFilter = __webpack_require__(124);
	
	Object.defineProperty(exports, 'FoodFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_foodFilter).default;
	  }
	});
	
	var _fridgeFilter = __webpack_require__(125);
	
	Object.defineProperty(exports, 'FridgeFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_fridgeFilter).default;
	  }
	});
	
	var _frontFilter = __webpack_require__(126);
	
	Object.defineProperty(exports, 'FrontFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_frontFilter).default;
	  }
	});
	
	var _glamFilter = __webpack_require__(127);
	
	Object.defineProperty(exports, 'GlamFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_glamFilter).default;
	  }
	});
	
	var _gobblinFilter = __webpack_require__(128);
	
	Object.defineProperty(exports, 'GobblinFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_gobblinFilter).default;
	  }
	});
	
	var _k1Filter = __webpack_require__(129);
	
	Object.defineProperty(exports, 'K1Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_k1Filter).default;
	  }
	});
	
	var _k2Filter = __webpack_require__(130);
	
	Object.defineProperty(exports, 'K2Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_k2Filter).default;
	  }
	});
	
	var _k6Filter = __webpack_require__(131);
	
	Object.defineProperty(exports, 'K6Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_k6Filter).default;
	  }
	});
	
	var _kdynamicFilter = __webpack_require__(132);
	
	Object.defineProperty(exports, 'KDynamicFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_kdynamicFilter).default;
	  }
	});
	
	var _leninFilter = __webpack_require__(133);
	
	Object.defineProperty(exports, 'LeninFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_leninFilter).default;
	  }
	});
	
	var _lomoFilter = __webpack_require__(134);
	
	Object.defineProperty(exports, 'LomoFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_lomoFilter).default;
	  }
	});
	
	var _mellowFilter = __webpack_require__(135);
	
	Object.defineProperty(exports, 'MellowFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_mellowFilter).default;
	  }
	});
	
	var _morningFilter = __webpack_require__(136);
	
	Object.defineProperty(exports, 'MorningFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_morningFilter).default;
	  }
	});
	
	var _orchidFilter = __webpack_require__(137);
	
	Object.defineProperty(exports, 'OrchidFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_orchidFilter).default;
	  }
	});
	
	var _polaFilter = __webpack_require__(138);
	
	Object.defineProperty(exports, 'PolaFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_polaFilter).default;
	  }
	});
	
	var _pola669Filter = __webpack_require__(139);
	
	Object.defineProperty(exports, 'Pola669Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_pola669Filter).default;
	  }
	});
	
	var _quoziFilter = __webpack_require__(151);
	
	Object.defineProperty(exports, 'QuoziFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_quoziFilter).default;
	  }
	});
	
	var _semiredFilter = __webpack_require__(152);
	
	Object.defineProperty(exports, 'SemiredFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_semiredFilter).default;
	  }
	});
	
	var _sunnyFilter = __webpack_require__(153);
	
	Object.defineProperty(exports, 'SunnyFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_sunnyFilter).default;
	  }
	});
	
	var _texasFilter = __webpack_require__(154);
	
	Object.defineProperty(exports, 'TexasFilter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_texasFilter).default;
	  }
	});
	
	var _x400Filter = __webpack_require__(155);
	
	Object.defineProperty(exports, 'X400Filter', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_x400Filter).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operations = __webpack_require__(64);
	
	var Operations = _interopRequireWildcard(_operations);
	
	var _operationsStack = __webpack_require__(63);
	
	var _operationsStack2 = _interopRequireDefault(_operationsStack);
	
	var _versionChecker = __webpack_require__(110);
	
	var _versionChecker2 = _interopRequireDefault(_versionChecker);
	
	var _exif = __webpack_require__(40);
	
	var _exif2 = _interopRequireDefault(_exif);
	
	var _imageExporter = __webpack_require__(108);
	
	var _imageExporter2 = _interopRequireDefault(_imageExporter);
	
	var _performanceTest = __webpack_require__(75);
	
	var _performanceTest2 = _interopRequireDefault(_performanceTest);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var RenderType = _globals.Constants.RenderType; /*
	                                                 * This file is part of PhotoEditorSDK.
	                                                 *
	                                                 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                                                 * All rights reserved.
	                                                 *
	                                                 * Redistribution and use in source and binary forms, without
	                                                 * modification, are permitted provided that the following license agreement
	                                                 * is approved and a legal/financial contract was signed by the user.
	                                                 * The license agreement can be found under following link:
	                                                 *
	                                                 * https://www.photoeditorsdk.com/LICENSE.txt
	                                                 */
	
	var ImageFormat = _globals.Constants.ImageFormat;
	var Events = _globals.Constants.Events;
	
	/**
	 * The main SDK class which handles rendering and manages
	 * operations.
	 * @class
	 * @alias PhotoEditorSDK
	 */
	
	var PhotoEditorSDK = function (_EventEmitter) {
	  (0, _inherits3.default)(PhotoEditorSDK, _EventEmitter);
	
	  /**
	   * Creates a PhotoEditorSDK instance
	   * @param  {String} [preferredRenderer = webgl] - `webgl` or `canvas`
	   * @param  {Object} [options = {}]
	   * @param  {Image} [options.image] - The image that should be rendered
	   * @param  {String} [options.renderMode = dynamic] - `dynamic` or `export`
	   * @param  {Boolean} [options.versionCheck = true] - Should a version check be performed?
	   * @param  {Boolean} [options.displayWelcomeMessage = true] - Should a welcome message be printed
	   *   in the console?
	   * @param  {Boolean} [options.transparent = false] - Should the canvas background be transparent?
	   * @param  {HTMLCanvasElement} [options.canvas] - The canvas element the SDK should render to
	   * @param  {Number} [options.zoom = 1] - The zoom level. Only available in `dynamic` mode
	   * @param  {Number} [options.spriteScale = 1] - The output sprite's scale. Only available in `dynamic` mode
	   * @param  {String} [options.logLevel = warn] - `trace`, `info`, `warn`, `error` or `log`
	   * @param  {Number} [options.pixelRatio = 1] - If none is given, PhotoEditorSDK automatically
	   *   detects the current device's pixel ratio
	   */
	
	  function PhotoEditorSDK(preferredRenderer) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    (0, _classCallCheck3.default)(this, PhotoEditorSDK);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._onContextRestored = _this._onContextRestored.bind(_this);
	
	    var _require = __webpack_require__(65);
	
	    var version = _require.version;
	
	    _this.version = version;
	
	    _this._preferredRenderer = preferredRenderer;
	    _this._options = _globals.Utils.defaults(options, {
	      extensions: {},
	      renderMode: 'dynamic',
	      versionCheck: true,
	      displayWelcomeMessage: true,
	      image: null,
	      canvas: null,
	      transparent: false,
	      zoom: 1,
	      spriteScale: 1,
	      logLevel: 'warn',
	      pixelRatio: typeof window !== 'undefined' && window.devicePixelRatio || 1
	    });
	
	    _this._options.extensions = _globals.Utils.defaults(_this._options.extensions, {
	      operations: [],
	      controls: [],
	      languages: []
	    });
	
	    _globals.Log.setLevel(_this._options.logLevel);
	
	    _this._defaultRenderMode = _this._options.renderMode;
	    _this._offset = new _globals.Vector2();
	    _this._zoom = _this._options.zoom;
	    _this._spriteScale = _this._options.spriteScale;
	    _this._operations = {};
	    _this._renderMode = _this._options.renderMode;
	    _this._operationsStack = null;
	    _this.setOperationsStack(new _operationsStack2.default());
	
	    // Engine stuff
	    _this._container = new _globals.Engine.Container();
	    _this._sprite = new _globals.Engine.Sprite();
	    _this._container.addChild(_this._sprite);
	
	    _this._inputBaseTexture = null;
	    _this._inputTexture = null;
	
	    _this._checkForUpdates();
	    _this._registerOperations();
	
	    if (_this._options.image) {
	      _this.setImage(_this._options.image);
	    }
	
	    _this._initRenderer();
	
	    var renderer = _this._renderer.constructor.type;
	    if (_this._options.displayWelcomeMessage) {
	      _globals.Log.log('Yo!', 'Version: ' + _this.version + ' (' + renderer + ') - https://www.photoeditorsdk.com');
	    }
	
	    // Async image handling
	    (0, _globals.requestAnimationFrame)(_this._init.bind(_this));
	    return _this;
	  }
	
	  /**
	   * Initializes the SDK
	   * @private
	   */
	
	
	  PhotoEditorSDK.prototype._init = function _init() {
	    if (this._options.image) {
	      this.setImage(this._options.image);
	    }
	  };
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when an operation is updated. Delegates the event.
	   * @private
	   */
	
	
	  PhotoEditorSDK.prototype._onOperationUpdate = function _onOperationUpdate() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    this.emit.apply(this, [Events.OPERATION_UPDATED].concat(args));
	  };
	
	  /**
	   * Gets called when the WebGL context has been restored. Re-triggers a render.
	   * @private
	   */
	  /* istanbul ignore next */
	
	
	  PhotoEditorSDK.prototype._onContextRestored = function _onContextRestored() {
	    _globals.Log.warn(this.constructor.name, 'Trying to re-render after WebGL context has been restored.');
	    this.setAllOperationsToDirty();
	    this._operationsStack.forEach(function (operation) {
	      operation.disposeRenderTexture();
	    });
	    this.render();
	  };
	
	  // -------------------------------------------------------------------------- RENDERING
	
	  /**
	   * Exports the image with the given options. Result of the Promise is the exported image or data url.
	   * @param  {PhotoEditorSDK.RenderType} [renderType=PhotoEditorSDK.RenderType.DATAURL] - The output type
	   * @param  {PhotoEditorSDK.ImageFormat} [imageFormat=PhotoEditorSDK.ImageFormat.PNG] - The output image format
	   * @param  {Number} [quality=0.8] - The image quality, between 0 and 1
	   * @return {Promise}
	   */
	
	
	  PhotoEditorSDK.prototype.export = function _export() {
	    var renderType = arguments.length <= 0 || arguments[0] === undefined ? RenderType.DATAURL : arguments[0];
	
	    var _this2 = this;
	
	    var imageFormat = arguments.length <= 1 || arguments[1] === undefined ? ImageFormat.PNG : arguments[1];
	    var quality = arguments.length <= 2 || arguments[2] === undefined ? 0.8 : arguments[2];
	
	    this._renderMode = 'export';
	    var tempDimensions = this._renderer.getDimensions();
	    this._renderer.resizeTo(this.getFinalDimensions());
	
	    return _imageExporter2.default.validateSettings(renderType, imageFormat).then(function () {
	      return _this2.render();
	    }).then(function () {
	      return _imageExporter2.default.export(_this2, _this2._image, _this2._renderer.getCanvas(), renderType, imageFormat, quality);
	    }).then(function (data) {
	      _this2._renderer.resizeTo(tempDimensions);
	      _this2._renderMode = _this2._defaultRenderMode;
	      _this2.setAllOperationsToDirty();
	      _this2.render();
	      return data;
	    });
	  };
	
	  /**
	   * Renders the current image to the canvas
	   * @return {Promise}
	   */
	
	
	  PhotoEditorSDK.prototype.render = function render() {
	    var _this3 = this;
	
	    if (!this._image) {
	      throw new Error('You need to set an image before calling PhotoEditorSDK#render.');
	    }
	
	    var context = this._renderer.getContext();
	    if (context.startFrame) {
	      context.startFrame();
	    }
	
	    var perfTest = void 0;
	    if (_globals.Log.canLog('info')) {
	      perfTest = new _performanceTest2.default('⚡⚡⚡', 'Frame rendering');
	    }
	    _globals.Log.info('⚡⚡⚡', 'Rendering starts');
	
	    this._container.setPosition(0, 0);
	    this._container.setScale(1, 1);
	    this._sprite.setAnchor(0, 0);
	    this._sprite.setPosition(0, 0);
	    this._sprite.setScale(1, 1);
	    this._sprite.setRotation(0);
	
	    var stack = this._operationsStack;
	    stack.updateDirtinessForRenderer(this._renderer);
	
	    this._sprite.setTexture(this._inputTexture);
	    this._container.updateTransform();
	
	    return stack.validateSettings().then(function () {
	      return stack.render(_this3, _this3._sprite);
	    }).then(function () {
	      switch (_this3._renderMode) {
	        case 'dynamic':
	          // Always center image, set scale to zoom level
	          var center = _this3._renderer.getDimensions().clone().divide(2).add(_this3._offset);
	          _this3._container.setScale(_this3._zoom, _this3._zoom);
	          _this3._container.setPosition(center);
	          _this3._sprite.setAnchor(0.5, 0.5);
	          _this3._sprite.setScale(_this3._spriteScale, _this3._spriteScale);
	          break;
	        case 'export':
	          // Move sprite to upper left hand corner, render at full scale
	          _this3._container.setScale(1, 1);
	          _this3._sprite.setAnchor(0, 0);
	          _this3._sprite.setPosition(0, 0);
	          _this3._sprite.setScale(1, 1);
	          _this3._sprite.setRotation(0);
	          break;
	      }
	
	      _this3._renderer.render(_this3._container);
	    }).then(function () {
	      if (perfTest) {
	        perfTest.stop();
	      }
	      if (context.endFrame) {
	        context.endFrame();
	      }
	    });
	  };
	
	  // -------------------------------------------------------------------------- OPERATIONS
	
	  /**
	   * Registers all default operations
	   * @private
	   */
	
	
	  PhotoEditorSDK.prototype._registerOperations = function _registerOperations() {
	    this._operations = {};
	
	    for (var operationName in Operations) {
	      var operation = Operations[operationName];
	      this._operations[operation.identifier] = operation;
	    }
	
	    this._operations = _globals.Utils.extend(this._operations, this._options.extensions.operations);
	  };
	
	  /**
	   * Sets all operations in the stack to dirty
	   */
	
	
	  PhotoEditorSDK.prototype.setAllOperationsToDirty = function setAllOperationsToDirty() {
	    this._operationsStack.setAllToDirty();
	  };
	
	  /**
	   * Creates an operation with the given identifier
	   * @param {String} identifier
	   * @param {Object} [options = {}]
	   * @param {Boolean} [addToStack = true]
	   * @returns {PhotoEditorSDK.Operation}
	   */
	
	
	  PhotoEditorSDK.prototype.createOperation = function createOperation(identifier) {
	    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
	    var addToStack = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	    var Operation = this._operations[identifier];
	    if (!Operation) {
	      throw new Error('No operation with identifier `' + identifier + '` found.');
	    }
	
	    var operation = new Operation(this, options);
	    if (addToStack) {
	      this.addOperation(operation);
	    }
	    return operation;
	  };
	
	  /**
	   * Adds the given operation to the operations stack
	   * @param {PhotoEditorSDK.Operation} operation
	   */
	
	
	  PhotoEditorSDK.prototype.addOperation = function addOperation(operation) {
	    this._operationsStack.push(operation);
	  };
	
	  /**
	   * Removes the given operation from the operations stack
	   * @param  {PhotoEditorSDK.Operation} operation
	   */
	
	
	  PhotoEditorSDK.prototype.removeOperation = function removeOperation(operation) {
	    this._operationsStack.remove(operation);
	  };
	
	  // -------------------------------------------------------------------------- DIMENSIONS
	
	  /**
	   * Returns the initial image dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  PhotoEditorSDK.prototype.getInputDimensions = function getInputDimensions() {
	    var frame = this._inputTexture.getFrame();
	    return new _globals.Vector2(frame.width, frame.height);
	  };
	
	  /**
	   * Returns the final dimensions that the input image would have
	   * after all existing operations have been applied
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  PhotoEditorSDK.prototype.getFinalDimensions = function getFinalDimensions() {
	    var dimensions = this.getInputDimensions();
	    var operationsStack = this._operationsStack;
	
	    operationsStack.forEach(function (operation) {
	      dimensions = operation.getNewDimensions(dimensions);
	    });
	
	    return dimensions.round();
	  };
	
	  /**
	   * Returns the current sprite dimensions
	   * @return {Vector2}
	   */
	
	
	  PhotoEditorSDK.prototype.getOutputDimensions = function getOutputDimensions() {
	    return this.getFinalDimensions().clone().multiply(this._zoom);
	  };
	
	  // -------------------------------------------------------------------------- MISC
	
	  /**
	   * Checks for version updates
	   * @private
	   */
	
	
	  PhotoEditorSDK.prototype._checkForUpdates = function _checkForUpdates() {
	    if (this._options.versionCheck) {
	      this._versionChecker = new _versionChecker2.default(this.version);
	    }
	  };
	
	  /**
	   * Creates a render texture for the current renderer
	   * @return {PhotoEditorSDK.Engine.RenderTexture}
	   * @TODO  This does probably not belong here
	   */
	
	
	  PhotoEditorSDK.prototype.createRenderTexture = function createRenderTexture() {
	    var pixelRatio = this._options.pixelRatio;
	
	    var frame = this._sprite.getTexture().getFrame();
	    return new _globals.Engine.RenderTexture(this._renderer, frame.width, frame.height, pixelRatio);
	  };
	
	  /**
	   * Initializes the renderer
	   * @private
	   */
	
	
	  PhotoEditorSDK.prototype._initRenderer = function _initRenderer() {
	    var rendererOptions = {
	      canvas: this._options.canvas,
	      pixelRatio: this._options.pixelRatio,
	      debug: this._options.debug,
	      transparent: this._options.transparent
	    };
	
	    var width = void 0,
	        height = void 0;
	    if (this._renderMode === 'dynamic' && this._options.canvas) {
	      var canvas = this._options.canvas;
	
	      width = canvas.width;
	      height = canvas.height;
	    } else if (this._image) {
	      var dimensions = this.getFinalDimensions();
	      width = dimensions.x;
	      height = dimensions.y;
	    }
	
	    switch (this._preferredRenderer) {
	      /* istanbul ignore next */
	      case 'webgl':
	        this._renderer = _globals.Engine.autoDetectRenderer(width, height, rendererOptions);
	        this._renderer.on('context-restored', this._onContextRestored);
	        break;
	      case 'canvas':
	        this._renderer = new _globals.Engine.CanvasRenderer(width, height, rendererOptions);
	        this._renderer.on('context-restored', this._onContextRestored);
	        break;
	      default:
	        _globals.Log.warn('PhotoEditorSDK', 'PhotoEditorSDK Error: Renderer `' + this._preferredRenderer + '` not supported. Falling back to automatically detected renderer.');
	        this._renderer = _globals.Engine.autoDetectRenderer(width, height, rendererOptions);
	    }
	  };
	
	  /**
	   * Resizes the renderer to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  PhotoEditorSDK.prototype.resizeTo = function resizeTo(dimensions) {
	    this._renderer.resizeTo(dimensions);
	  };
	
	  /**
	   * Resets all custom and selected operations
	   */
	
	
	  PhotoEditorSDK.prototype.reset = function reset() {
	    this._operationsStack.clear();
	  };
	
	  // -------------------------------------------------------------------------- EXIF
	
	  /**
	   * Parses the exif data and fixes the orientation if necessary
	   * @param {Image} image
	   * @private
	   * @TODO Move this somewhere else
	   */
	
	
	  PhotoEditorSDK.prototype.parseExif = function parseExif(image) {
	    if (!image) {
	      return;
	    }
	    var src = image.src;
	
	    /* istanbul ignore else */
	
	    if (typeof window === 'undefined') {
	      var NodeCanvas = __webpack_require__(17);
	      if (image instanceof NodeCanvas.Image && image.rawSource) {
	        src = image.rawSource;
	      }
	    }
	
	    if (_exif2.default.isJPEG(src)) {
	      var exif = null;
	      try {
	        exif = _exif2.default.fromBase64String(src);
	      } catch (e) {}
	      if (!exif) {
	        return;
	      }
	
	      return exif;
	    }
	  };
	
	  /**
	   * Reads the EXIF orientation tag and fixes it with the OrientationOperation
	   * @private
	   * @TODO Move this somewhere else
	   */
	
	
	  PhotoEditorSDK.prototype._handleExifOrientation = function _handleExifOrientation() {
	    var exifTags = this._exif.getTags();
	
	    if (exifTags && exifTags.Orientation) {
	      var rotationNeedsChange = exifTags.Orientation !== 1 && exifTags.Orientation !== 2;
	      var flipNeedsChange = [2, 4, 5, 7].indexOf(exifTags.Orientation) !== -1;
	
	      var orientationOperation = void 0;
	      if (rotationNeedsChange || flipNeedsChange) {
	        orientationOperation = this.createOperation('orientation');
	      }
	
	      if (rotationNeedsChange) {
	        // We need to rotate
	        var degrees = 0;
	        switch (exifTags.Orientation) {
	          case 7:
	          case 8:
	            degrees = -90;
	            break;
	          case 3:
	          case 4:
	            degrees = -180;
	            break;
	          case 5:
	          case 6:
	            degrees = 90;
	            break;
	        }
	
	        orientationOperation.setRotation(degrees);
	      }
	
	      if ([2, 4].indexOf(exifTags.Orientation) !== -1) {
	        orientationOperation.setFlipHorizontally(true);
	      }
	
	      if ([5, 7].indexOf(exifTags.Orientation) !== -1) {
	        orientationOperation.setFlipVertically(true);
	      }
	
	      this._exif.setOrientation(1);
	    }
	  };
	
	  // -------------------------------------------------------------------------- GETTERS / SETTERS
	
	  /**
	   * Checks if an image is provided
	   * @return {Boolean} [description]
	   */
	
	
	  PhotoEditorSDK.prototype.hasImage = function hasImage() {
	    return this._image !== null && typeof this._image !== 'undefined';
	  };
	
	  /**
	   * Returns the image
	   * @return {Image}
	   */
	
	
	  PhotoEditorSDK.prototype.getImage = function getImage() {
	    return this._image;
	  };
	
	  /**
	   * Sets the image and parses the exif data
	   * @param {Image} image
	   * @param {PhotoEditorSDK.Exif} [exif = null]
	   * @param {PhotoEditorSDK.Math.Vector2} [dimensions]
	   */
	
	
	  PhotoEditorSDK.prototype.setImage = function setImage(image) {
	    var exif = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var dimensions = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    this._options.image = image;
	    this._image = image;
	    if (!exif) {
	      this._exif = this.parseExif(image);
	    } else {
	      this._exif = exif;
	    }
	    if (this._exif) {
	      this._handleExifOrientation();
	    }
	
	    var baseTexture = new _globals.Engine.BaseTexture(this._image);
	    var frame = new _globals.Rectangle(0, 0, this._image.width, this._image.height);
	    if (dimensions) {
	      frame.width = dimensions.x;
	      frame.height = dimensions.y;
	    }
	
	    this._inputTexture = new _globals.Engine.Texture(baseTexture, frame);
	    this._sprite.setTexture(this._inputTexture);
	  };
	
	  /**
	   * Returns the canvas
	   * @return {HTMLCanvasElement}
	   */
	
	
	  PhotoEditorSDK.prototype.getCanvas = function getCanvas() {
	    return this._renderer.getCanvas();
	  };
	
	  /**
	   * Sets the canvas
	   * @param {HTMLCanvasElement} canvas
	   */
	
	
	  PhotoEditorSDK.prototype.setCanvas = function setCanvas(canvas) {
	    this._renderer.setCanvas(canvas);
	  };
	
	  /**
	   * Returns the sprite
	   * @return {PhotoEditorSDK.Engine.Sprite}
	   */
	
	
	  PhotoEditorSDK.prototype.getSprite = function getSprite() {
	    return this._sprite;
	  };
	
	  /**
	   * Returns the container
	   * @return {PhotoEditorSDK.Engine.Container}
	   */
	
	
	  PhotoEditorSDK.prototype.getContainer = function getContainer() {
	    return this._container;
	  };
	
	  /**
	   * Returns the operation stack
	   * @return {PhotoEditorSDK.OperationsStack}
	   */
	
	
	  PhotoEditorSDK.prototype.getOperationsStack = function getOperationsStack() {
	    return this._operationsStack;
	  };
	
	  /**
	   * Sets the operations stack
	   * @param {PhotoEditorSDK.OperationsStack} operationsStack
	   */
	
	
	  PhotoEditorSDK.prototype.setOperationsStack = function setOperationsStack(operationsStack) {
	    if (this._operationsStack) {
	      this._operationsStack.off(Events.OPERATION_UPDATED, this._onOperationUpdate);
	    }
	
	    this._operationsStack = operationsStack;
	    this._operationsStack.on(Events.OPERATION_UPDATED, this._onOperationUpdate);
	  };
	
	  /**
	   * Returns the available operations
	   * @return {Operation[]}
	   */
	
	
	  PhotoEditorSDK.prototype.getOperations = function getOperations() {
	    return this._operations;
	  };
	
	  /**
	   * Returns the renderer
	   * @return {PhotoEditorSDK.Engine.BaseRenderer}
	   */
	
	
	  PhotoEditorSDK.prototype.getRenderer = function getRenderer() {
	    return this._renderer;
	  };
	
	  /**
	   * Returns the rendering offset
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  PhotoEditorSDK.prototype.getOffset = function getOffset() {
	    return this._offset;
	  };
	
	  /**
	   * Sets the rendering offset
	   * @param {PhotoEditorSDK.Math.Vector2|Number} offset
	   * @param {Number} y
	   */
	
	
	  PhotoEditorSDK.prototype.setOffset = function setOffset(offset, y) {
	    if (offset instanceof _globals.Vector2) {
	      this._offset.copy(offset);
	    } else {
	      this._offset.set(offset, y);
	    }
	  };
	
	  /**
	   * Returns the zoom level
	   * @return {Number}
	   */
	
	
	  PhotoEditorSDK.prototype.getZoom = function getZoom() {
	    return this._zoom;
	  };
	
	  /**
	   * Sets the zoom level
	   * @param {Number} zoom
	   */
	
	
	  PhotoEditorSDK.prototype.setZoom = function setZoom(zoom) {
	    this._zoom = zoom;
	    this._container.setScale(this._zoom, this._zoom);
	    this._container.updateTransform();
	  };
	
	  /**
	   * Returns the output sprite's scale
	   * @return {Number}
	   */
	
	
	  PhotoEditorSDK.prototype.getSpriteScale = function getSpriteScale() {
	    return this._spriteScale;
	  };
	
	  /**
	   * Sets the sprite scale to the given value
	   * @param {Number} spriteScale
	   */
	
	
	  PhotoEditorSDK.prototype.setSpriteScale = function setSpriteScale(spriteScale) {
	    this._spriteScale = spriteScale;
	    this._sprite.setScale(spriteScale);
	    this._sprite.updateTransform();
	  };
	
	  /**
	   * Returns the pixel ratio
	   * @return {Number}
	   */
	
	
	  PhotoEditorSDK.prototype.getPixelRatio = function getPixelRatio() {
	    return this._options.pixelRatio;
	  };
	
	  /**
	   * Returns the Exif instance
	   * @return {PhotoEditorSDK.Exif} [description]
	   */
	
	
	  PhotoEditorSDK.prototype.getExif = function getExif() {
	    return this._exif;
	  };
	
	  /**
	   * Returns the options
	   * @return {Object}
	   */
	
	
	  PhotoEditorSDK.prototype.getOptions = function getOptions() {
	    return this._options;
	  };
	
	  /**
	   * Returns the input texture
	   * @return {PhotoEditorSDK.Engine.Texture}
	   */
	
	
	  PhotoEditorSDK.prototype.getInputTexture = function getInputTexture() {
	    return this._inputTexture;
	  };
	
	  // -------------------------------------------------------------------------- DISPOSAL
	
	  /**
	   * Disposes the SDK
	   */
	
	
	  PhotoEditorSDK.prototype.dispose = function dispose() {
	    this._renderer.dispose();
	    if (this._exif) {
	      this._exif.dispose();
	    }
	  };
	
	  return PhotoEditorSDK;
	}(_globals.EventEmitter);
	
	exports.default = PhotoEditorSDK;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _configurable = __webpack_require__(31);
	
	var _configurable2 = _interopRequireDefault(_configurable);
	
	var _shader = __webpack_require__(44);
	
	var _shader2 = _interopRequireDefault(_shader);
	
	var _textureShader = __webpack_require__(45);
	
	var _textureShader2 = _interopRequireDefault(_textureShader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A filter can be attached to a DisplayObject and affects the way it is displayed.
	 * @class
	 * @extends PhotoEditorSDK.Configurable
	 * @memberof PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Filter = function (_Configurable) {
	  (0, _inherits3.default)(Filter, _Configurable);
	
	  function Filter() {
	    (0, _classCallCheck3.default)(this, Filter);
	    return (0, _possibleConstructorReturn3.default)(this, _Configurable.apply(this, arguments));
	  }
	
	  /**
	   * Goes through the available options, sets _options defaults
	   * @param {Object} userOptions
	   * @override
	   * @protected
	   */
	
	  Filter.prototype._initOptions = function _initOptions() {
	    this._shaders = [];
	    this._availableUniforms = _textureShader2.default.defaultUniforms;
	    this._attributes = _textureShader2.default.defaultAttributes;
	    this._vertexSource = _textureShader2.default.defaultVertexSource;
	    this._fragmentSource = _textureShader2.default.defaultFragmentSource;
	
	    this._initUniforms();
	    _Configurable.prototype._initOptions.call(this);
	  };
	
	  /**
	   * Initializes the uniforms
	   * @private
	   */
	
	
	  Filter.prototype._initUniforms = function _initUniforms() {
	    this._uniforms = {};
	    for (var name in this._availableUniforms) {
	      var uniform = this._availableUniforms[name];
	      this._uniforms[name] = {
	        type: uniform.type,
	        value: uniform.default || null
	      };
	    }
	
	    // Options are also turned into uniforms
	    for (var optionName in this.availableOptions) {
	      var optionConfig = this.availableOptions[optionName];
	
	      if (!optionConfig.uniformType) {
	        _globals.Log.trace(this.constructor.name, 'Option `' + optionName + '` is missing a `uniformType`!');
	      } else {
	        this._uniforms['u_' + optionName] = {
	          type: optionConfig.uniformType,
	          value: optionConfig.default || null
	        };
	      }
	    }
	  };
	
	  /**
	   * Sets the value for the given option, validates it
	   * @param {String} optionName
	   * @param {*} value
	   * @param {Boolean} update = true
	   * @override
	   */
	
	
	  Filter.prototype.setOption = function setOption(optionName, value) {
	    var update = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	    _Configurable.prototype.setOption.call(this, optionName, value, update);
	
	    var uniformValue = value;
	    var optionConfig = this.availableOptions[optionName];
	
	    if (!optionConfig.uniformType) {
	      return;
	    }
	
	    switch (optionConfig.type) {
	      case 'color':
	        if (optionConfig.uniformType === '4f') {
	          uniformValue = value.toGLColor();
	        } else if (optionConfig.uniformType === '3f') {
	          uniformValue = value.toRGBGLColor();
	        }
	        break;
	      case 'vector2':
	        uniformValue = [value.x, value.y];
	        break;
	    }
	
	    this.setUniform('u_' + optionName, uniformValue);
	  };
	
	  /**
	   * Sets the given uniform to the given value
	   * @param {String} name
	   * @param {*} value
	   * @param {Boolean} sync = false
	   */
	
	
	  Filter.prototype.setUniform = function setUniform(name, value) {
	    var sync = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	    this._uniforms[name].value = value;
	  };
	
	  /**
	   * Sets the given uniforms to their values
	   * @param {Object}  uniforms
	   * @param {Boolean} sync = false
	   */
	
	
	  Filter.prototype.setUniforms = function setUniforms(uniforms) {
	    var sync = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    for (var name in uniforms) {
	      this._uniforms[name].value = uniforms[name];
	      if (sync) {
	        this.syncUniform(name);
	      }
	    }
	  };
	
	  /**
	   * Synchronizes the uniform with the given name
	   * @param  {String} name
	   */
	
	
	  Filter.prototype.syncUniform = function syncUniform(name) {
	    this._shaders.forEach(function (shader) {
	      shader.syncUniform(name);
	    });
	  };
	
	  /**
	   * Synchronizes all uniforms with WebGL
	   */
	
	
	  Filter.prototype.syncUniforms = function syncUniforms() {
	    this._shaders.forEach(function (shader) {
	      shader.syncUniforms();
	    });
	  };
	
	  /**
	   * Returns the shader for the given renderer
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @return {PhotoEditorSDK.Engine.Shader}
	   */
	  /* istanbul ignore next */
	
	
	  Filter.prototype.getShaderForRenderer = function getShaderForRenderer(renderer) {
	    var gl = renderer.getContext();
	    var shader = this._shaders[gl.id];
	
	    if (!shader) {
	      shader = new _shader2.default(renderer, this._vertexSource, this._fragmentSource, this._uniforms, this._attributes);
	
	      this._shaders[gl.id] = shader;
	    }
	
	    return shader;
	  };
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   */
	
	
	  Filter.prototype.apply = function apply(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    /* istanbul ignore if */
	    if (renderer.isOfType('webgl')) {
	      this._applyWebGL(renderer, inputTarget, outputTarget, clear);
	    } else if (renderer.isOfType('canvas')) {
	      this._applyCanvas(renderer, inputTarget, outputTarget, clear);
	    }
	  };
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the WebGLRenderer
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderer} renderer
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} inputTarget
	   * @param  {PhotoEditorSDK.Engine.WebGLRenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  Filter.prototype._applyWebGL = function _applyWebGL(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var gl = renderer.getContext();
	    var shader = this.getShaderForRenderer(renderer);
	
	    renderer.setRenderTarget(outputTarget);
	    if (clear) {
	      outputTarget.clear();
	    }
	
	    renderer.setShader(shader);
	
	    var projectionMatrix = renderer.getCurrentRenderTarget().getProjectionMatrix().toArray();
	    shader.setUniform('u_projMatrix', projectionMatrix);
	    shader.syncUniforms();
	
	    // Render!
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_2D, inputTarget.getTexture());
	    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
	  };
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  Filter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    _globals.Log.warn(this.constructor.name, '`_applyCanvas` is not implemented. Just copying image data from `inputTarget` to `outputTarget`.');
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  /**
	   * Disposes this Filter
	   */
	
	
	  Filter.prototype.dispose = function dispose() {
	    this._shaders.forEach(function (shader) {
	      return shader.dispose();
	    });
	    this._shaders = [];
	  };
	
	  return Filter;
	}(_configurable2.default);
	
	exports.default = Filter;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _contextPerformanceHook = __webpack_require__(70);
	
	var _contextPerformanceHook2 = _interopRequireDefault(_contextPerformanceHook);
	
	var _baseRenderer = __webpack_require__(67);
	
	var _baseRenderer2 = _interopRequireDefault(_baseRenderer);
	
	var _canvasRenderTarget = __webpack_require__(29);
	
	var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);
	
	var _canvasFilterManager = __webpack_require__(42);
	
	var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The renderer that is used for Canvas2D rendering
	 * @class
	 * @extends PhotoEditorSDK.Engine.BaseRenderer
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var CanvasRenderer = function (_BaseRenderer) {
	  (0, _inherits3.default)(CanvasRenderer, _BaseRenderer);
	
	  /**
	   * Creates a CanvasRenderer
	   * @override
	   */
	
	  function CanvasRenderer() {
	    (0, _classCallCheck3.default)(this, CanvasRenderer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseRenderer.call.apply(_BaseRenderer, [this].concat(args)));
	
	    _this._type = 'canvas';
	
	    _this.setCanvas(_this._options.canvas || _this._createCanvas());
	    return _this;
	  }
	
	  /**
	   * Creates a canvas element
	   * @return {Canvas}
	   * @private
	   */
	
	
	  CanvasRenderer.prototype._createCanvas = function _createCanvas() {
	    return _globals.Utils.createCanvas();
	  };
	
	  /**
	   * Gets the rendering context for this renderer
	   * @returns {Object}
	   * @private
	   */
	
	
	  CanvasRenderer.prototype._createContext = function _createContext() {
	    var canvas = this._canvas;
	    var ctx = canvas.getContext('2d');
	
	    if (this._options.debug) {
	      ctx = new _contextPerformanceHook2.default(ctx);
	    }
	
	    this.id = ctx.id = CanvasRenderer.contextId++;
	    this._context = ctx;
	    ctx.renderer = this;
	
	    this.emit('context', ctx);
	
	    return ctx;
	  };
	
	  /**
	   * Sets up the rendering context for this renderer
	   * @private
	   */
	
	
	  CanvasRenderer.prototype._setupContext = function _setupContext() {
	    var ctx = this._context;
	
	    // Enable image smoothing if available
	    if (!('imageSmoothingEnabled' in ctx)) {
	      ['moz', 'webkit', 'ms'].forEach(function (prop) {
	        if (ctx[prop]) {
	          ctx[prop] = true;
	        }
	      });
	    } else {
	      ctx.imageSmoothingEnabled = true;
	    }
	
	    this._defaultRenderTarget = new _canvasRenderTarget2.default(this._width, this._height, this._pixelRatio, this._canvas, this._context);
	    this.setRenderTarget(this._defaultRenderTarget);
	
	    this._filterManager = new _canvasFilterManager2.default(this);
	  };
	
	  /**
	   * Renders the given DisplayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   */
	
	
	  CanvasRenderer.prototype.render = function render(displayObject) {
	    var ctx = this._renderTarget.getContext();
	
	    // Since the given displayObject is the "root" object
	    // right now, we need to give it a dummy / fake object
	    // as parent with the default world transform and alpha
	    var originalParent = displayObject.getParent();
	    displayObject.setParent(this._fakeObject);
	
	    // Update transforms and render this object
	    displayObject.updateTransform();
	
	    // Reset parent
	    displayObject.setParent(originalParent);
	
	    // Reset transform
	    ctx.setTransform(1, 0, 0, 1, 0, 0);
	
	    // Reset alpha
	    ctx.globalAlpha = 1;
	
	    // Clear the view
	    var _canvas = this._canvas;
	    var width = _canvas.width;
	    var height = _canvas.height;
	
	    ctx.clearRect(0, 0, width, height);
	    if (this._clearColor.a !== 0) {
	      ctx.save();
	      ctx.fillStyle = this._clearColor.toRGBA();
	      ctx.fillRect(0, 0, width, height);
	      ctx.restore();
	    }
	
	    this.renderDisplayObject(displayObject, this._renderTarget);
	  };
	
	  /**
	   * Renders the given DisplayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} renderTarget
	   */
	
	
	  CanvasRenderer.prototype.renderDisplayObject = function renderDisplayObject(displayObject, renderTarget) {
	    var originalRenderTarget = this._renderTarget;
	    this._filterManager.setFilterStack(renderTarget.getFilterStack());
	    this.setRenderTarget(renderTarget);
	    displayObject.renderCanvas(this);
	    this.setRenderTarget(originalRenderTarget);
	  };
	
	  /**
	   * Returns the current render target
	   * @return {PhotoEditorSDK.Engine.RenderTarget}
	   */
	
	
	  CanvasRenderer.prototype.getCurrentRenderTarget = function getCurrentRenderTarget() {
	    return this._renderTarget;
	  };
	
	  /**
	   * Sets the render target
	   * @param {PhotoEditorSDK.Engine.RenderTarget} renderTarget
	   */
	
	
	  CanvasRenderer.prototype.setRenderTarget = function setRenderTarget(renderTarget) {
	    this._renderTarget = renderTarget;
	  };
	
	  /**
	   * Returns the current rendering context
	   * @return {RenderingContext}
	   */
	
	
	  CanvasRenderer.prototype.getContext = function getContext() {
	    return this._renderTarget.getContext();
	  };
	
	  /**
	   * Disposes this Renderer
	   */
	
	
	  CanvasRenderer.prototype.dispose = function dispose() {
	    this._filterManager.dispose();
	  };
	
	  return CanvasRenderer;
	}(_baseRenderer2.default); /*
	                            * This file is part of PhotoEditorSDK.
	                            *
	                            * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                            * All rights reserved.
	                            *
	                            * Redistribution and use in source and binary forms, without
	                            * modification, are permitted provided that the following license agreement
	                            * is approved and a legal/financial contract was signed by the user.
	                            * The license agreement can be found under following link:
	                            *
	                            * https://www.photoeditorsdk.com/LICENSE.txt
	                            */
	
	CanvasRenderer.contextId = 0;
	CanvasRenderer.type = 'Canvas2D';
	
	exports.default = CanvasRenderer;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _globals2 = _interopRequireDefault(_globals);
	
	var _objectRenderer = __webpack_require__(68);
	
	var _objectRenderer2 = _interopRequireDefault(_objectRenderer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The ObjectRenderer that is responsible for rendering Sprite instances
	 * @class
	 * @extends PhotoEditorSDK.Engine.ObjectRenderer
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	/* eslint constructor-super: 0 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var SpriteRenderer = function (_ObjectRenderer) {
	  (0, _inherits3.default)(SpriteRenderer, _ObjectRenderer);
	
	  /**
	   * Creates a SpriteRenderer
	   * @override
	   */
	
	  function SpriteRenderer() {
	    (0, _classCallCheck3.default)(this, SpriteRenderer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _ObjectRenderer.call.apply(_ObjectRenderer, [this].concat(args)));
	
	    _this._maxBatchSize = _globals2.default.BATCH_SIZE;
	    _this._vertices = new ArrayBuffer(_globals2.default.BATCH_SIZE * 4 * _globals2.default.VERTEX_BYTE_SIZE);
	    _this._positions = new Float32Array(_this._vertices);
	    _this._colors = new Uint32Array(_this._vertices);
	    _this._indices = new Uint16Array(_globals2.default.BATCH_SIZE * 6);
	
	    // Fill vertex position indices
	    for (var i = 0, j = 0; i < _globals2.default.BATCH_SIZE * 6; i += 6, j += 4) {
	      _this._indices[i + 0] = j + 0;
	      _this._indices[i + 1] = j + 1;
	      _this._indices[i + 2] = j + 2;
	      _this._indices[i + 3] = j + 0;
	      _this._indices[i + 4] = j + 2;
	      _this._indices[i + 5] = j + 3;
	    }
	
	    _this._shaders = [];
	    _this._sprites = [];
	
	    _this._currentBatchSize = 0;
	    _this._currentBaseTexture = null;
	
	    _this._onContextChange();
	    return _this;
	  }
	
	  /**
	   * Adds the given sprite to the batch
	   * @param  {PhotoEditorSDK.Engine.Sprite} sprite
	   */
	
	
	  SpriteRenderer.prototype.render = function render(sprite) {
	    var texture = sprite.getTexture();
	    var textureFrame = texture.getFrame();
	    var baseTexture = texture.getBaseTexture();
	
	    // Has the maximum batch size been reached? Flush!
	    if (this._currentBatchSize >= this._maxBatchSize) {
	      this.flush();
	      this._currentBaseTexture = baseTexture;
	    }
	
	    // No updated UVs => No rendering
	    var uvs = texture.getUVs();
	    if (!uvs) {
	      return;
	    }
	
	    // Fill positions array
	    var index = this._currentBatchSize * _globals2.default.VERTEX_BYTE_SIZE;
	    this._addVertexCoordinates(sprite, index, textureFrame);
	    this._addTextureUVs(sprite, index, uvs);
	    this._addColors(sprite, index);
	
	    // Add the sprite to the list of sprites
	    this._sprites[this._currentBatchSize] = sprite;
	    this._currentBatchSize++;
	  };
	
	  /**
	   * Adds the color to the positions array for the given sprite
	   * @param {PhotoEditorSDK.Engine.Sprite} sprite
	   * @param {Number} index
	   * @private
	   */
	
	
	  SpriteRenderer.prototype._addColors = function _addColors(sprite, index) {
	    var colors = this._colors;
	    var tint = sprite.getTint();
	    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.getWorldAlpha() * 255 << 24);
	    colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = color;
	  };
	
	  /**
	   * Adds the texture UV coordinates to the positions array for the given sprite
	   * @param {PhotoEditorSDK.Engine.Sprite} sprite
	   * @param {Number} index
	   * @param {PhotoEditorSDK.Engine.TextureUVs} uvs
	   * @private
	   */
	
	
	  SpriteRenderer.prototype._addTextureUVs = function _addTextureUVs(sprite, index, uvs) {
	    var positions = this._positions;
	
	    // Add UVs
	    var uvCoords = uvs.getUVsAt(0);
	    positions[index + 2] = uvCoords.x;
	    positions[index + 3] = uvCoords.y;
	
	    uvCoords = uvs.getUVsAt(1);
	    positions[index + 7] = uvCoords.x;
	    positions[index + 8] = uvCoords.y;
	
	    uvCoords = uvs.getUVsAt(2);
	    positions[index + 12] = uvCoords.x;
	    positions[index + 13] = uvCoords.y;
	
	    uvCoords = uvs.getUVsAt(3);
	    positions[index + 17] = uvCoords.x;
	    positions[index + 18] = uvCoords.y;
	  };
	
	  /**
	   * Adds the vertex coordinates to the positions array for the given
	   * sprite and texture frame
	   * @param {PhotoEditorSDK.Engine.Sprite} sprite
	   * @param {Number} index
	   * @param {PhotoEditorSDK.Math.Rectangle} textureFrame
	   * @private
	   */
	
	
	  SpriteRenderer.prototype._addVertexCoordinates = function _addVertexCoordinates(sprite, index, textureFrame) {
	    var positions = this._positions;
	    var worldTransform = sprite.getWorldTransform();
	
	    // Transform sprite coords with anchor in mind
	    var anchor = sprite.getAnchor();
	    var rectPositions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
	
	    var stride = 5;
	    for (var i = 0; i < 4; i++) {
	      positions[index + i * stride] = rectPositions[i].x;
	      positions[index + i * stride + 1] = rectPositions[i].y;
	    }
	  };
	
	  /**
	   * Gets called when the rendering context changes
	   * @private
	   */
	
	
	  SpriteRenderer.prototype._onContextChange = function _onContextChange() {
	    var gl = this._renderer.getContext();
	
	    this._shader = this._renderer.shaders.default;
	
	    this._vertexBuffer = gl.createBuffer();
	    this._indexBuffer = gl.createBuffer();
	
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
	  };
	
	  /**
	   * Gets called when this object renderer is activated
	   */
	
	
	  SpriteRenderer.prototype.start = function start() {
	    this._shader.setupBuffers(this._vertexBuffer, this._indexBuffer);
	  };
	
	  /**
	   * Renders the queued sprites in batches, every time the base texture has changed,
	   * it flushes the current batch to the graphics card
	   */
	
	
	  SpriteRenderer.prototype.flush = function flush() {
	    var renderer = this._renderer;
	    var gl = renderer.getContext();
	
	    if (this._currentBatchSize === 0) {
	      return;
	    }
	
	    if (this._currentBatchSize > _globals2.default.BATCH_SIZE * 0.5) {
	      // Upload whole ArrayBuffer
	      gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
	    } else {
	      // Only upload sub array
	      var subArray = this._positions.subarray(0, this._currentBatchSize * _globals2.default.VERTEX_BYTE_SIZE);
	      gl.bufferSubData(gl.ARRAY_BUFFER, 0, subArray);
	    }
	
	    // Init variables
	    var currentBatchSize = 0;
	    var currentBaseTexture = null;
	    var nextBaseTexture = null;
	    var currentShader = null;
	    var nextShader = null;
	    var shaderChanged = false;
	    var textureChanged = false;
	    var sprite = null;
	    var batchStartIndex = 0;
	
	    for (var i = 0, j = this._currentBatchSize; i < j; i++) {
	      sprite = this._sprites[i];
	
	      nextBaseTexture = sprite.getTexture().getBaseTexture();
	      nextShader = sprite.getShader() || this._shader;
	      shaderChanged = currentShader !== nextShader;
	      textureChanged = currentBaseTexture !== nextBaseTexture;
	
	      if (textureChanged || shaderChanged) {
	        this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
	
	        batchStartIndex = i;
	        currentBatchSize = 0;
	        currentBaseTexture = nextBaseTexture;
	
	        // Shader has changed, set it
	        if (shaderChanged) {
	          currentShader = nextShader;
	          renderer.setShader(currentShader);
	
	          var renderTarget = renderer.getCurrentRenderTarget();
	          var projectionMatrix = renderTarget.getProjectionMatrix().toArray();
	          currentShader.setUniform('u_projMatrix', projectionMatrix);
	          currentShader.syncUniforms();
	
	          gl.activeTexture(gl.TEXTURE0);
	        }
	      }
	
	      currentBatchSize++;
	    }
	
	    this._renderBatch(currentBaseTexture, currentBatchSize, batchStartIndex);
	
	    // Reset the batch
	    this._currentBatchSize = 0;
	    this._sprites = [];
	  };
	
	  /**
	   * Renders the current batch
	   * @param  {PhotoEditorSDK.Engine.BaseTexture} baseTexture
	   * @param  {Number} batchSize
	   * @param  {Number} batchStartIndex
	   * @private
	   */
	
	
	  SpriteRenderer.prototype._renderBatch = function _renderBatch(baseTexture, batchSize, batchStartIndex) {
	    if (batchSize === 0) {
	      return;
	    }
	
	    var renderer = this._renderer;
	    var gl = renderer.getContext();
	
	    var glTexture = baseTexture.getGLTextureForId(gl.id);
	    if (!glTexture) {
	      glTexture = renderer.getOrCreateGLTexture(baseTexture);
	      renderer.updateTexture(baseTexture);
	    }
	    gl.activeTexture(gl.TEXTURE0 + baseTexture.getGLUnit());
	    gl.bindTexture(gl.TEXTURE_2D, glTexture);
	
	    var verticesCount = batchSize * 6;
	    var vertexOffset = batchStartIndex * 6 * 2;
	    gl.drawElements(gl.TRIANGLES, verticesCount, gl.UNSIGNED_SHORT, vertexOffset);
	  };
	
	  /**
	   * Disposes this ObjectRenderer
	   */
	
	
	  SpriteRenderer.prototype.dispose = function dispose() {
	    var renderer = this._renderer;
	    var gl = renderer.getContext();
	
	    gl.deleteBuffer(this._vertexBuffer);
	    gl.deleteBuffer(this._indexBuffer);
	
	    this._vertices = null;
	    this._positions = null;
	    this._colors = null;
	    this._indices = null;
	
	    _ObjectRenderer.prototype.dispose.call(this);
	  };
	
	  return SpriteRenderer;
	}(_objectRenderer2.default);
	
	exports.default = SpriteRenderer;

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _baseRenderer = __webpack_require__(67);
	
	var _baseRenderer2 = _interopRequireDefault(_baseRenderer);
	
	var _webglRenderTarget = __webpack_require__(30);
	
	var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);
	
	var _objectRenderer = __webpack_require__(68);
	
	var _objectRenderer2 = _interopRequireDefault(_objectRenderer);
	
	var _spriteRenderer = __webpack_require__(98);
	
	var _spriteRenderer2 = _interopRequireDefault(_spriteRenderer);
	
	var _textureShader = __webpack_require__(45);
	
	var _textureShader2 = _interopRequireDefault(_textureShader);
	
	var _displayObject = __webpack_require__(41);
	
	var _displayObject2 = _interopRequireDefault(_displayObject);
	
	var _webglFilterManager = __webpack_require__(43);
	
	var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);
	
	var _contextPerformanceHook = __webpack_require__(70);
	
	var _contextPerformanceHook2 = _interopRequireDefault(_contextPerformanceHook);
	
	var _pixelArrayImage = __webpack_require__(71);
	
	var _pixelArrayImage2 = _interopRequireDefault(_pixelArrayImage);
	
	var _canvas = __webpack_require__(17);
	
	var _canvas2 = _interopRequireDefault(_canvas);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NodeCanvasImage = typeof _canvas2.default !== 'undefined' ? _canvas2.default.Image : undefined;
	
	/**
	 * The renderer that is used for WebGL rendering
	 * @class
	 * @extends PhotoEditorSDK.Engine.BaseRenderer
	 * @memberof PhotoEditorSDK.Engine
	 */
	/* istanbul ignore next */
	
	
	// For server-side environments
	/* global Image */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var WebGLRenderer = function (_BaseRenderer) {
	  (0, _inherits3.default)(WebGLRenderer, _BaseRenderer);
	
	  /**
	   * Creates a WebGLRenderer
	   * @override
	   */
	
	  function WebGLRenderer() {
	    (0, _classCallCheck3.default)(this, WebGLRenderer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _BaseRenderer.call.apply(_BaseRenderer, [this].concat(args)));
	
	    _this._type = 'webgl';
	
	    _this._textures = [];
	    _this._fakeObject = new _displayObject2.default();
	    _this._onContextLost = _this._onContextLost.bind(_this);
	    _this._onContextRestored = _this._onContextRestored.bind(_this);
	
	    _this.setCanvas(_this._options.canvas || _globals.Utils.createCanvas());
	
	    _this.shaders = _this._initShaders();
	    _this.renderers = _this._initRenderers();
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- CONTEXT LOSS
	
	  /**
	   * Gets called when the WebGL context has been lost
	   * @param  {Event} e
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._onContextLost = function _onContextLost(e) {
	    e.preventDefault();
	    _globals.Log.warn(this.constructor.name, 'WebGL context has been lost - trying to restore.');
	  };
	
	  /**
	   * Gets called when the WebGL context has been restored. Cleans up and resets everything.
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._onContextRestored = function _onContextRestored() {
	    var _this2 = this;
	
	    _globals.Log.warn(this.constructor.name, 'WebGL context has been restored. Clearing all textures.');
	
	    this._textures.forEach(function (texture) {
	      texture.disposeGLTextures(_this2);
	    });
	
	    this._createContext();
	    this._setupContext();
	    this.emit('context-restored');
	  };
	
	  /**
	   * Gets called before the context has been set up
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._onBeforeContext = function _onBeforeContext() {
	    this._filterManager = new _webglFilterManager2.default(this);
	    this._currentObjectRenderer = new _objectRenderer2.default(this);
	  };
	
	  /**
	   * Sets the given shader to active
	   * @param {PhotoEditorSDK.Engine.Shader} shader
	   */
	
	
	  WebGLRenderer.prototype.setShader = function setShader(shader) {
	    this._currentShader = shader;
	    this._context.useProgram(shader.getProgram());
	    this._setAttributesForShader(shader);
	  };
	
	  /**
	   * Sets the canvas to the given one
	   * @param {HTMLCanvasElement} canvas
	   */
	
	
	  WebGLRenderer.prototype.setCanvas = function setCanvas(canvas) {
	    if (this._canvas) {
	      this._canvas.removeEventListener('webglcontextlost', this._onContextLost);
	      this._canvas.removeEventListener('webglcontextrestored', this._onContextRestored);
	    }
	
	    if (canvas.addEventListener) {
	      // node-canvas doesn't have events
	      canvas.addEventListener('webglcontextlost', this._onContextLost);
	      canvas.addEventListener('webglcontextrestored', this._onContextRestored);
	    }
	
	    _BaseRenderer.prototype.setCanvas.call(this, canvas);
	  };
	
	  /**
	   * Uploads the given shader's attributes to the GPU
	   * @param {PhotoEditorSDK.Engine.Shader} shader
	   */
	
	
	  WebGLRenderer.prototype._setAttributesForShader = function _setAttributesForShader(shader) {
	    var gl = this._context;
	    var attributes = shader.getAttributes();
	    var attributeLocations = shader.getAttributeLocations();
	
	    attributes.forEach(function (attributeName) {
	      var attributeLocation = attributeLocations[attributeName];
	      gl.enableVertexAttribArray(attributeLocation);
	    });
	  };
	
	  /**
	   * Initializes the default shaders
	   * @return {Object}
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._initShaders = function _initShaders() {
	    return {
	      default: new _textureShader2.default(this)
	    };
	  };
	
	  /**
	   * Initializes the available object renderers
	   * @return {Object}
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._initRenderers = function _initRenderers() {
	    return {
	      sprite: new _spriteRenderer2.default(this)
	    };
	  };
	
	  /**
	   * Gets the rendering context for this renderer
	   * @returns {Object}
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._createContext = function _createContext() {
	    var canvas = this._canvas;
	    var gl = null;
	
	    // If node-gl is available, use it for context creation. This allows us
	    // to render images on the server-side with hardware accelerated graphics
	    var createContext = __webpack_require__(28);
	    if (createContext) {
	      gl = createContext(canvas.width, canvas.height, {
	        preserveDrawingBuffer: true
	      });
	    } else {
	      gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	    }
	
	    // Hook up WebGLDebugUtils if present
	    if (typeof window !== 'undefined' && window.WebGLDebugUtils && this._options.debug) {
	      var logGL = function logGL(functionName, args) {
	        console.error('gl.' + functionName + '(' + window.WebGLDebugUtils.glFunctionArgsToString(functionName, args) + ')');
	      };
	      gl = window.WebGLDebugUtils.makeDebugContext(gl, null, logGL);
	    }
	
	    // Hook up ContextPerformanceHook if debug is enabled
	    if (this._options.debug) {
	      gl = new _contextPerformanceHook2.default(gl);
	    }
	
	    this.id = gl.id = WebGLRenderer.contextId++;
	    this._context = gl;
	    gl.renderer = this;
	
	    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	
	    this.emit('context', gl);
	
	    return gl;
	  };
	
	  /**
	   * Sets up the rendering context for this renderer
	   * @private
	   */
	
	
	  WebGLRenderer.prototype._setupContext = function _setupContext() {
	    var gl = this._context;
	
	    gl.disable(gl.DEPTH_TEST);
	    gl.disable(gl.CULL_FACE);
	    gl.enable(gl.BLEND);
	    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	
	    this._defaultRenderTarget = new _webglRenderTarget2.default(this, this._width, this._height, this._pixelRatio, true);
	    this.setRenderTarget(this._defaultRenderTarget);
	  };
	
	  /**
	   * Resizes the context and view to the given size
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  WebGLRenderer.prototype.resizeTo = function resizeTo(dimensions) {
	    _BaseRenderer.prototype.resizeTo.call(this, dimensions);
	    if (this._currentRenderTarget) {
	      this._currentRenderTarget.resizeTo(dimensions);
	    }
	
	    if (__webpack_require__(28)) {
	      this._context.resize(dimensions.x, dimensions.y);
	    }
	  };
	
	  /**
	   * Sets the current render target to the passed one and activates
	   * it for rendering
	   * @param {PhotoEditorSDK.Engine.RenderTarget} renderTarget
	   */
	
	
	  WebGLRenderer.prototype.setRenderTarget = function setRenderTarget(renderTarget) {
	    this._currentRenderTarget = renderTarget;
	    this._currentRenderTarget.activate();
	  };
	
	  /**
	   * Sets the current object renderer to the given one
	   * @param {PhotoEditorSDK.Engine.ObjectRenderer} objectRenderer
	   */
	
	
	  WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
	    this._currentObjectRenderer.stop();
	    this._currentObjectRenderer = objectRenderer;
	    this._currentObjectRenderer.start();
	  };
	
	  /**
	   * Renders the given DisplayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   */
	
	
	  WebGLRenderer.prototype.render = function render(displayObject) {
	    this.setRenderTarget(this._defaultRenderTarget);
	    this._defaultRenderTarget.clear(this._clearColor);
	
	    // Since the given displayObject is the "root" object
	    // right now, we need to give it a dummy / fake object
	    // as parent with the default world transform and alpha
	    var originalParent = displayObject.getParent();
	    displayObject.setParent(this._fakeObject);
	
	    // Update transforms and render this object
	    displayObject.updateTransform();
	
	    // Reset parent
	    displayObject.setParent(originalParent);
	
	    this.renderDisplayObject(displayObject, this._defaultRenderTarget);
	  };
	
	  /**
	   * Renders the given DisplayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} renderTarget
	   */
	
	
	  WebGLRenderer.prototype.renderDisplayObject = function renderDisplayObject(displayObject, renderTarget) {
	    this.setRenderTarget(renderTarget);
	    this._filterManager.setFilterStack(renderTarget.getFilterStack());
	    displayObject.renderWebGL(this);
	    this._currentObjectRenderer.flush();
	  };
	
	  /**
	   * Clears the context
	   */
	
	
	  WebGLRenderer.prototype.clear = function clear() {
	    var gl = this._context;
	
	    gl.clearColor.apply(gl, this._clearColor.toGLColor());
	    gl.clear(gl.COLOR_BUFFER_BIT);
	  };
	
	  /**
	   * Returns and/or creates a WebGLTexture for the given BaseTexture object
	   * @param  {PhotoEditorSDK.Engine.BaseTexture} texture
	   * @return {PhotoEditorSDK.Engine.WebGLTexture}
	   */
	
	
	  WebGLRenderer.prototype.getOrCreateGLTexture = function getOrCreateGLTexture(texture) {
	    var gl = this._context;
	
	    var glTexture = texture.getGLTextureForId(gl.id);
	    if (!glTexture) {
	      glTexture = gl.createTexture();
	      texture.setGLTextureForId(glTexture, gl.id);
	
	      // Hold reference to texture for easier disposal
	      this._textures.push(texture);
	    }
	
	    return glTexture;
	  };
	
	  /**
	   * Updates the given texture
	   * @param  {PhotoEditorSDK.Engine.BaseTexture} texture
	   * @param  {Boolean} [upload = true]
	   */
	
	
	  WebGLRenderer.prototype.updateTexture = function updateTexture(texture) {
	    var upload = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    var source = texture.getSource();
	    var hasSource = !!source;
	
	    var gl = this._context;
	    var glUnit = texture.getGLUnit();
	    var glTexture = this.getOrCreateGLTexture(texture);
	
	    gl.activeTexture(gl.TEXTURE0 + glUnit);
	    gl.bindTexture(gl.TEXTURE_2D, glTexture);
	
	    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	    if (__webpack_require__(28)) {
	      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	    }
	
	    if (upload && hasSource) {
	      if (typeof Image !== 'undefined' && source instanceof Image || source.constructor.name === 'Canvas' || source.tagName && source.tagName.toUpperCase() === 'CANVAS') {
	        // Default client-side behavior: Upload the `source` image
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
	      } else {
	        // In case we're on the server side, convert a `node-canvas` Image object
	        // into a PixelArrayImage
	        if (typeof NodeCanvasImage !== 'undefined' && source instanceof NodeCanvasImage) {
	          source = _pixelArrayImage2.default.fromNodeCanvasImage(source);
	        }
	
	        // Upload the PixelArrayImage's data (a Uint8Array)
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.width, source.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source.data);
	      }
	    }
	
	    if (texture.isMipMappingEnabled()) {
	      gl.generateMipmap(gl.TEXTURE_2D);
	    } else {
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    }
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.getGLFilter(gl, 'min'));
	    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.getGLFilter(gl, 'mag'));
	    gl.activeTexture(gl.TEXTURE0);
	  };
	
	  /**
	   * Returns the maximum dimensions
	   * @return {Number}
	   */
	
	
	  WebGLRenderer.prototype.getMaxDimensions = function getMaxDimensions() {
	    // node-gl support
	    var createContext = __webpack_require__(28);
	    if (createContext) {
	      var _gl = createContext(1, 1);
	      return _gl.getParameter(_gl.MAX_TEXTURE_SIZE);
	    }
	
	    var canvas = _globals.Utils.createCanvas();
	    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	    if (!gl) {
	      return null;
	    } else {
	      return gl.getParameter(gl.MAX_TEXTURE_SIZE);
	    }
	  };
	
	  /**
	   * Returns the current render target
	   * @return {PhotoEditorSDK.Engine.RenderTarget}
	   */
	
	
	  WebGLRenderer.prototype.getCurrentRenderTarget = function getCurrentRenderTarget() {
	    return this._currentRenderTarget;
	  };
	
	  /**
	   * Returns the current object renderer
	   * @return {PhotoEditorSDK.Engine.ObjectRenderer}
	   */
	
	
	  WebGLRenderer.prototype.getCurrentObjectRenderer = function getCurrentObjectRenderer() {
	    return this._currentObjectRenderer;
	  };
	
	  /**
	   * Checks if this renderer is supported on the current device and browser
	   * @return {Boolean}
	   */
	
	
	  WebGLRenderer.isSupported = function isSupported() {
	    if (__webpack_require__(28)) {
	      // We're on the server side and node-gl is available
	      return true;
	    }
	
	    if (typeof window === 'undefined') {
	      return false;
	    }
	
	    var canvas = _globals.Utils.createCanvas();
	    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	    return !!gl;
	  };
	
	  /**
	   * Disposes this Renderer
	   */
	
	
	  WebGLRenderer.prototype.dispose = function dispose() {
	    var _this3 = this;
	
	    this._filterManager.dispose();
	    this._currentObjectRenderer.dispose();
	    this._defaultRenderTarget.dispose();
	    this._textures.forEach(function (texture) {
	      texture.disposeGLTextures(_this3);
	    });
	  };
	
	  return WebGLRenderer;
	}(_baseRenderer2.default);
	
	WebGLRenderer.contextId = 0;
	WebGLRenderer.type = 'WebGL';
	
	exports.default = WebGLRenderer;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _textureShader = __webpack_require__(45);
	
	var _textureShader2 = _interopRequireDefault(_textureShader);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = {
	  TextureShader: _textureShader2.default
	}; /*
	    * This file is part of PhotoEditorSDK.
	    *
	    * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	    * All rights reserved.
	    *
	    * Redistribution and use in source and binary forms, without
	    * modification, are permitted provided that the following license agreement
	    * is approved and a legal/financial contract was signed by the user.
	    * The license agreement can be found under following link:
	    *
	    * https://www.photoeditorsdk.com/LICENSE.txt
	    */

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _container = __webpack_require__(66);
	
	var _container2 = _interopRequireDefault(_container);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A drawable rectangle with a texture
	 * @class
	 * @extends PhotoEditorSDK.Engine.Container
	 * @memberof PhotoEditorSDK.Engine
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Sprite = function (_Container) {
	  (0, _inherits3.default)(Sprite, _Container);
	
	  /**
	   * Creates a Sprite
	   * @param  {PhotoEditorSDK.Engine.Texture} texture
	   */
	
	  function Sprite(texture) {
	    (0, _classCallCheck3.default)(this, Sprite);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Container.call(this));
	
	    _this._onTextureUpdate = _this._onTextureUpdate.bind(_this);
	
	    _this._texture = texture;
	    _this._shader = null;
	
	    // Cached dimensions
	    _this._width = 0;
	    _this._height = 0;
	
	    _this._anchor = new _globals.Vector2(0, 0);
	
	    _this.setTexture(texture);
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when this sprite's texture has been updated
	   * @private
	   */
	
	
	  Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  // -------------------------------------------------------------------------- RENDERING
	
	  /**
	   * Renders the contents of this container
	   * @param {WebGLRenderer} renderer
	   * @private
	   */
	
	
	  Sprite.prototype._renderWebGL = function _renderWebGL(renderer) {
	    renderer.setObjectRenderer(renderer.renderers.sprite);
	    renderer.renderers.sprite.render(this);
	  };
	
	  /**
	   * Renders the contents of this container
	   * @param  {CanvasRenderer} renderer
	   * @private
	   */
	
	
	  Sprite.prototype._renderCanvas = function _renderCanvas(renderer) {
	    var transform = this._worldTransform;
	    var textureFrame = this._texture.getFrame();
	
	    var width = textureFrame.width;
	    var height = textureFrame.height;
	
	    var pixelRatio = renderer.getPixelRatio();
	
	    // Apply transform
	    var dx = this._anchor.x * -width;
	    var dy = this._anchor.y * -height;
	    var ctx = renderer.getContext();
	    ctx.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * pixelRatio, transform.ty * pixelRatio);
	
	    ctx.globalAlpha = this.getWorldAlpha();
	
	    var baseTexture = this._texture.getBaseTexture();
	    var texturePixelRatio = baseTexture.getPixelRatio();
	    ctx.drawImage(this._texture.getBaseTexture().getSource(),
	
	    // Source x, y, width, height
	    0, 0, width * texturePixelRatio, height * texturePixelRatio,
	
	    // Destination x, y, width, height
	    dx * pixelRatio, dy * pixelRatio, width * pixelRatio, height * pixelRatio);
	  };
	
	  // -------------------------------------------------------------------------- PUBLIC API
	
	  /**
	   * Checks if this sprite is located at the given position
	   * @param  {PhotoEditorSDK.Math.Vector2}  position
	   * @return {Boolean}
	   */
	
	
	  Sprite.prototype.isAtPosition = function isAtPosition(position) {
	    var localPosition = this._worldTransform.applyInverseToVector(position);
	    var textureFrame = this._texture.getFrame();
	    var width = textureFrame.width;
	    var height = textureFrame.height;
	
	
	    var upperLeft = new _globals.Vector2(-width, -height);
	    upperLeft.multiply(this._anchor);
	    var lowerRight = upperLeft.clone().add(width, height);
	
	    if (localPosition.x < upperLeft.x || localPosition.x > lowerRight.x || localPosition.y < upperLeft.y || localPosition.y > lowerRight.y) {
	      return false;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns the non-global bounds of this DisplayObject
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Sprite.prototype.getLocalBounds = function getLocalBounds() {
	    if (this._localBoundsNeedUpdate) {
	      var bounds = this._localBounds;
	      var textureFrame = this._texture.getFrame();
	
	      bounds.x = -textureFrame.width * this._anchor.x;
	      bounds.y = -textureFrame.height * this._anchor.y;
	      bounds.width = textureFrame.width;
	      bounds.height = textureFrame.height;
	
	      this._localBoundsNeedUpdate = false;
	    }
	    return this._localBounds.clone();
	  };
	
	  /**
	   * Returns the bounds for this DisplayObject
	   * @return {PhotoEditorSDK.Math.Rectangle}
	   */
	
	
	  Sprite.prototype.getBounds = function getBounds() {
	    var _this2 = this;
	
	    if (this._boundsNeedUpdate) {
	      (function () {
	        var bounds = _this2._bounds;
	        var textureFrame = _this2._texture.getFrame();
	
	        // @TODO Optimize this (if necessary). We could skip matrix application
	        //       when there's no rotation
	        var worldTransform = _this2._worldTransform;
	        var anchor = _this2._anchor;
	        var positions = worldTransform.rectangleToCoordinates(textureFrame, anchor);
	
	        var minX = positions[0].x;
	        var minY = positions[0].y;
	        var maxX = minX;
	        var maxY = minY;
	
	        positions.forEach(function (_ref) {
	          var x = _ref.x;
	          var y = _ref.y;
	
	          minX = Math.min(minX, x);
	          minY = Math.min(minY, y);
	          maxX = Math.max(maxX, x);
	          maxY = Math.max(maxY, y);
	        });
	
	        bounds.x = minX;
	        bounds.width = Math.abs(maxX - minX);
	        bounds.y = minY;
	        bounds.height = Math.abs(maxY - minY);
	
	        _this2._boundsNeedUpdate = false;
	      })();
	    }
	    return this._bounds.clone();
	  };
	
	  // -------------------------------------------------------------------------- GETTERS / SETTERS
	
	  /**
	   * Returns the current texture
	   * @return {PhotoEditorSDK.Engine.Texture} [description]
	   */
	
	
	  Sprite.prototype.getTexture = function getTexture() {
	    return this._texture;
	  };
	
	  /**
	   * Sets the texture
	   * @param {PhotoEditorSDK.Engine.Texture} texture
	   */
	
	
	  Sprite.prototype.setTexture = function setTexture(texture) {
	    if (!texture) {
	      return;
	    }
	
	    if (this._texture) {
	      this._texture.off('update', this._onTextureUpdate);
	    }
	
	    this._texture = texture;
	    if (texture.getBaseTexture().isLoaded()) {
	      this._onTextureUpdate();
	    }
	    texture.on('update', this._onTextureUpdate);
	  };
	
	  /**
	   * Returns the shader
	   * @return {PhotoEditorSDK.Engine.Shader}
	   */
	
	
	  Sprite.prototype.getShader = function getShader() {
	    return this._shader;
	  };
	
	  /**
	   * Sets the shader
	   * @param {PhotoEditorSDK.Engine.Shader} shader
	   */
	
	
	  Sprite.prototype.setShader = function setShader(shader) {
	    this._shader = shader;
	  };
	
	  /**
	   * Returns the width
	   * @return {Number}
	   */
	
	
	  Sprite.prototype.getWidth = function getWidth() {
	    return this._width;
	  };
	
	  /**
	   * Sets the width
	   * @param {Number} width
	   */
	
	
	  Sprite.prototype.setWidth = function setWidth(width) {
	    this._scale.x = width / this._texture.getFrame().width;
	    this._width = width;
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the height
	   * @return {Number}
	   */
	
	
	  Sprite.prototype.getHeight = function getHeight() {
	    return this._height;
	  };
	
	  /**
	   * Sets the height
	   * @param {Number} height
	   */
	
	
	  Sprite.prototype.setHeight = function setHeight(height) {
	    this._scale.y = height / this._texture.getFrame().height;
	    this._height = height;
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Returns the anchor
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Sprite.prototype.getAnchor = function getAnchor() {
	    return this._anchor;
	  };
	
	  /**
	   * Sets the anchor
	   * @param {PhotoEditorSDK.Math.Vector2} anchor
	   */
	
	
	  Sprite.prototype.setAnchor = function setAnchor(anchor, y) {
	    if (anchor instanceof _globals.Vector2) {
	      this._anchor.copy(anchor);
	    } else {
	      this._anchor.set(anchor, y);
	    }
	    this._boundsNeedUpdate = true;
	    this._localBoundsNeedUpdate = true;
	  };
	
	  /**
	   * Disposes this Sprite
	   */
	
	
	  Sprite.prototype.dispose = function dispose() {
	    if (this._texture) {
	      this._texture.off('update', this._onTextureUpdate);
	    }
	  };
	
	  return Sprite;
	}(_container2.default);
	
	exports.default = Sprite;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(6);
	
	var _texture = __webpack_require__(69);
	
	var _texture2 = _interopRequireDefault(_texture);
	
	var _baseTexture = __webpack_require__(46);
	
	var _baseTexture2 = _interopRequireDefault(_baseTexture);
	
	var _webglRenderTarget = __webpack_require__(30);
	
	var _webglRenderTarget2 = _interopRequireDefault(_webglRenderTarget);
	
	var _canvasRenderTarget = __webpack_require__(29);
	
	var _canvasRenderTarget2 = _interopRequireDefault(_canvasRenderTarget);
	
	var _webglFilterManager = __webpack_require__(43);
	
	var _webglFilterManager2 = _interopRequireDefault(_webglFilterManager);
	
	var _canvasFilterManager = __webpack_require__(42);
	
	var _canvasFilterManager2 = _interopRequireDefault(_canvasFilterManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A texture that you can render to
	 * @class
	 * @extends PhotoEditorSDK.Engine.Texture
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var RenderTexture = function (_Texture) {
	  (0, _inherits3.default)(RenderTexture, _Texture);
	
	  /**
	   * Creates a RenderTexture
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @param  {Number} [width = 100]
	   * @param  {Number} [height = 100]
	   * @param  {Number} [pixelRatio = 1]
	   */
	
	  function RenderTexture(renderer) {
	    var width = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];
	    var height = arguments.length <= 2 || arguments[2] === undefined ? 100 : arguments[2];
	    var pixelRatio = arguments.length <= 3 || arguments[3] === undefined ? 1 : arguments[3];
	    (0, _classCallCheck3.default)(this, RenderTexture);
	
	    var baseTexture = new _baseTexture2.default();
	    var frame = baseTexture.getFrame();
	    frame.width = width;
	    frame.height = height;
	    baseTexture.setPixelRatio(pixelRatio);
	    baseTexture.setLoaded(true);
	
	
	    // RenderTexture is always loaded!
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Texture.call(this, baseTexture, new _globals.Rectangle(0, 0, width, height)));
	
	    _this._loaded = true;
	    _this._width = width;
	    _this._height = height;
	    _this._pixelRatio = pixelRatio;
	    _this._renderer = renderer;
	
	    _this._setupFilterManager();
	    _this._setupBuffer();
	    _this._updateUVs();
	    return _this;
	  }
	
	  /**
	   * Sets up the filter manager
	   * @private
	   */
	
	
	  RenderTexture.prototype._setupFilterManager = function _setupFilterManager() {
	    /* istanbul ignore if */
	    if (this._renderer.isOfType('webgl')) {
	      this._filterManager = new _webglFilterManager2.default(this._renderer);
	    } else if (this._renderer.isOfType('canvas')) {
	      this._filterManager = new _canvasFilterManager2.default(this._renderer);
	    }
	
	    this._filterManager.resizeTo(new _globals.Vector2(this._width, this._height));
	  };
	
	  /**
	   * Sets up the buffer that we're rendering to
	   * @private
	   */
	
	
	  RenderTexture.prototype._setupBuffer = function _setupBuffer() {
	    /* istanbul ignore if */
	    if (this._renderer.isOfType('webgl')) {
	      this._setupWebGLBuffer();
	    } else if (this._renderer.isOfType('canvas')) {
	      this._setupCanvasRenderTarget();
	    }
	  };
	
	  /**
	   * Sets up the WebGLRenderTarget for this RenderTexture
	   * @private
	   */
	
	
	  RenderTexture.prototype._setupWebGLBuffer = function _setupWebGLBuffer() {
	    this._renderTarget = new _webglRenderTarget2.default(this._renderer, this._width, this._height, this._pixelRatio);
	    this._baseTexture.setGLTextureForId(this._renderTarget.getTexture(), this._renderer.getContext().id);
	  };
	
	  /**
	   * Sets up the CanvasRenderTarget for this RenderTexture
	   * @private
	   */
	
	
	  RenderTexture.prototype._setupCanvasRenderTarget = function _setupCanvasRenderTarget() {
	    this._renderTarget = new _canvasRenderTarget2.default(this._width, this._height, this._pixelRatio);
	    this._baseTexture.setSource(this._renderTarget.getCanvas());
	  };
	
	  /**
	   * Clears this texture's render buffer
	   * @param {PhotoEditorSDK.Color} color
	   */
	
	
	  RenderTexture.prototype.clear = function clear(color) {
	    this._renderTarget.clear(color);
	  };
	
	  /**
	   * Resizes this RenderTexture to the given dimensions
	   * @param  {PhotoEditorSDK.Math.Vector2} dimensions
	   */
	
	
	  RenderTexture.prototype.resizeTo = function resizeTo(dimensions) {
	    if (this._width === dimensions.x && this._height === dimensions.y) {
	      return;
	    }
	
	    this._width = dimensions.x;
	    this._height = dimensions.y;
	    this._frame.width = dimensions.x;
	    this._frame.height = dimensions.y;
	
	    this._baseTexture.resizeTo(dimensions);
	    this._renderTarget.resizeTo(dimensions);
	    this._filterManager.resizeTo(dimensions);
	  };
	
	  /**
	   * Renders the given DisplayObject
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   */
	
	
	  RenderTexture.prototype.render = function render(displayObject) {
	    /* istanbul ignore if */
	    if (this._renderer.isOfType('webgl')) {
	      this._renderWebGL(displayObject);
	    } else if (this._renderer.isOfType('canvas')) {
	      this._renderCanvas(displayObject);
	    } else {
	      throw new Error('RenderTexture does not support rendering via ' + this._renderer.constructor.name);
	    }
	  };
	
	  /**
	   * Renders the given DisplayObject using WebGL
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @private
	   */
	
	
	  RenderTexture.prototype._renderWebGL = function _renderWebGL(displayObject) {
	    this._renderTarget.activate();
	
	    displayObject.getWorldTransform().reset();
	    displayObject.getChildren().forEach(function (child) {
	      child.updateTransform();
	    });
	
	    var tempFilterManager = this._renderer.getFilterManager();
	    this._renderer.setFilterManager(this._filterManager);
	    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
	    this._renderer.setFilterManager(tempFilterManager);
	  };
	
	  /**
	   * Renders the given DisplayObject using Canvas2D
	   * @param  {PhotoEditorSDK.Engine.DisplayObject} displayObject
	   * @private
	   */
	
	
	  RenderTexture.prototype._renderCanvas = function _renderCanvas(displayObject) {
	    displayObject.getWorldTransform().reset();
	    displayObject.getChildren().forEach(function (child) {
	      child.updateTransform();
	    });
	
	    var tempFilterManager = this._renderer.getFilterManager();
	    this._renderer.setFilterManager(this._filterManager);
	    this._renderer.renderDisplayObject(displayObject, this._renderTarget);
	    this._renderer.setFilterManager(tempFilterManager);
	  };
	
	  /**
	   * Returns the render target
	   * @return {PhotoEditorSDK.Engine.WebGLRenderTarget}
	   */
	
	
	  RenderTexture.prototype.getRenderTarget = function getRenderTarget() {
	    return this._renderTarget;
	  };
	
	  /**
	   * Disposes this RenderTexture
	   */
	
	
	  RenderTexture.prototype.dispose = function dispose() {
	    this._baseTexture.dispose(this._renderer);
	    this._renderTarget.dispose();
	    this._filterManager.dispose();
	  };
	
	  return RenderTexture;
	}(_texture2.default); /*
	                       * This file is part of PhotoEditorSDK.
	                       *
	                       * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                       * All rights reserved.
	                       *
	                       * Redistribution and use in source and binary forms, without
	                       * modification, are permitted provided that the following license agreement
	                       * is approved and a legal/financial contract was signed by the user.
	                       * The license agreement can be found under following link:
	                       *
	                       * https://www.photoeditorsdk.com/LICENSE.txt
	                       */
	
	exports.default = RenderTexture;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * Represents a rectangle that is rendered using WebGL
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 * @ignore
	 */
	/* istanbul ignore next */
	
	var Quad = function () {
	  function Quad(renderer) {
	    (0, _classCallCheck3.default)(this, Quad);
	
	    this._renderer = renderer;
	
	    this._vertices = new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
	
	    this._uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
	
	    this._indices = new Uint16Array([0, 1, 2, 0, 3, 2]);
	
	    this._colors = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);
	
	    this._initBuffers();
	    this._uploadBuffers();
	  }
	
	  /**
	   * Maps the given rectangles to the quad
	   * @param  {Rectangle} rect1
	   * @param  {Rectangle} rect2
	   */
	
	
	  Quad.prototype.map = function map(rect1, rect2) {
	    var x = rect2.x;
	    var y = rect2.y;
	
	    // Update the UVs
	    // We don't have any translation, so these four
	    // values are all we need
	
	    this._uvs[2] = rect2.width / rect1.width;
	    this._uvs[4] = this._uvs[2];
	    this._uvs[5] = rect2.height / rect1.height;
	    this._uvs[7] = this._uvs[5];
	
	    // Update the vertices
	    this._vertices[0] = x;
	    this._vertices[1] = y;
	
	    this._vertices[2] = x + rect2.width;
	    this._vertices[3] = y;
	
	    this._vertices[4] = this._vertices[2];
	    this._vertices[5] = y + rect2.height;
	
	    this._vertices[6] = x;
	    this._vertices[7] = this._vertices[5];
	
	    this._uploadBuffers();
	  };
	
	  /**
	   * Initializes the buffers
	   * @private
	   */
	
	
	  Quad.prototype._initBuffers = function _initBuffers() {
	    var gl = this._renderer.getContext();
	
	    // Init vertex buffer
	    this._vertexBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	    gl.bufferData(gl.ARRAY_BUFFER, (8 + 8 + 16) * 4, gl.DYNAMIC_DRAW);
	
	    this._indexBuffer = gl.createBuffer();
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
	    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
	  };
	
	  /**
	   * Uploads the buffers
	   * @private
	   */
	
	
	  Quad.prototype._uploadBuffers = function _uploadBuffers() {
	    var gl = this._renderer.getContext();
	
	    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
	    gl.bufferSubData(gl.ARRAY_BUFFER, 8 * 4, this._uvs);
	    gl.bufferSubData(gl.ARRAY_BUFFER, (8 + 8) * 4, this._colors);
	  };
	
	  Quad.prototype.getVertexBuffer = function getVertexBuffer() {
	    return this._vertexBuffer;
	  };
	
	  Quad.prototype.getIndexBuffer = function getIndexBuffer() {
	    return this._indexBuffer;
	  };
	
	  /**
	   * Cleans up this Quad's buffers
	   */
	
	
	  Quad.prototype.dispose = function dispose() {
	    var gl = this._renderer.getContext();
	    gl.deleteBuffer(this._vertexBuffer);
	    gl.deleteBuffer(this._indexBuffer);
	  };
	
	  return Quad;
	}();
	
	exports.default = Quad;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(6);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Represents the UV coordinates of a texture
	 * @class
	 * @memberof PhotoEditorSDK.Engine
	 */
	
	var TextureUVs = function () {
	  /**
	   * Creates a TextureUVs instance
	   */
	
	  function TextureUVs() {
	    (0, _classCallCheck3.default)(this, TextureUVs);
	
	    this._uvs = [new _globals.Vector2(0, 0), new _globals.Vector2(1, 0), new _globals.Vector2(1, 1), new _globals.Vector2(0, 1)];
	  }
	
	  /**
	   * Updates the UVs based on the given baseframe
	   * @param  {Rectangle} frame
	   * @param  {Rectangle} baseFrame
	   */
	
	
	  TextureUVs.prototype.update = function update(frame, baseFrame) {
	    // Upper left
	    var uv = this._uvs[0];
	    uv.x = frame.x / baseFrame.width;
	    uv.y = frame.y / baseFrame.height;
	
	    // Upper right
	    uv = this._uvs[1];
	    uv.x = (frame.x + frame.width) / baseFrame.width;
	    uv.y = frame.y / baseFrame.height;
	
	    // Lower right
	    uv = this._uvs[2];
	    uv.x = (frame.x + frame.width) / baseFrame.width;
	    uv.y = (frame.y + frame.height) / baseFrame.height;
	
	    // Lower left
	    uv = this._uvs[3];
	    uv.x = frame.x / baseFrame.width;
	    uv.y = (frame.y + frame.height) / baseFrame.height;
	  };
	
	  /**
	   * Returns the UV coordinates for the given index
	   * @param  {Number} index
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  TextureUVs.prototype.getUVsAt = function getUVsAt(index) {
	    return this._uvs[index];
	  };
	
	  /**
	   * Returns the UV coordinates
	   * @return {Array.<PhotoEditorSDK.Math.Vector2>}
	   */
	
	
	  TextureUVs.prototype.getUVs = function getUVs() {
	    return this._uvs;
	  };
	
	  return TextureUVs;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = TextureUVs;

/***/ },
/* 105 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * A couple of utility functions
	 * @type {Object}
	 */
	var Utils = {
	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object for all destination properties that resolve to undefined. Once a
	   * property is set, additional values of the same property are ignored.
	   * @param  {Object} object
	   * @param  {Object} ...sources
	   * @return {Object}
	   */
	  defaults: function defaults(object) {
	    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      sources[_key - 1] = arguments[_key];
	    }
	
	    // Shallow clone
	    var newObject = {};
	    for (var key in object) {
	      newObject[key] = object[key];
	    }
	
	    // Clone sources
	    for (var i = 0; i < sources.length; i++) {
	      var source = sources[i];
	      for (var _key2 in source) {
	        if (typeof newObject[_key2] === 'undefined') {
	          newObject[_key2] = source[_key2];
	        }
	      }
	    }
	
	    return newObject;
	  },
	
	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object. Subsequent sources overwrite property assignments of previous
	   * sources.
	   * @param {Object} object
	   * @param {Object} ...sources
	   * @return {Object}
	   */
	  extend: function extend(object) {
	    for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
	      sources[_key3 - 1] = arguments[_key3];
	    }
	
	    // Shallow clone
	    var newObject = {};
	    for (var key in object) {
	      newObject[key] = object[key];
	    }
	
	    // Extend sources
	    for (var i = 0; i < sources.length; i++) {
	      var source = sources[i];
	      for (var _key4 in source) {
	        newObject[_key4] = source[_key4];
	      }
	    }
	
	    return newObject;
	  }
	};
	
	exports.default = Utils;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _sdk = __webpack_require__(95);
	
	var _sdk2 = _interopRequireDefault(_sdk);
	
	var _math = __webpack_require__(62);
	
	var Math = _interopRequireWildcard(_math);
	
	var _operations = __webpack_require__(64);
	
	var Operations = _interopRequireWildcard(_operations);
	
	var _filters = __webpack_require__(94);
	
	var Filters = _interopRequireWildcard(_filters);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _eventEmitter = __webpack_require__(21);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _utils = __webpack_require__(22);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _operationsStack = __webpack_require__(63);
	
	var _operationsStack2 = _interopRequireDefault(_operationsStack);
	
	var _exif = __webpack_require__(40);
	
	var _exif2 = _interopRequireDefault(_exif);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _constants = __webpack_require__(38);
	
	var _base = __webpack_require__(39);
	
	var _base2 = _interopRequireDefault(_base);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * The current version of the SDK
	 * @name PhotoEditorSDK.version
	 * @internal Keep in sync with package.json
	 */
	_sdk2.default.version = __webpack_require__(65).version;
	
	// Namespaces
	/*!
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	_sdk2.default.Math = Math;
	
	_sdk2.default.Operations = Operations;
	
	_sdk2.default.Filters = Filters;
	
	_sdk2.default.FilterPrimitives = FilterPrimitives;
	
	_sdk2.default.Engine = _engine2.default;
	
	// Classes
	
	_sdk2.default.Color = _color2.default;
	
	_sdk2.default.Filter = _filter2.default;
	
	_sdk2.default.Operation = _operation2.default;
	
	_sdk2.default.EventEmitter = _eventEmitter2.default;
	
	_sdk2.default.Utils = _utils2.default;
	
	_sdk2.default.OperationsStack = _operationsStack2.default;
	
	_sdk2.default.EXIF = _exif2.default;
	
	_sdk2.default.Promise = _promise2.default;
	
	// Constants
	
	_sdk2.default.RenderType = _constants.RenderType;
	_sdk2.default.ImageFormat = _constants.ImageFormat;
	
	// Libs
	
	_sdk2.default.Base64 = _base2.default;
	
	module.exports = _sdk2.default;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	/**
	 * An ArrayStream provides methods for working with a byte array
	 * @class
	 * @memberof PhotoEditorSDK
	 * @ignore
	 */
	
	var ArrayStream = function () {
	  /**
	   * Creates an ArrayStream
	   * @param  {Array} buf
	   */
	
	  function ArrayStream(buf) {
	    (0, _classCallCheck3.default)(this, ArrayStream);
	
	    this._head = 0;
	    this._buf = buf;
	  }
	
	  /**
	   * Returns the value of the following 8 bit integer
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.peekInt8 = function peekInt8() {
	    return this._buf[this._head];
	  };
	
	  /**
	   * Returns the value of the following 16 bit integer
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.peekInt16 = function peekInt16() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var a = this._buf[this._head];
	    var b = this._buf[this._head + 1];
	    if (!littleEndian) {
	      return (a << 8) + b;
	    } else {
	      return (b << 8) + a;
	    }
	  };
	
	  /**
	   * Returns the value of the following 24 bit integer
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.peekInt24 = function peekInt24() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var a = this._buf[this._head];
	    var b = this._buf[this._head + 1];
	    var c = this._buf[this._head + 2];
	    if (!littleEndian) {
	      return (a << 16) + (b << 8) + c;
	    } else {
	      return (c << 16) + (b << 8) + a;
	    }
	  };
	
	  /**
	   * Returns the value of the following 32 bit integer
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.peekInt32 = function peekInt32() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var a = this._buf[this._head];
	    var b = this._buf[this._head + 1];
	    var c = this._buf[this._head + 2];
	    var d = this._buf[this._head + 3];
	    if (!littleEndian) {
	      return (a << 32) + (b << 16) + (c << 8) + d;
	    } else {
	      return (d << 32) + (c << 16) + (b << 8) + a;
	    }
	  };
	
	  /**
	   * Writes the given 16 bit integer at the current head position
	   * @param  {Number} num
	   */
	
	
	  ArrayStream.prototype.writeInt16 = function writeInt16(num) {
	    this._buf[this._head] = num >> 8; // upper
	    this._buf[this._head + 1] = num & 0xff; // lower
	  };
	
	  /**
	   * Returns the value of the following 8 bit integer and moves the head by 1 byte
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.readInt8 = function readInt8() {
	    var num = this.peekInt8();
	    this._head += 1;
	    return num;
	  };
	
	  /**
	   * Returns the value of the following 16 bit integer and moves the head by 2 bytes
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.readInt16 = function readInt16() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var num = this.peekInt16(littleEndian);
	    this._head += 2;
	    return num;
	  };
	
	  /**
	   * Returns the value of the following 24 bit integer and moves the head by 3 bytes
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.readInt24 = function readInt24() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var num = this.peekInt24(littleEndian);
	    this._head += 3;
	    return num;
	  };
	
	  /**
	   * Returns the value of the following 32 bit integer and moves the head by 4 bytes
	   * @param  {Boolean} [littleEndian = false]
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.readInt32 = function readInt32() {
	    var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	    var num = this.peekInt32(littleEndian);
	    this._head += 4;
	    return num;
	  };
	
	  /**
	   * Reads a string with the given length
	   * @param  {Number} length
	   * @return {String}
	   */
	
	
	  ArrayStream.prototype.readString = function readString(length) {
	    var str = '';
	    for (var i = 0; i < length; i++) {
	      var character = this.readInt8();
	      str += String.fromCharCode(character);
	    }
	    return str;
	  };
	
	  /**
	   * Returns the current head position
	   * @return {Number}
	   */
	
	
	  ArrayStream.prototype.getHead = function getHead() {
	    return this._head;
	  };
	
	  /**
	   * Sets the head position
	   * @param {Number} head
	   */
	
	
	  ArrayStream.prototype.setHead = function setHead(head) {
	    this._head = head;
	  };
	
	  return ArrayStream;
	}();
	
	exports.default = ArrayStream;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _constants = __webpack_require__(38);
	
	var _utils = __webpack_require__(22);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _exif = __webpack_require__(40);
	
	var _exif2 = _interopRequireDefault(_exif);
	
	var _nodeGlExporter = __webpack_require__(109);
	
	var _nodeGlExporter2 = _interopRequireDefault(_nodeGlExporter);
	
	var _canvas = __webpack_require__(17);
	
	var _canvas2 = _interopRequireDefault(_canvas);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * @class
	 * @alias PhotoEditorSDK.ImageExporter
	 * @private
	 */
	/* global Image */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var ImageExporter = function () {
	  function ImageExporter() {
	    (0, _classCallCheck3.default)(this, ImageExporter);
	  }
	
	  /**
	   * Validates the given RenderType and ImageFormat
	   * @param  {PhotoEditorSDK.RenderType} renderType
	   * @param  {PhotoEditorSDK.ImageFormat} imageFormat
	   * @return {Promise}
	   * @todo Clean this mess up
	   */
	
	  ImageExporter.validateSettings = function validateSettings(renderType, imageFormat) {
	    return new _promise2.default(function (resolve, reject) {
	      var settings = {
	        renderType: renderType,
	        imageFormat: imageFormat
	      };
	
	      // Validate RenderType
	      if (typeof settings.renderType !== 'undefined' && settings.renderType !== null && _utils2.default.values(_constants.RenderType).indexOf(settings.renderType) === -1) {
	        throw new Error('Invalid render type: ' + settings.renderType);
	      } else if (typeof renderType === 'undefined') {
	        settings.renderType = _constants.RenderType.DATAURL;
	      }
	
	      // Validate ImageFormat
	      if (typeof settings.imageFormat !== 'undefined' && settings.imageFormat !== null && _utils2.default.values(_constants.ImageFormat).indexOf(settings.imageFormat) === -1) {
	        throw new Error('Invalid image format: ' + settings.imageFormat);
	      } else if (typeof imageFormat === 'undefined') {
	        settings.imageFormat = _constants.ImageFormat.PNG;
	      }
	
	      // Render type 'buffer' only available in node
	      if (settings.renderType === _constants.RenderType.BUFFER && typeof process === 'undefined') {
	        throw new Error('Render type \'buffer\' is only available when using node.js');
	      }
	
	      resolve(settings);
	    });
	  };
	
	  /**
	   * Exports the image from the given canvas with the given options
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Image} image
	   * @param  {HTMLCanvasElement} canvas
	   * @param  {PhotoEditorSDK.RenderType} renderType
	   * @param  {PhotoEditorSDK.ImageFormat} imageFormat
	   * @param  {Number} [quality = 0.8]
	   * @return {Promise}
	   */
	
	
	  ImageExporter.export = function _export(sdk, image, canvas, renderType, imageFormat) {
	    var quality = arguments.length <= 5 || arguments[5] === undefined ? 0.8 : arguments[5];
	
	    return new _promise2.default(function (resolve, reject) {
	      var result = void 0;
	      if (renderType === _constants.RenderType.IMAGE || renderType === _constants.RenderType.DATAURL) {
	        if (typeof window === 'undefined') {
	          // Quality not supported in node environment / node-canvas
	          result = canvas.toDataURL(imageFormat);
	        } else {
	          result = canvas.toDataURL(imageFormat, quality);
	        }
	
	        // When image's `src` attribute is a jpeg data url, we can restore
	        // the exif information
	        if (_exif2.default.isJPEG(image.src) && _exif2.default.isJPEG(result)) {
	          var exif = sdk.getExif();
	          if (exif) {
	            result = exif.restoreExifTags(result);
	          }
	        }
	      }
	
	      var renderer = sdk.getRenderer();
	      if (renderer.isOfType('webgl') && typeof _canvas2.default !== 'undefined' && canvas instanceof _canvas2.default) {
	        _nodeGlExporter2.default.renderContextToCanvas(renderer.getContext(), canvas);
	      }
	
	      if (renderType === _constants.RenderType.IMAGE) {
	        var outputImage = void 0;
	
	        /* istanbul ignore else  */
	        if (typeof Image === 'undefined') {
	          // Not a browser environment
	          var CanvasImage = __webpack_require__(17).Image;
	          outputImage = new CanvasImage();
	        } else {
	          outputImage = new Image();
	        }
	
	        outputImage.src = result;
	        resolve(outputImage);
	      } else if (renderType === _constants.RenderType.DATAURL) {
	        resolve(result);
	      } else if (renderType === _constants.RenderType.BUFFER) {
	        resolve(canvas.toBuffer());
	      } else if (renderType === _constants.RenderType.MSBLOB) {
	        resolve(canvas.msToBlob());
	      } else if (renderType === _constants.RenderType.BLOB) {
	        canvas.toBlob(function (blob) {
	          resolve(blob);
	        }, imageFormat, quality);
	      }
	    });
	  };
	
	  return ImageExporter;
	}();
	
	exports.default = ImageExporter;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(37)))

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _canvas = __webpack_require__(17);
	
	var _canvas2 = _interopRequireDefault(_canvas);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var NodeGLExporter = function () {
	  function NodeGLExporter() {
	    (0, _classCallCheck3.default)(this, NodeGLExporter);
	  }
	
	  /**
	   * Creates a new `node-canvas` Canvas and renders the image from the `gl` context onto it
	   * @param  {WebGLRenderingContext2D} gl
	   * @param  {Canvas} canvas
	   */
	
	  NodeGLExporter.renderContextToCanvas = function renderContextToCanvas(gl, canvas) {
	    var width = canvas.width;
	    var height = canvas.height;
	
	    var pixels = new Uint8Array(width * height * 4);
	    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
	
	    var context = canvas.getContext('2d');
	    var imageData = new _canvas2.default.ImageData(width, height);
	
	    var i = 0;
	    pixels.forEach(function () {
	      imageData.data[i] = pixels[i];
	      i++;
	    });
	
	    context.putImageData(imageData, 0, 0);
	  };
	
	  return NodeGLExporter;
	}(); /*
	      * This file is part of PhotoEditorSDK.
	      *
	      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	      * All rights reserved.
	      *
	      * Redistribution and use in source and binary forms, without
	      * modification, are permitted provided that the following license agreement
	      * is approved and a legal/financial contract was signed by the user.
	      * The license agreement can be found under following link:
	      *
	      * https://www.photoeditorsdk.com/LICENSE.txt
	      */
	
	exports.default = NodeGLExporter;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(5);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var VERSION_CHECK_FN = 'imglySDKVersionCallback'; /*
	                                                   * This file is part of PhotoEditorSDK.
	                                                   *
	                                                   * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                                                   * All rights reserved.
	                                                   *
	                                                   * Redistribution and use in source and binary forms, without
	                                                   * modification, are permitted provided that the following license agreement
	                                                   * is approved and a legal/financial contract was signed by the user.
	                                                   * The license agreement can be found under following link:
	                                                   *
	                                                   * https://www.photoeditorsdk.com/LICENSE.txt
	                                                   */
	
	var VERSION_CHECK_URL = 'https://www.photoeditorsdk.com/version.json?sdk=html5&jsoncallback=' + VERSION_CHECK_FN;
	
	/**
	 * Checks whether there is a new version of the SDK available
	 * @class
	 * @memberof PhotoEditorSDK
	 * @ignore
	 */
	/* istanbul ignore next */
	
	var VersionChecker = function () {
	  /**
	   * Creates a new VersionChecker
	   * @param  {String} version
	   */
	
	  function VersionChecker(version) {
	    (0, _classCallCheck3.default)(this, VersionChecker);
	
	    this._version = version;
	    this._check();
	  }
	
	  /**
	   * Checks if this version of the SDK is outdated
	   * @private
	   */
	
	
	  VersionChecker.prototype._check = function _check() {
	    var _this = this;
	
	    if (typeof document === 'undefined') {
	      return _globals.Log.info(this.constructor.name, 'Not in browser environment. Version check skipped.');
	    }
	
	    var self = this;
	    window[VERSION_CHECK_FN] = function (response) {
	      if (response.outdated) {
	        _globals.Log.warn(_this.constructor.name, 'Your Version ' + self._version + ' is outdated. Current version is ' + response.version + '.');
	      }
	    };
	
	    var script = document.createElement('script');
	    script.src = VERSION_CHECK_URL + '&version=' + this._version;
	    script.async = true;
	    document.getElementsByTagName('head')[0].appendChild(script);
	  };
	
	  return VersionChecker;
	}();
	
	exports.default = VersionChecker;

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _adjustmentsFilter = __webpack_require__(76);
	
	var _adjustmentsFilter2 = _interopRequireDefault(_adjustmentsFilter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Applies adjustments (brightness, saturation, contrast) to the image
	 * @class
	 * @alias Operations.AdjustmentsOperation
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var AdjustmentsOperation = function (_Operation) {
	  (0, _inherits3.default)(AdjustmentsOperation, _Operation);
	
	  /**
	   * Creates a new AdjustmentsOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   * @param  {Number} [options.brightness = 0]
	   * @param  {Number} [options.saturation = 1]
	   * @param  {Number} [options.contrast = 1]
	   */
	
	  function AdjustmentsOperation() {
	    (0, _classCallCheck3.default)(this, AdjustmentsOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._filter = new _adjustmentsFilter2.default();
	    _this._sprite.setFilters([_this._filter]);
	    return _this;
	  }
	
	  /**
	   * Applies this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise} renderer
	   * @private
	   */
	
	
	  AdjustmentsOperation.prototype._render = function _render(sdk) {
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	    var renderer = sdk.getRenderer();
	
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var spriteBounds = outputSprite.getBounds();
	    var spriteDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	    renderTexture.resizeTo(spriteDimensions);
	
	    this._filter.set({
	      brightness: this._options.brightness,
	      saturation: this._options.saturation,
	      contrast: this._options.contrast
	    });
	
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	
	    this.setDirtyForRenderer(false, renderer);
	
	    return _promise2.default.resolve();
	  };
	
	  return AdjustmentsOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	AdjustmentsOperation.identifier = 'adjustments';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	AdjustmentsOperation.prototype.availableOptions = {
	  brightness: { type: 'number', default: 0 },
	  saturation: { type: 'number', default: 1.0 },
	  contrast: { type: 'number', default: 1.0 }
	};
	
	exports.default = AdjustmentsOperation;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BorderFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(BorderFilter, _Engine$Filter);
	
	  function BorderFilter() {
	    (0, _classCallCheck3.default)(this, BorderFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(213);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  BorderFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var outputContext = outputTarget.getContext();
	
	    var _options = this._options;
	    var color = _options.color;
	    var thickness = _options.thickness;
	
	
	    outputContext.save();
	    outputContext.drawImage(canvas, 0, 0);
	    outputContext.beginPath();
	    outputContext.lineWidth = thickness * 2;
	    outputContext.strokeStyle = color.toRGBA();
	    outputContext.rect(0, 0, canvas.width, canvas.height);
	    outputContext.stroke();
	    outputContext.restore();
	  };
	
	  return BorderFilter;
	}(_globals.Engine.Filter);
	
	BorderFilter.prototype.availableOptions = {
	  color: { type: 'color', default: _globals.Color.BLACK, uniformType: '4f' },
	  thickness: { type: 'number', default: 0, uniformType: 'f' },
	  textureSize: { type: 'vector2', default: new _globals.Vector2(0, 0), uniformType: '2f' }
	};
	
	/**
	 * An operation that can draw a border around the canvas
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	
	var BorderOperation = function (_Operation) {
	  (0, _inherits3.default)(BorderOperation, _Operation);
	
	  /**
	   * Creates a new BorderOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function BorderOperation() {
	    (0, _classCallCheck3.default)(this, BorderOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this2._filter = new BorderFilter();
	    _this2._sprite.setFilters([_this2._filter]);
	    return _this2;
	  }
	
	  /**
	   * Renders the border operation
	   * @param  {PhotoEditorSDK} sdk
	   * @private
	   */
	
	
	  BorderOperation.prototype._render = function _render(sdk) {
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	    var renderer = sdk.getRenderer();
	
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var spriteBounds = outputSprite.getBounds();
	    var spriteDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	
	    renderTexture.resizeTo(spriteDimensions);
	
	    var _options2 = this._options;
	    var color = _options2.color;
	    var thickness = _options2.thickness;
	
	    // Update uniforms
	
	    this._filter.set({
	      color: color,
	      thickness: thickness,
	      textureSize: spriteDimensions
	    });
	
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	    this.setDirtyForRenderer(false, renderer);
	
	    return _globals.Promise.resolve();
	  };
	
	  return BorderOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	BorderOperation.identifier = 'border';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	BorderOperation.prototype.availableOptions = {
	  color: { type: 'color', default: new _globals.Color(0, 0, 0, 1) },
	  thickness: { type: 'number', default: 5 }
	};
	
	exports.default = BorderOperation;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _path = __webpack_require__(114);
	
	var _path2 = _interopRequireDefault(_path);
	
	var _controlPoint = __webpack_require__(77);
	
	var _controlPoint2 = _interopRequireDefault(_controlPoint);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can draw brushes on the canvas
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BrushOperation = function (_Operation) {
	  (0, _inherits3.default)(BrushOperation, _Operation);
	
	  /**
	   * Creates a new BrushOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function BrushOperation() {
	    (0, _classCallCheck3.default)(this, BrushOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._brushCanvasDirty = true;
	    _this._brushCanvas = _globals.Utils.createCanvas();
	    _this._texture = _globals.Engine.Texture.fromCanvas(_this._brushCanvas);
	    _this._sprite.setTexture(_this._texture);
	
	    _this._inputSprite = new _globals.Engine.Sprite();
	    _this._container.removeChild(_this._sprite);
	    _this._container.addChild(_this._inputSprite);
	    _this._container.addChild(_this._sprite);
	
	    _this._onPathUpdate = _this._onPathUpdate.bind(_this);
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._sdk.on(_globals.Constants.Events.OPERATION_UPDATED, _this._onOperationUpdate);
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when a path has been updated
	   * @private
	   */
	
	
	  BrushOperation.prototype._onPathUpdate = function _onPathUpdate() {
	    this.setDirty(true, false);
	  };
	
	  /**
	   * Gets called when an operation is about to be updated. If the crop
	   * or rotation operation is updated, this will be recognized and the
	   * stickers will be updated accordingly
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  BrushOperation.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    var identifier = operation.constructor.identifier;
	
	
	    if (identifier === 'crop' && 'start' in options && 'end' in options) {
	      this._applyCrop(operation, options);
	    }
	
	    if (identifier === 'orientation') {
	      if ('rotation' in options) {
	        this._applyRotation(operation, options);
	      }
	
	      if ('flipVertically' in options && operation.getFlipVertically() !== options.flipVertically) {
	        this._applyFlip(operation, 'vertical');
	      }
	
	      if ('flipHorizontally' in options && operation.getFlipHorizontally() !== options.flipHorizontally) {
	        this._applyFlip(operation, 'horizontal');
	      }
	    }
	  };
	
	  // -------------------------------------------------------------------------- UPDATE BY OTHER OPERATION
	
	  /**
	   * Applies the given crop change
	   * @param  {PhotoEditorSDK.Operations.CropOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  BrushOperation.prototype._applyCrop = function _applyCrop(operation, options) {
	    var inputDimensions = this._sdk.getInputDimensions();
	
	    var oldStart = operation.getStart();
	    var newStart = options.start;
	
	    this._options.paths.forEach(function (path) {
	      path.forEachControlPoint(function (controlPoint) {
	        var position = controlPoint.getPosition().clone();
	        controlPoint.setPosition(position.add(oldStart.clone().subtract(newStart).multiply(inputDimensions)));
	      });
	    });
	
	    this.setDirty(true, true);
	    this.clearBrushCanvas();
	  };
	
	  /**
	   * Applies the given rotation change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  BrushOperation.prototype._applyRotation = function _applyRotation(operation, options) {
	    var oldRotation = operation.getRotation();
	    var newRotation = options.rotation;
	    var degreesDifference = newRotation - oldRotation;
	
	    var finalDimensions = this._sdk.getFinalDimensions();
	    this._options.paths.forEach(function (path) {
	      path.forEachControlPoint(function (controlPoint) {
	        var position = controlPoint.getPosition().clone();
	        if (degreesDifference === 90 || oldRotation === 270 && newRotation === 0) {
	          position.flip();
	          position.x = finalDimensions.y - position.x;
	        } else if (degreesDifference === -90 || oldRotation === -270 && newRotation === 0) {
	          position.flip();
	          position.y = finalDimensions.x - position.y;
	        }
	        controlPoint.setPosition(position);
	      });
	    });
	
	    this.setDirty(true, true);
	    this.clearBrushCanvas();
	  };
	
	  /**
	   * Applies a flip with the given direction
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {String} direction
	   * @private
	   */
	
	
	  BrushOperation.prototype._applyFlip = function _applyFlip(operation, direction) {
	    var rotation = operation.getRotation();
	    if (rotation === 90 || rotation === 270) {
	      if (direction === 'vertical') {
	        direction = 'horizontal';
	      } else {
	        direction = 'vertical';
	      }
	    }
	
	    var finalDimensions = this._sdk.getFinalDimensions();
	    this._options.paths.forEach(function (path) {
	      path.forEachControlPoint(function (controlPoint) {
	        var position = controlPoint.getPosition().clone();
	        switch (direction) {
	          case 'horizontal':
	            position.x = finalDimensions.x - position.x;
	            break;
	          case 'vertical':
	            position.y = finalDimensions.y - position.y;
	            break;
	        }
	        controlPoint.setPosition(position);
	      });
	    });
	
	    this.setDirty(true, true);
	    this.clearBrushCanvas();
	  };
	
	  // -------------------------------------------------------------------------- RENDERING
	
	  /**
	   * Renders the brush operation
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   * @override
	   * @private
	   */
	
	
	  BrushOperation.prototype._render = function _render(sdk) {
	    this.renderBrushCanvas(sdk);
	
	    var renderer = sdk.getRenderer();
	    var outputSprite = sdk.getSprite();
	    this._inputSprite.setTexture(outputSprite.getTexture());
	
	    /* istanbul ignore next */
	    if (renderer.isOfType('webgl')) {
	      renderer.updateTexture(this._texture.getBaseTexture());
	    }
	
	    var renderTexture = this._getRenderTexture(sdk);
	    var outputBounds = outputSprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(outputBounds.width, outputBounds.height));
	
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	
	    return _globals.Promise.resolve();
	  };
	
	  /**
	   * Clears the brush canvas
	   */
	
	
	  BrushOperation.prototype.clearBrushCanvas = function clearBrushCanvas() {
	    if (!this._brushCanvas) {
	      return;
	    }
	
	    this._brushCanvasDirty = true;
	    var canvas = this._brushCanvas;
	    var context = canvas.getContext('2d');
	    context.clearRect(0, 0, canvas.width, canvas.height);
	  };
	
	  /**
	   * Renders the brush canvas that will be used as a texture in WebGL
	   * and as an image in canvas
	   * @param {HTMLCanvasElement} canvas
	   * @private
	   */
	
	
	  BrushOperation.prototype.renderBrushCanvas = function renderBrushCanvas(sdk) {
	    var canvas = arguments.length <= 1 || arguments[1] === undefined ? this._brushCanvas : arguments[1];
	
	    var finalDimensions = sdk.getFinalDimensions();
	    if (canvas.width !== finalDimensions.x || canvas.height !== finalDimensions.y) {
	      canvas.width = finalDimensions.x;
	      canvas.height = finalDimensions.y;
	      this._texture.getBaseTexture().update();
	    }
	
	    var paths = this._options.paths;
	    for (var i = 0; i < paths.length; i++) {
	      var path = paths[i];
	      path.renderToCanvas(canvas);
	    }
	    this._brushCanvasDirty = false;
	  };
	
	  /**
	   * Creates and adds a new path
	   * @param {Number} thickness
	   * @param {Color} color
	   * @return {PhotoEditorSDK.Operations.BrushOperation.Path}
	   */
	
	
	  BrushOperation.prototype.createPath = function createPath(thickness, color) {
	    var path = new BrushOperation.Path(this, thickness, color);
	    path.on('update', this._onPathUpdate);
	    this._options.paths.push(path);
	    this.setDirty(true);
	    return path;
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @param {Boolean} [setPathsToDirty = false]
	   * @override
	   */
	
	
	  BrushOperation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    var setPathsToDirty = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	    _Operation.prototype.setDirtyForRenderer.call(this, dirty, renderer);
	
	    if (setPathsToDirty) {
	      this._options.paths.forEach(function (path) {
	        path.setDirty();
	      });
	    }
	  };
	
	  /**
	   * Sets the dirtiness for all renderers
	   * @param {Boolean} dirty
	   * @param {Boolean} [setPathsToDirty = false]
	   * @override
	   */
	
	
	  BrushOperation.prototype.setDirty = function setDirty(dirty) {
	    var setPathsToDirty = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    for (var rendererId in this._dirtiness) {
	      this.setDirtyForRenderer(dirty, { id: rendererId }, setPathsToDirty);
	    }
	  };
	
	  /**
	   * Disposes this operation
	   * @override
	   */
	
	
	  BrushOperation.prototype.dispose = function dispose() {
	    this._sdk.off(_globals.Constants.Events.OPERATION_UPDATED, this._onOperationUpdate);
	  };
	
	  return BrushOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	BrushOperation.identifier = 'brush';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	BrushOperation.prototype.availableOptions = {
	  thickness: { type: 'number', default: 10 },
	  color: { type: 'color', default: new _globals.Color(1, 0, 0, 1) },
	  paths: { type: 'array', default: [], setter: function setter(paths) {
	      paths.forEach(function (path) {
	        path.setDirty(true);
	      });
	      this.clearBrushCanvas();
	      this.setDirty(true);
	      return paths;
	    } }
	};
	
	BrushOperation.Path = _path2.default;
	BrushOperation.ControlPoint = _controlPoint2.default;
	
	exports.default = BrushOperation;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _controlPoint = __webpack_require__(77);
	
	var _controlPoint2 = _interopRequireDefault(_controlPoint);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A path that can be drawn on a {@link PhotoEditorSDK.Operations.BrushOperation}. Should only be
	 * created using {@link PhotoEditorSDK.Operations.BrushOperation#createPath}
	 * @class
	 * @extends PhotoEditorSDK.EventEmitter
	 * @memberof PhotoEditorSDK.Operations.BrushOperation
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Path = function (_EventEmitter) {
	  (0, _inherits3.default)(Path, _EventEmitter);
	
	  /**
	   * Creates a Path
	   * @param  {PhotoEditorSDK.Operations.BrushOperation} operation
	   * @param  {Number} thickness
	   * @param  {PhotoEditorSDK.Color} color
	   */
	
	  function Path(operation, thickness, color) {
	    (0, _classCallCheck3.default)(this, Path);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));
	
	    _this._thickness = thickness;
	    _this._color = color;
	    _this._controlPoints = [];
	    return _this;
	  }
	
	  /**
	   * Draws this path onto the given canvas
	   * @param  {HTMLCanvasElement} canvas
	   */
	
	
	  Path.prototype.renderToCanvas = function renderToCanvas(canvas) {
	    if (this._controlPoints.length < 2) {
	      return;
	    }
	
	    var lastControlPoint = this._controlPoints[0];
	    var controlPoint = lastControlPoint;
	    for (var i = 1; i < this._controlPoints.length; i++) {
	      controlPoint = this._controlPoints[i];
	      controlPoint.renderToCanvas(canvas, lastControlPoint);
	      lastControlPoint = controlPoint;
	    }
	  };
	
	  /**
	   * Adds a control point at the given position to this path
	   * @param {PhotoEditorSDK.Math.Vector2} position
	   */
	
	
	  Path.prototype.addControlPoint = function addControlPoint(position) {
	    var controlPoint = new _controlPoint2.default(this, position);
	    this._controlPoints.push(controlPoint);
	    this.emit('update');
	  };
	
	  /**
	   * Returns the path color
	   * @return {PhotoEditorSDK.Color}
	   */
	
	
	  Path.prototype.getColor = function getColor() {
	    return this._color;
	  };
	
	  /**
	   * Returns the path's stroke thickness
	   * @return {Number}
	   */
	
	
	  Path.prototype.getThickness = function getThickness() {
	    return this._thickness;
	  };
	
	  /**
	   * Returns this path's control points
	   * @return {Array.<PhotoEditorSDK.Operations.BrushOperation.ControlPoint>}
	   */
	
	
	  Path.prototype.getControlPoints = function getControlPoints() {
	    return this._controlPoints;
	  };
	
	  /**
	   * Sets this path to dirty
	   */
	
	
	  Path.prototype.setDirty = function setDirty() {
	    this._controlPoints.forEach(function (point) {
	      point.setDirty();
	    });
	  };
	
	  /**
	   * Calls `iterator` for each control point
	   * @param  {Function} iterator
	   */
	
	
	  Path.prototype.forEachControlPoint = function forEachControlPoint(iterator) {
	    this._controlPoints.forEach(iterator);
	  };
	
	  return Path;
	}(_globals.EventEmitter);
	
	exports.default = Path;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can crop out a part of the image
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	
	var CropOperation = function (_Operation) {
	  (0, _inherits3.default)(CropOperation, _Operation);
	
	  /**
	   * Creates a new CropOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function CropOperation() {
	    (0, _classCallCheck3.default)(this, CropOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._sprite.setAnchor(0, 0);
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._sdk.on(_globals.Constants.Events.OPERATION_UPDATED, _this._onOperationUpdate);
	    return _this;
	  }
	
	  // -------------------------------------------------------------------------- EVENTS
	
	  /**
	   * Gets called when an operation is about to be updated. If the crop
	   * or rotation operation is updated, this will be recognized and the
	   * crop will be updated accordingly
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  CropOperation.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    var identifier = operation.constructor.identifier;
	
	
	    if (identifier === 'orientation') {
	      if ('rotation' in options) {
	        this._applyRotation(operation, options);
	      }
	      if ('flipVertically' in options || 'flipHorizontally' in options) {
	        this._applyFlip(operation, options);
	      }
	    }
	  };
	
	  // -------------------------------------------------------------------------- FIXES
	
	  /**
	   * Applies the rotation done by an orientation operation
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  CropOperation.prototype._applyRotation = function _applyRotation(operation, options) {
	    var currentRotation = operation.getRotation();
	    var newRotation = options.rotation;
	    var degreesDifference = newRotation - currentRotation;
	
	    var start = this._options.start.clone();
	    var end = this._options.end.clone();
	
	    var tempStart = start.clone();
	    if (degreesDifference === 90 || degreesDifference === -270) {
	      start.set(1.0 - end.y, tempStart.x);
	      end.set(1.0 - tempStart.y, end.x);
	    } else if (degreesDifference === -90 || degreesDifference === 270) {
	      start.set(tempStart.y, 1.0 - end.x);
	      end.set(end.y, 1.0 - tempStart.x);
	    }
	
	    this.set({ start: start, end: end }, false);
	  };
	
	  /**
	   * Applies the flip done by an orientation operation
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  CropOperation.prototype._applyFlip = function _applyFlip(operation, options) {
	    if ('flipVertically' in options && operation.getFlipVertically() !== options.flipVertically) {
	      this._applyFlipDirection(operation, 'vertical');
	    }
	
	    if ('flipHorizontally' in options && operation.getFlipHorizontally() !== options.flipHorizontally) {
	      this._applyFlipDirection(operation, 'horizontal');
	    }
	  };
	
	  /**
	   * Applies a flip with the given direction
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {String} direction
	   * @private
	   */
	
	
	  CropOperation.prototype._applyFlipDirection = function _applyFlipDirection(operation, direction) {
	    var rotation = operation.getRotation();
	    if (rotation === 90 || rotation === 270) {
	      if (direction === 'vertical') {
	        direction = 'horizontal';
	      } else {
	        direction = 'vertical';
	      }
	    }
	
	    var start = this._options.start;
	    var end = this._options.end;
	
	    switch (direction) {
	      case 'horizontal':
	        var tempStartX = start.x;
	        start.x = 1 - end.x;
	        end.x = 1 - tempStartX;
	        break;
	      case 'vertical':
	        var tempStartY = start.y;
	        start.y = 1 - end.y;
	        end.y = 1 - tempStartY;
	        break;
	    }
	
	    this.set({ start: start, end: end }, false);
	  };
	
	  // -------------------------------------------------------------------------- RENDERING
	
	  /**
	   * Crops the image
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   * @override
	   * @private
	   */
	
	
	  CropOperation.prototype._render = function _render(sdk) {
	    var renderer = sdk.getRenderer();
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var outputBounds = outputSprite.getBounds();
	    var outputDimensions = new _globals.Vector2(outputBounds.width, outputBounds.height);
	
	    var start = this._options.start.clone().multiply(outputDimensions);
	    var end = this._options.end.clone().multiply(outputDimensions);
	
	    var newDimensions = end.clone().subtract(start).floor();
	    renderTexture.resizeTo(newDimensions);
	
	    this._sprite.setPosition(-start.x, -start.y);
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	    this.setDirtyForRenderer(true, renderer);
	
	    return _promise2.default.resolve();
	  };
	
	  /**
	   * Returns the dimensions the given dimensions will have after this operation
	   * has been applied
	   * @param {PhotoEditorSDK.Math.Vector2} dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   * @override
	   */
	
	
	  CropOperation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
	    dimensions = dimensions.clone();
	
	    var newDimensions = this._options.end.clone().subtract(this._options.start);
	
	    newDimensions.multiply(dimensions);
	
	    return newDimensions;
	  };
	
	  return CropOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	CropOperation.identifier = 'crop';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	CropOperation.prototype.availableOptions = {
	  start: { type: 'vector2', required: true, default: new _globals.Vector2(0, 0) },
	  end: { type: 'vector2', required: true, default: new _globals.Vector2(1, 1) }
	};
	
	exports.default = CropOperation;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _identityFilter = __webpack_require__(78);
	
	var _identityFilter2 = _interopRequireDefault(_identityFilter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can apply a selected filter
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	
	var FilterOperation = function (_Operation) {
	  (0, _inherits3.default)(FilterOperation, _Operation);
	
	  function FilterOperation() {
	    (0, _classCallCheck3.default)(this, FilterOperation);
	    return (0, _possibleConstructorReturn3.default)(this, _Operation.apply(this, arguments));
	  }
	
	  /**
	   * Renders this operation
	   * @param {PhotoEditorSDK} sdk
	   * @return {Promise}
	   * @private
	   */
	
	  FilterOperation.prototype._render = function _render(sdk) {
	    return this._selectedFilter.render(sdk, this._getRenderTexture(sdk));
	  };
	
	  /**
	   * Applies this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   * @override
	   */
	
	
	  FilterOperation.prototype.render = function render(sdk) {
	    if (!this.getEnabled() || this._selectedFilter.constructor.isIdentity) {
	      return _globals.Promise.resolve();
	    }
	
	    _Operation.prototype.render.call(this, sdk);
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @override
	   */
	
	
	  FilterOperation.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    _Operation.prototype.setDirtyForRenderer.call(this, dirty, renderer);
	    this._selectedFilter.setDirtyForRenderer(dirty, renderer);
	  };
	
	  return FilterOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	FilterOperation.identifier = 'filter';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	FilterOperation.prototype.availableOptions = {
	  intensity: {
	    type: 'number',
	    default: 1,
	    setter: function setter(intensity) {
	      this._selectedFilter && this._selectedFilter.setIntensity(intensity);
	      return intensity;
	    }
	  },
	  filter: { type: 'object', default: _identityFilter2.default,
	    setter: function setter(Filter) {
	      if (this._selectedFilter) {
	        this._selectedFilter.dispose();
	        this._selectedFilter = null;
	      }
	      this._selectedFilter = new Filter(this._options.intensity);
	      return Filter;
	    }
	  }
	};
	
	exports.default = FilterOperation;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A15 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var A15Filter = function (_Filter) {
	  (0, _inherits3.default)(A15Filter, _Filter);
	
	  function A15Filter() {
	    (0, _classCallCheck3.default)(this, A15Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 0.63
	    }));
	
	    _this._stack.push(new FilterPrimitives.Brightness({
	      brightness: 0.12
	    }));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 38], [94, 94], [148, 142], [175, 187], [255, 255]],
	        green: [[0, 0], [77, 53], [171, 190], [255, 255]],
	        blue: [[0, 10], [48, 85], [174, 228], [255, 255]]
	      }
	    }));
	    return _this;
	  }
	
	  return A15Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	A15Filter.identifier = 'a15';
	
	A15Filter.displayName = '15';
	
	exports.default = A15Filter;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Breeze Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BreezeFilter = function (_Filter) {
	  (0, _inherits3.default)(BreezeFilter, _Filter);
	
	  function BreezeFilter() {
	    (0, _classCallCheck3.default)(this, BreezeFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Desaturation
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Desaturation({
	      desaturation: 0.5
	    }));
	
	    // Tone curve
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [170, 170], [212, 219], [234, 242], [255, 255]],
	        green: [[0, 0], [170, 168], [234, 231], [255, 255]],
	        blue: [[0, 0], [170, 170], [212, 208], [255, 255]]
	      }
	    }));
	    return _this;
	  }
	
	  return BreezeFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	BreezeFilter.identifier = 'breeze';
	
	BreezeFilter.displayName = 'Breeze';
	
	exports.default = BreezeFilter;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * BW Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BWFilter = function (_Filter) {
	  (0, _inherits3.default)(BWFilter, _Filter);
	
	  function BWFilter() {
	    (0, _classCallCheck3.default)(this, BWFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Grayscale());
	    return _this;
	  }
	
	  return BWFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	BWFilter.identifier = 'bw';
	
	BWFilter.displayName = 'B&W';
	
	exports.default = BWFilter;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * BWHard Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BWHardFilter = function (_Filter) {
	  (0, _inherits3.default)(BWHardFilter, _Filter);
	
	  function BWHardFilter() {
	    (0, _classCallCheck3.default)(this, BWHardFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Grayscale());
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 1.5
	    }));
	    return _this;
	  }
	
	  return BWHardFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	BWHardFilter.identifier = 'bwhard';
	
	BWHardFilter.displayName = '1920';
	
	exports.default = BWHardFilter;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Celsius Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var CelsiusFilter = function (_Filter) {
	  (0, _inherits3.default)(CelsiusFilter, _Filter);
	
	  function CelsiusFilter() {
	    (0, _classCallCheck3.default)(this, CelsiusFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 69], [55, 110], [202, 230], [255, 255]],
	        green: [[0, 44], [89, 93], [185, 141], [255, 189]],
	        blue: [[0, 76], [39, 82], [218, 138], [255, 171]]
	      }
	    }));
	    return _this;
	  }
	
	  return CelsiusFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	CelsiusFilter.identifier = 'celsius';
	
	CelsiusFilter.displayName = 'Celsius';
	
	exports.default = CelsiusFilter;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Chest Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var ChestFilter = function (_Filter) {
	  (0, _inherits3.default)(ChestFilter, _Filter);
	
	  function ChestFilter() {
	    (0, _classCallCheck3.default)(this, ChestFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [44, 44], [124, 143], [221, 204], [255, 255]],
	        green: [[0, 0], [130, 127], [213, 199], [255, 255]],
	        blue: [[0, 0], [51, 52], [219, 204], [255, 255]]
	      }
	    }));
	    return _this;
	  }
	
	  return ChestFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	ChestFilter.identifier = 'chest';
	
	ChestFilter.displayName = 'Chest';
	
	exports.default = ChestFilter;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Fixie Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var FixieFilter = function (_Filter) {
	  (0, _inherits3.default)(FixieFilter, _Filter);
	
	  function FixieFilter() {
	    (0, _classCallCheck3.default)(this, FixieFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [44, 28], [63, 48], [128, 132], [235, 248], [255, 255]],
	        green: [[0, 0], [20, 10], [60, 45], [190, 209], [211, 231], [255, 255]],
	        blue: [[0, 31], [41, 62], [150, 142], [234, 212], [255, 224]]
	      }
	    }));
	    return _this;
	  }
	
	  return FixieFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	FixieFilter.identifier = 'fixie';
	
	FixieFilter.displayName = 'Fixie';
	
	exports.default = FixieFilter;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Food Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var FoodFilter = function (_Filter) {
	  (0, _inherits3.default)(FoodFilter, _Filter);
	
	  function FoodFilter() {
	    (0, _classCallCheck3.default)(this, FoodFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 1.35
	    }));
	
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 1.1
	    }));
	    return _this;
	  }
	
	  return FoodFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	FoodFilter.identifier = 'food';
	
	FoodFilter.displayName = 'Food';
	
	exports.default = FoodFilter;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Fridge Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var FridgeFilter = function (_Filter) {
	  (0, _inherits3.default)(FridgeFilter, _Filter);
	
	  function FridgeFilter() {
	    (0, _classCallCheck3.default)(this, FridgeFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 9], [21, 11], [45, 24], [255, 220]],
	        green: [[0, 12], [21, 21], [42, 42], [150, 150], [170, 173], [255, 210]],
	        blue: [[0, 28], [43, 72], [128, 185], [255, 220]]
	      }
	    }));
	    return _this;
	  }
	
	  return FridgeFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	FridgeFilter.identifier = 'fridge';
	
	FridgeFilter.displayName = 'Fridge';
	
	exports.default = FridgeFilter;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Front Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var FrontFilter = function (_Filter) {
	  (0, _inherits3.default)(FrontFilter, _Filter);
	
	  function FrontFilter() {
	    (0, _classCallCheck3.default)(this, FrontFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 65], [28, 67], [67, 113], [125, 183], [187, 217], [255, 229]],
	        green: [[0, 52], [42, 59], [104, 134], [169, 209], [255, 240]],
	        blue: [[0, 52], [65, 68], [93, 104], [150, 153], [255, 198]]
	      }
	    }));
	    return _this;
	  }
	
	  return FrontFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	FrontFilter.identifier = 'front';
	
	FrontFilter.displayName = 'Front';
	
	exports.default = FrontFilter;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Glam Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var GlamFilter = function (_Filter) {
	  (0, _inherits3.default)(GlamFilter, _Filter);
	
	  function GlamFilter() {
	    (0, _classCallCheck3.default)(this, GlamFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 1.1
	    }));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [94, 74], [181, 205], [255, 255]],
	        green: [[0, 0], [127, 127], [255, 255]],
	        blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
	      }
	    }));
	    return _this;
	  }
	
	  return GlamFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	GlamFilter.identifier = 'glam';
	
	GlamFilter.displayName = 'Glam';
	
	exports.default = GlamFilter;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Gobblin Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var GobblinFilter = function (_Filter) {
	  (0, _inherits3.default)(GobblinFilter, _Filter);
	
	  function GobblinFilter() {
	    (0, _classCallCheck3.default)(this, GobblinFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Gobblin());
	    return _this;
	  }
	
	  return GobblinFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	GobblinFilter.identifier = 'gobblin';
	
	GobblinFilter.displayName = 'Gobblin';
	
	exports.default = GobblinFilter;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * K1 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var K1Filter = function (_Filter) {
	  (0, _inherits3.default)(K1Filter, _Filter);
	
	  function K1Filter() {
	    (0, _classCallCheck3.default)(this, K1Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [53, 32], [91, 80], [176, 205], [255, 255]]
	    }));
	
	    // Saturation
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 0.9
	    }));
	    return _this;
	  }
	
	  return K1Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	K1Filter.identifier = 'k1';
	
	K1Filter.displayName = 'K1';
	
	exports.default = K1Filter;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * K2 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	
	var K2Filter = function (_Filter) {
	  (0, _inherits3.default)(K2Filter, _Filter);
	
	  function K2Filter() {
	    (0, _classCallCheck3.default)(this, K2Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [54, 33], [77, 82], [94, 103], [122, 126], [177, 193], [229, 232], [255, 255]]
	    }));
	
	    // Soft color overlay
	    _this._stack.push(new FilterPrimitives.SoftColorOverlay({
	      color: new _color2.default(40 / 255, 40 / 255, 40 / 255)
	    }));
	    return _this;
	  }
	
	  return K2Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	K2Filter.identifier = 'k2';
	
	K2Filter.displayName = 'K2';
	
	exports.default = K2Filter;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * K6 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var K6Filter = function (_Filter) {
	  (0, _inherits3.default)(K6Filter, _Filter);
	
	  function K6Filter() {
	    (0, _classCallCheck3.default)(this, K6Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Saturation
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 0.5
	    }));
	    return _this;
	  }
	
	  return K6Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	K6Filter.identifier = 'k6';
	
	K6Filter.displayName = 'K6';
	
	exports.default = K6Filter;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * KDynamic Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var KDynamicFilter = function (_Filter) {
	  (0, _inherits3.default)(KDynamicFilter, _Filter);
	
	  function KDynamicFilter() {
	    (0, _classCallCheck3.default)(this, KDynamicFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [17, 27], [46, 69], [90, 112], [156, 200], [203, 243], [255, 255]]
	    }));
	
	    // Saturation
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 0.7
	    }));
	    return _this;
	  }
	
	  return KDynamicFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	KDynamicFilter.identifier = 'kdynamic';
	
	KDynamicFilter.displayName = 'KDynamic';
	
	exports.default = KDynamicFilter;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Lenin Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var LeninFilter = function (_Filter) {
	  (0, _inherits3.default)(LeninFilter, _Filter);
	
	  function LeninFilter() {
	    (0, _classCallCheck3.default)(this, LeninFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Desaturation
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Desaturation({
	      desaturation: 0.4
	    }));
	
	    // Tone curve
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 20], [40, 20], [106, 111], [129, 153], [190, 223], [255, 255]],
	        green: [[0, 20], [40, 20], [62, 41], [106, 108], [132, 159], [203, 237], [255, 255]],
	        blue: [[0, 40], [40, 40], [73, 60], [133, 160], [191, 297], [203, 237], [237, 239], [255, 255]]
	      }
	    }));
	    return _this;
	  }
	
	  return LeninFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	LeninFilter.identifier = 'lenin';
	
	LeninFilter.displayName = 'Lenin';
	
	exports.default = LeninFilter;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Lomo Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var LomoFilter = function (_Filter) {
	  (0, _inherits3.default)(LomoFilter, _Filter);
	
	  function LomoFilter() {
	    (0, _classCallCheck3.default)(this, LomoFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [87, 20], [131, 156], [183, 205], [255, 200]]
	    }));
	    return _this;
	  }
	
	  return LomoFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	LomoFilter.identifier = 'lomo';
	
	LomoFilter.displayName = 'Lomo';
	
	exports.default = LomoFilter;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Mellow Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var MellowFilter = function (_Filter) {
	  (0, _inherits3.default)(MellowFilter, _Filter);
	
	  function MellowFilter() {
	    (0, _classCallCheck3.default)(this, MellowFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [41, 84], [87, 134], [255, 255]],
	        green: [[0, 0], [255, 216]],
	        blue: [[0, 0], [255, 131]]
	      }
	    }));
	    return _this;
	  }
	
	  return MellowFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	MellowFilter.identifier = 'mellow';
	
	MellowFilter.displayName = 'Mellow';
	
	exports.default = MellowFilter;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Morning Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var MorningFilter = function (_Filter) {
	  (0, _inherits3.default)(MorningFilter, _Filter);
	
	  function MorningFilter() {
	    (0, _classCallCheck3.default)(this, MorningFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 40], [255, 230]],
	        green: [[0, 10], [255, 225]],
	        blue: [[0, 20], [255, 181]]
	      }
	    }));
	
	    _this._stack.push(new FilterPrimitives.Glow());
	    return _this;
	  }
	
	  return MorningFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	MorningFilter.identifier = 'morning';
	
	MorningFilter.displayName = 'Morning';
	
	exports.default = MorningFilter;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Orchid Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var OrchidFilter = function (_Filter) {
	  (0, _inherits3.default)(OrchidFilter, _Filter);
	
	  function OrchidFilter() {
	    (0, _classCallCheck3.default)(this, OrchidFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Tone curve
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [115, 130], [195, 215], [255, 255]],
	        green: [[0, 0], [148, 153], [172, 215], [255, 255]],
	        blue: [[0, 46], [58, 75], [178, 205], [255, 255]]
	      }
	    }));
	
	    // Tone curve
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [117, 151], [189, 217], [255, 255]]
	    }));
	
	    // Desaturation
	    _this._stack.push(new FilterPrimitives.Desaturation({
	      desaturation: 0.65
	    }));
	    return _this;
	  }
	
	  return OrchidFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	OrchidFilter.identifier = 'orchid';
	
	OrchidFilter.displayName = 'Orchid';
	
	exports.default = OrchidFilter;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Pola Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var PolaFilter = function (_Filter) {
	  (0, _inherits3.default)(PolaFilter, _Filter);
	
	  function PolaFilter() {
	    (0, _classCallCheck3.default)(this, PolaFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [94, 74], [181, 205], [255, 255]],
	        green: [[0, 0], [34, 34], [99, 76], [176, 190], [255, 255]],
	        blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
	      }
	    }));
	
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 0.8
	    }));
	
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 1.5
	    }));
	    return _this;
	  }
	
	  return PolaFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	PolaFilter.identifier = 'pola';
	
	PolaFilter.displayName = 'Pola SX';
	
	exports.default = PolaFilter;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Pola669 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var Pola669Filter = function (_Filter) {
	  (0, _inherits3.default)(Pola669Filter, _Filter);
	
	  function Pola669Filter() {
	    (0, _classCallCheck3.default)(this, Pola669Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [56, 18], [196, 209], [255, 255]],
	        green: [[0, 38], [71, 84], [255, 255]],
	        blue: [[0, 0], [131, 133], [204, 211], [255, 255]]
	      }
	    }));
	
	    _this._stack.push(new FilterPrimitives.Saturation({
	      saturation: 0.8
	    }));
	
	    _this._stack.push(new FilterPrimitives.Contrast({
	      contrast: 1.5
	    }));
	    return _this;
	  }
	
	  return Pola669Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	Pola669Filter.identifier = 'pola669';
	
	Pola669Filter.displayName = 'Pola 669';
	
	exports.default = Pola669Filter;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BlendFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(BlendFilter, _Engine$Filter);
	
	  function BlendFilter() {
	    (0, _classCallCheck3.default)(this, BlendFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(212);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {PhotoEditorSDK.Engine.CanvasRenderer} renderer
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} inputTarget
	   * @param  {PhotoEditorSDK.Engine.RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  BlendFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var outputContext = outputTarget.getContext();
	
	    var filteredCanvas = this._options.filteredCanvas;
	
	
	    outputContext.save();
	    outputContext.drawImage(canvas, 0, 0);
	    outputContext.globalAlpha = this._options.intensity;
	    outputContext.drawImage(filteredCanvas, 0, 0);
	    outputContext.restore();
	  };
	
	  return BlendFilter;
	}(_globals.Engine.Filter);
	
	BlendFilter.prototype.availableOptions = {
	  filteredImage: { type: 'number', default: 1, uniformType: 'i' },
	  filteredCanvas: { type: 'object', default: null },
	  intensity: { type: 'number', default: 1, uniformType: 'f' }
	};
	
	/**
	 * A helper class that can collect {@link Primitive} instances and render
	 * the stack
	 * @class
	 * @memberof PhotoEditorSDK.Filter
	 */
	
	var PrimitivesStack = function () {
	  function PrimitivesStack() {
	    var intensity = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
	    (0, _classCallCheck3.default)(this, PrimitivesStack);
	
	    this._intensity = intensity;
	
	    this._stack = [];
	    this._dirtiness = {};
	    this._renderTextures = {};
	    this._container = new _globals.Engine.Container();
	    this._sprite = new _globals.Engine.Sprite();
	    this._container.addChild(this._sprite);
	
	    this._blendFilter = new BlendFilter();
	  }
	
	  /**
	   * Adds the given primitive to the stack
	   * @param {PhotoEditorSDK.Filter.Primitive} primitive
	   */
	
	
	  PrimitivesStack.prototype.push = function push(primitive) {
	    this._stack.push(primitive);
	  };
	
	  /**
	   * Clears the stack
	   */
	
	
	  PrimitivesStack.prototype.clear = function clear() {
	    this._stack = [];
	  };
	
	  /**
	   * Renders this stack
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {PhotoEditorSDK.Engine.RenderTexture} outputTexture
	   * @return {Promise}
	   * @description This takes the output sprite's current texture and renders
	   *              it to this stack's internal render texture. It then uses the
	   *              internal texture as a uniform for a blend shader and renders
	   *              the sprite with the original texture and the blend shader to
	   *              the outputTexture
	   */
	
	
	  PrimitivesStack.prototype.render = function render(sdk, outputTexture) {
	    if (this._stack.length === 0) {
	      return _promise2.default.resolve();
	    }
	    var renderer = sdk.getRenderer();
	
	    var filteredRenderTexture = this._renderTextures[renderer.id];
	    if (!filteredRenderTexture) {
	      filteredRenderTexture = this._renderTextures[renderer.id] = sdk.createRenderTexture();
	    }
	
	    var outputSprite = sdk.getSprite();
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    // Resize both the output and temp texture
	    var spriteBounds = outputSprite.getBounds();
	    var spriteDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	    outputTexture.resizeTo(spriteDimensions);
	    filteredRenderTexture.resizeTo(spriteDimensions);
	
	    if (this.isDirtyForRenderer(renderer)) {
	      // Update primitives
	      this._stack.forEach(function (p) {
	        return p.update(sdk);
	      });
	
	      // Set filters
	      var filters = this._stack.map(function (p) {
	        return p.getFilter();
	      });
	      this._sprite.setFilters(filters);
	
	      // Render to RenderTexture
	      filteredRenderTexture.render(this._container);
	      this.setDirtyForRenderer(false, renderer);
	    }
	
	    // Use filteredRenderTexture as uniform for blend shader, blend the two
	    // to achieve intensity
	    this._blendFilter.setIntensity(this._intensity);
	    if (renderer.isOfType('canvas')) {
	      this._blendFilter.setFilteredCanvas(filteredRenderTexture.getRenderTarget().getCanvas());
	    }
	    this._sprite.setFilters([this._blendFilter]);
	
	    var baseTexture = filteredRenderTexture.getBaseTexture();
	    baseTexture.setGLUnit(1);
	
	    /* istanbul ignore next */
	    if (renderer.isOfType('webgl')) {
	      renderer.updateTexture(baseTexture, false);
	    }
	
	    outputTexture.render(this._container);
	
	    outputSprite.setTexture(outputTexture);
	    return _promise2.default.resolve();
	  };
	
	  PrimitivesStack.prototype.setIntensity = function setIntensity(intensity) {
	    this._intensity = intensity;
	  };
	
	  /**
	   * Checks if this operation is dirty for the given renderer
	   * @param  {PhotoEditorSDK.Engine.BaseRenderer}  renderer
	   * @return {Boolean}
	   */
	
	
	  PrimitivesStack.prototype.isDirtyForRenderer = function isDirtyForRenderer(renderer) {
	    if (!(renderer.id in this._dirtiness)) {
	      this._dirtiness[renderer.id] = true;
	    }
	    return this._dirtiness[renderer.id];
	  };
	
	  /**
	   * Sets the dirtiness for the given renderer
	   * @param {Boolean} dirty
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   */
	
	
	  PrimitivesStack.prototype.setDirtyForRenderer = function setDirtyForRenderer(dirty, renderer) {
	    this._dirtiness[renderer.id] = dirty;
	  };
	
	  /**
	   * Sets the dirtiness for all renderers
	   * @param {Boolean} dirty
	   */
	
	
	  PrimitivesStack.prototype.setDirty = function setDirty(dirty) {
	    for (var rendererId in this._dirtiness) {
	      this._dirtiness[rendererId] = dirty;
	    }
	  };
	
	  /**
	   * Cleans up this instance
	   */
	
	
	  PrimitivesStack.prototype.dispose = function dispose() {
	    for (var rendererId in this._renderTextures) {
	      this._renderTextures[rendererId].dispose();
	      delete this._renderTextures[rendererId];
	    }
	    this._stack.forEach(function (primitive) {
	      return primitive.dispose();
	    });
	    this._stack = [];
	    this._blendFilter.dispose();
	
	    this._sprite.dispose();
	  };
	
	  return PrimitivesStack;
	}();
	
	exports.default = PrimitivesStack;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var BrightnessFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(BrightnessFilter, _Engine$Filter);
	
	  function BrightnessFilter() {
	    (0, _classCallCheck3.default)(this, BrightnessFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(214);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  BrightnessFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var brightness = this._options.brightness;
	
	
	    if (brightness === 0) {
	      return;
	    }
	    brightness = brightness * 255;
	
	    for (var i = 0; i < canvas.width * canvas.height; i++) {
	      var index = i * 4;
	      imageData.data[index] += brightness;
	      imageData.data[index + 1] += brightness;
	      imageData.data[index + 2] += brightness;
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return BrightnessFilter;
	}(_globals.Engine.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	
	
	BrightnessFilter.prototype.availableOptions = {
	  brightness: { type: 'number', default: 0, uniformType: 'f' }
	};
	
	/**
	 * Brightness primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Brightness = function (_Primitive) {
	  (0, _inherits3.default)(Brightness, _Primitive);
	
	  function Brightness() {
	    (0, _classCallCheck3.default)(this, Brightness);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new BrightnessFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  Brightness.prototype.update = function update() {
	    this._filter.setBrightness(this._options.brightness);
	  };
	
	  return Brightness;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	Brightness.prototype.availableOptions = BrightnessFilter.prototype.availableOptions;
	
	exports.default = Brightness;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var ContrastFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(ContrastFilter, _Engine$Filter);
	
	  function ContrastFilter() {
	    (0, _classCallCheck3.default)(this, ContrastFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(215);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  ContrastFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var contrast = this._options.contrast;
	
	    if (contrast === 1) {
	      return;
	    }
	
	    for (var i = 0; i < canvas.width * canvas.height; i++) {
	      var index = i * 4;
	      imageData.data[index] = (imageData.data[index] - 127) * contrast + 127;
	      imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast + 127;
	      imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast + 127;
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return ContrastFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	
	
	ContrastFilter.prototype.availableOptions = {
	  contrast: { type: 'number', default: 1, uniformType: 'f' }
	};
	
	/**
	 * Contrast primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Contrast = function (_Primitive) {
	  (0, _inherits3.default)(Contrast, _Primitive);
	
	  function Contrast() {
	    (0, _classCallCheck3.default)(this, Contrast);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new ContrastFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  Contrast.prototype.update = function update() {
	    this._filter.setContrast(this._options.contrast);
	  };
	
	  return Contrast;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	Contrast.prototype.availableOptions = ContrastFilter.prototype.availableOptions;
	
	exports.default = Contrast;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var DesaturationFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(DesaturationFilter, _Engine$Filter);
	
	  function DesaturationFilter() {
	    (0, _classCallCheck3.default)(this, DesaturationFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(216);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  DesaturationFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var desaturation = this._options.desaturation;
	
	
	    for (var i = 0; i < canvas.width * canvas.height; i++) {
	      var index = i * 4;
	      var luminance = imageData.data[index] * 0.3 + imageData.data[index + 1] * 0.59 + imageData.data[index + 2] * 0.11;
	      imageData.data[index] = luminance * (1 - desaturation) + imageData.data[index] * desaturation;
	      imageData.data[index + 1] = luminance * (1 - desaturation) + imageData.data[index + 1] * desaturation;
	      imageData.data[index + 2] = luminance * (1 - desaturation) + imageData.data[index + 2] * desaturation;
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return DesaturationFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	
	
	DesaturationFilter.prototype.availableOptions = {
	  desaturation: { type: 'number', default: 1, uniformType: 'f' }
	};
	
	/**
	 * Desaturation primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Desaturation = function (_Primitive) {
	  (0, _inherits3.default)(Desaturation, _Primitive);
	
	  function Desaturation() {
	    (0, _classCallCheck3.default)(this, Desaturation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new DesaturationFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  Desaturation.prototype.update = function update() {
	    this._filter.setDesaturation(this._options.desaturation);
	  };
	
	  return Desaturation;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	Desaturation.prototype.availableOptions = DesaturationFilter.prototype.availableOptions;
	
	exports.default = Desaturation;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var GlowFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(GlowFilter, _Engine$Filter);
	
	  function GlowFilter() {
	    (0, _classCallCheck3.default)(this, GlowFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(217);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  GlowFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    var color = this._options.color;
	
	
	    var d;
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        var x01 = x / canvas.width;
	        var y01 = y / canvas.height;
	
	        var nx = (x01 - 0.5) / 0.75;
	        var ny = (y01 - 0.5) / 0.75;
	
	        var scalarX = nx * nx;
	        var scalarY = ny * ny;
	        d = 1 - (scalarX + scalarY);
	        d = Math.min(Math.max(d, 0.1), 1.0);
	
	        imageData.data[index] = imageData.data[index] * (d * color.r);
	        imageData.data[index + 1] = imageData.data[index + 1] * (d * color.g);
	        imageData.data[index + 2] = imageData.data[index + 2] * (d * color.b);
	        imageData.data[index + 3] = 255;
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return GlowFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	GlowFilter.prototype.availableOptions = {
	  color: { type: 'color', default: _color2.default.WHITE, uniformType: '3f' }
	};
	
	/**
	 * Glow primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Glow = function (_Primitive) {
	  (0, _inherits3.default)(Glow, _Primitive);
	
	  function Glow() {
	    (0, _classCallCheck3.default)(this, Glow);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new GlowFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  Glow.prototype.update = function update() {
	    this._filter.setColor(this._options.color);
	  };
	
	  return Glow;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	Glow.prototype.availableOptions = GlowFilter.prototype.availableOptions;
	
	exports.default = Glow;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var GobblinFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(GobblinFilter, _Engine$Filter);
	
	  function GobblinFilter() {
	    (0, _classCallCheck3.default)(this, GobblinFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(218);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  GobblinFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
	        imageData.data[index] = imageData.data[index] * 0.6;
	        imageData.data[index + 2] += imageData.data[index] * 0.33;
	        imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
	        imageData.data[index + 3] = 255;
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return GobblinFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Gobblin primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	
	var Gobblin = function (_Primitive) {
	  (0, _inherits3.default)(Gobblin, _Primitive);
	
	  function Gobblin() {
	    (0, _classCallCheck3.default)(this, Gobblin);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new GobblinFilter();
	    return _this2;
	  }
	
	  return Gobblin;
	}(_primitive2.default);
	
	exports.default = Gobblin;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var GrayscaleFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(GrayscaleFilter, _Engine$Filter);
	
	  function GrayscaleFilter() {
	    (0, _classCallCheck3.default)(this, GrayscaleFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(219);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  GrayscaleFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
	
	        imageData.data[index] = luminance;
	        imageData.data[index + 1] = luminance;
	        imageData.data[index + 2] = luminance;
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return GrayscaleFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Grayscale primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	
	var Grayscale = function (_Primitive) {
	  (0, _inherits3.default)(Grayscale, _Primitive);
	
	  function Grayscale() {
	    (0, _classCallCheck3.default)(this, Grayscale);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new GrayscaleFilter();
	    return _this2;
	  }
	
	  return Grayscale;
	}(_primitive2.default);
	
	exports.default = Grayscale;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var SaturationFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(SaturationFilter, _Engine$Filter);
	
	  function SaturationFilter() {
	    (0, _classCallCheck3.default)(this, SaturationFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(221);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  SaturationFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	    var saturation = this._options.saturation;
	
	
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
	        imageData.data[index] = luminance * (1 - saturation) + imageData.data[index] * saturation;
	        imageData.data[index + 1] = luminance * (1 - saturation) + imageData.data[index + 1] * saturation;
	        imageData.data[index + 2] = luminance * (1 - saturation) + imageData.data[index + 2] * saturation;
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return SaturationFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	
	
	SaturationFilter.prototype.availableOptions = {
	  saturation: { type: 'number', default: 0, uniformType: 'f' }
	};
	
	/**
	 * Saturation primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var Saturation = function (_Primitive) {
	  (0, _inherits3.default)(Saturation, _Primitive);
	
	  function Saturation() {
	    (0, _classCallCheck3.default)(this, Saturation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new SaturationFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  Saturation.prototype.update = function update() {
	    this._filter.setSaturation(this._options.saturation);
	  };
	
	  return Saturation;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	Saturation.prototype.availableOptions = SaturationFilter.prototype.availableOptions;
	
	exports.default = Saturation;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	var _color = __webpack_require__(12);
	
	var _color2 = _interopRequireDefault(_color);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SoftColorOverlayFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(SoftColorOverlayFilter, _Engine$Filter);
	
	  function SoftColorOverlayFilter() {
	    (0, _classCallCheck3.default)(this, SoftColorOverlayFilter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(222);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  SoftColorOverlayFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        imageData.data[index] = Math.max(this._options.color.r * 255, imageData.data[index]);
	        imageData.data[index + 1] = Math.max(this._options.color.g * 255, imageData.data[index + 1]);
	        imageData.data[index + 2] = Math.max(this._options.color.b * 255, imageData.data[index + 2]);
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return SoftColorOverlayFilter;
	}(_engine2.default.Filter);
	
	/**
	 * Specifies the available options for this filter
	 * @type {Object}
	 * @ignore
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	SoftColorOverlayFilter.prototype.availableOptions = {
	  color: { type: 'color', default: _color2.default.WHITE, uniformType: '3f' }
	};
	
	/**
	 * SoftColorOverlay primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var SoftColorOverlay = function (_Primitive) {
	  (0, _inherits3.default)(SoftColorOverlay, _Primitive);
	
	  function SoftColorOverlay() {
	    (0, _classCallCheck3.default)(this, SoftColorOverlay);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new SoftColorOverlayFilter();
	    return _this2;
	  }
	
	  /**
	   * Updates the filter's uniforms
	   */
	
	
	  SoftColorOverlay.prototype.update = function update() {
	    this._filter.setColor(this._options.color);
	  };
	
	  return SoftColorOverlay;
	}(_primitive2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	
	
	SoftColorOverlay.prototype.availableOptions = SoftColorOverlayFilter.prototype.availableOptions;
	
	exports.default = SoftColorOverlay;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _lookupTable = __webpack_require__(79);
	
	var _lookupTable2 = _interopRequireDefault(_lookupTable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Tone curve primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitives.LookupTable
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	var ToneCurve = function (_LookupTable) {
	  (0, _inherits3.default)(ToneCurve, _LookupTable);
	
	  function ToneCurve() {
	    (0, _classCallCheck3.default)(this, ToneCurve);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _LookupTable.call.apply(_LookupTable, [this].concat(args)));
	
	    if (!_this._options.rgbControlPoints) {
	      _this._options.rgbControlPoints = {
	        red: _this._options.controlPoints,
	        green: _this._options.controlPoints,
	        blue: _this._options.controlPoints
	      };
	    }
	
	    _this._updateLookupTable();
	    return _this;
	  }
	
	  /**
	   * Calculates the lookup table
	   * @private
	   */
	
	
	  ToneCurve.prototype._updateLookupTable = function _updateLookupTable() {
	    var r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
	    var g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
	    var b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);
	
	    this._options.data = this._buildLookupTable(r, g, b);
	  };
	
	  /**
	   * Builds the lookup table
	   * @param  {Array} r
	   * @param  {Array} g
	   * @param  {Array} b
	   * @return {Array}
	   * @private
	   */
	
	
	  ToneCurve.prototype._buildLookupTable = function _buildLookupTable(r, g, b) {
	    var data = [];
	
	    for (var i = 0; i < 256; i++) {
	      data.push(Math.min(Math.max(i + r[i], 0), 255));
	      data.push(Math.min(Math.max(i + g[i], 0), 255));
	      data.push(Math.min(Math.max(i + b[i], 0), 255));
	      data.push(255);
	    }
	
	    return data;
	  };
	
	  /**
	   * Calculates the spline curve data for the given points
	   * @param  {Array.<Array.<Number>>} points
	   * @return {Array.<Number>}
	   */
	
	
	  ToneCurve.prototype._calculateSplineCurve = function _calculateSplineCurve(points) {
	    points = points.sort(function (a, b) {
	      return a[0] > b[0];
	    });
	
	    var splinePoints = this._getSplineCurve(points);
	    var firstSplinePoint = splinePoints[0];
	    var i;
	
	    if (firstSplinePoint[0] > 0) {
	      for (i = 0; i < firstSplinePoint[0]; i++) {
	        splinePoints.unshift([0, 0]);
	      }
	    }
	
	    var preparedPoints = [];
	    for (i = 0; i < splinePoints.length; i++) {
	      var newPoint = splinePoints[i];
	      var origPoint = [newPoint[0], newPoint[0]];
	
	      var distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));
	
	      if (origPoint[1] > newPoint[1]) {
	        distance = -distance;
	      }
	
	      preparedPoints.push(distance);
	    }
	
	    return preparedPoints;
	  };
	
	  ToneCurve.prototype._getSplineCurve = function _getSplineCurve(points) {
	    var sdA = this._secondDerivative(points);
	
	    var n = sdA.length;
	    var sd = [];
	    var i;
	
	    for (i = 0; i < n; i++) {
	      sd[i] = sdA[i];
	    }
	
	    var output = [];
	
	    for (i = 0; i < n - 1; i++) {
	      var cur = points[i];
	      var next = points[i + 1];
	
	      for (var x = cur[0]; x < next[0]; x++) {
	        var t = (x - cur[0]) / (next[0] - cur[0]);
	
	        var a = 1 - t;
	        var b = t;
	        var h = next[0] - cur[0];
	
	        var y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
	
	        if (y > 255) {
	          y = 255;
	        } else if (y < 0) {
	          y = 0;
	        }
	
	        output.push([x, y]);
	      }
	    }
	
	    if (output.length === 255) {
	      output.push(points[points.length - 1]);
	    }
	
	    return output;
	  };
	
	  ToneCurve.prototype._secondDerivative = function _secondDerivative(points) {
	    var n = points.length;
	    if (n <= 0 || n === 1) {
	      return null;
	    }
	
	    var matrix = [];
	    var result = [];
	    var i, k;
	
	    matrix[0] = [0, 1, 0];
	
	    for (i = 1; i < n - 1; i++) {
	      var P1 = points[i - 1];
	      var P2 = points[i];
	      var P3 = points[i + 1];
	
	      matrix[i] = matrix[i] || [];
	      matrix[i][0] = (P2[0] - P1[0]) / 6;
	      matrix[i][1] = (P3[0] - P1[0]) / 3;
	      matrix[i][2] = (P3[0] - P2[0]) / 6;
	      result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
	    }
	
	    result[0] = 0;
	    result[n - 1] = 0;
	
	    matrix[n - 1] = [0, 1, 0];
	
	    // Pass 1
	    for (i = 1; i < n; i++) {
	      k = matrix[1][0] / matrix[i - 1][1];
	      matrix[i][1] -= k * matrix[i - 1][2];
	      matrix[i][0] = 0;
	      result[i] -= k * result[i - 1];
	    }
	
	    // Pass 2
	    for (i = n - 2; i > 0; i--) {
	      k = matrix[i][2] / matrix[i + 1][1];
	      matrix[i][1] -= k * matrix[i + 1][0];
	      matrix[i][2] = 0;
	      result[i] -= k * result[i + 1];
	    }
	
	    var y2 = [];
	    for (i = 0; i < n; i++) {
	      y2[i] = result[i] / matrix[i][1];
	    }
	
	    return y2;
	  };
	
	  return ToneCurve;
	}(_lookupTable2.default);
	
	/**
	 * Specifies the available options for this primitive
	 * @type {Object}
	 * @ignore
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	ToneCurve.prototype.availableOptions = {
	  rgbControlPoints: { type: 'object' },
	  controlPoints: { type: 'array', default: [] }
	};
	
	exports.default = ToneCurve;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _engine = __webpack_require__(7);
	
	var _engine2 = _interopRequireDefault(_engine);
	
	var _primitive = __webpack_require__(10);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var X400Filter = function (_Engine$Filter) {
	  (0, _inherits3.default)(X400Filter, _Engine$Filter);
	
	  function X400Filter() {
	    (0, _classCallCheck3.default)(this, X400Filter);
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call(this));
	
	    _this._fragmentSource = __webpack_require__(223);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  X400Filter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var canvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var outputContext = outputTarget.getContext();
	
	    var imageData = inputContext.getImageData(0, 0, canvas.width, canvas.height);
	
	    for (var x = 0; x < canvas.width; x++) {
	      for (var y = 0; y < canvas.height; y++) {
	        var index = (canvas.width * y + x) * 4;
	
	        var gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
	        gray -= 0.2;
	        gray = Math.max(0.0, Math.min(1.0, gray));
	        gray += 0.15;
	        gray *= 1.4;
	
	        gray *= 255;
	        imageData.data[index] = gray;
	        imageData.data[index + 1] = gray;
	        imageData.data[index + 2] = gray;
	      }
	    }
	
	    outputContext.putImageData(imageData, 0, 0);
	  };
	
	  return X400Filter;
	}(_engine2.default.Filter);
	
	/**
	 * X400 primitive
	 * @class
	 * @extends PhotoEditorSDK.Filters.Primitive
	 * @memberof PhotoEditorSDK.FilterPrimitives
	 */
	
	
	var X400 = function (_Primitive) {
	  (0, _inherits3.default)(X400, _Primitive);
	
	  function X400() {
	    (0, _classCallCheck3.default)(this, X400);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this2 = (0, _possibleConstructorReturn3.default)(this, _Primitive.call.apply(_Primitive, [this].concat(args)));
	
	    _this2._filter = new X400Filter();
	    return _this2;
	  }
	
	  return X400;
	}(_primitive2.default);
	
	exports.default = X400;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Quozi Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var QuoziFilter = function (_Filter) {
	  (0, _inherits3.default)(QuoziFilter, _Filter);
	
	  function QuoziFilter() {
	    (0, _classCallCheck3.default)(this, QuoziFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    // Desaturation
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.Desaturation({
	      desaturation: 0.65
	    }));
	
	    // Tone curve
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 50], [40, 78], [118, 170], [181, 211], [255, 255]],
	        green: [[0, 27], [28, 45], [109, 157], [157, 195], [179, 208], [206, 212], [255, 240]],
	        blue: [[0, 50], [12, 55], [46, 103], [103, 162], [194, 182], [241, 201], [255, 219]]
	      }
	    }));
	    return _this;
	  }
	
	  return QuoziFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	QuoziFilter.identifier = 'quozi';
	
	QuoziFilter.displayName = 'Quozi';
	
	exports.default = QuoziFilter;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Semired Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var SemiredFilter = function (_Filter) {
	  (0, _inherits3.default)(SemiredFilter, _Filter);
	
	  function SemiredFilter() {
	    (0, _classCallCheck3.default)(this, SemiredFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 129], [75, 153], [181, 227], [255, 255]],
	        green: [[0, 8], [111, 85], [212, 158], [255, 226]],
	        blue: [[0, 5], [75, 22], [193, 90], [255, 229]]
	      }
	    }));
	
	    _this._stack.push(new FilterPrimitives.Glow());
	    return _this;
	  }
	
	  return SemiredFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	SemiredFilter.identifier = 'semired';
	
	SemiredFilter.displayName = 'Semired';
	
	exports.default = SemiredFilter;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Sunny Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var SunnyFilter = function (_Filter) {
	  (0, _inherits3.default)(SunnyFilter, _Filter);
	
	  function SunnyFilter() {
	    (0, _classCallCheck3.default)(this, SunnyFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 0], [62, 82], [141, 154], [255, 255]],
	        green: [[0, 39], [56, 96], [192, 176], [255, 255]],
	        blue: [[0, 0], [174, 99], [255, 235]]
	      }
	    }));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      controlPoints: [[0, 0], [55, 20], [158, 191], [255, 255]]
	    }));
	    return _this;
	  }
	
	  return SunnyFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	SunnyFilter.identifier = 'sunny';
	
	SunnyFilter.displayName = 'Sunny';
	
	exports.default = SunnyFilter;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Texas Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var TexasFilter = function (_Filter) {
	  (0, _inherits3.default)(TexasFilter, _Filter);
	
	  function TexasFilter() {
	    (0, _classCallCheck3.default)(this, TexasFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.ToneCurve({
	      rgbControlPoints: {
	        red: [[0, 72], [89, 99], [176, 212], [255, 237]],
	        green: [[0, 49], [255, 192]],
	        blue: [[0, 72], [255, 151]]
	      }
	    }));
	    return _this;
	  }
	
	  return TexasFilter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	TexasFilter.identifier = 'texas';
	
	TexasFilter.displayName = 'Texas';
	
	exports.default = TexasFilter;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _filter = __webpack_require__(3);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _primitives = __webpack_require__(4);
	
	var FilterPrimitives = _interopRequireWildcard(_primitives);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * X400 Filter
	 * @class
	 * @extends PhotoEditorSDK.Filter
	 * @memberof PhotoEditorSDK.Filters
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var X400Filter = function (_Filter) {
	  (0, _inherits3.default)(X400Filter, _Filter);
	
	  function X400Filter() {
	    (0, _classCallCheck3.default)(this, X400Filter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Filter.call.apply(_Filter, [this].concat(args)));
	
	    _this._stack.push(new FilterPrimitives.X400());
	    return _this;
	  }
	
	  return X400Filter;
	}(_filter2.default);
	
	/**
	 * This filter's identifier
	 * @type {String}
	 * @default
	 */
	
	
	X400Filter.identifier = 'x400';
	
	X400Filter.displayName = 'X400';
	
	exports.default = X400Filter;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _stackBlur = __webpack_require__(80);
	
	var _stackBlur2 = _interopRequireDefault(_stackBlur);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var LinearFocusFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(LinearFocusFilter, _Engine$Filter);
	
	  function LinearFocusFilter() {
	    (0, _classCallCheck3.default)(this, LinearFocusFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call.apply(_Engine$Filter, [this].concat(args)));
	
	    _this._fragmentSource = __webpack_require__(209);
	
	    _this._lastBlurRadius = null;
	    _this._lastGradientRadius = null;
	    _this._lastStart = new _globals.Vector2();
	    _this._lastEnd = new _globals.Vector2();
	
	    _this._blurredRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
	
	    _this._maskRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  LinearFocusFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var inputDimensions = inputTarget.getDimensions();
	    var dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
	
	    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
	    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
	
	    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
	    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
	
	    if (!this._outputRenderTexture) {
	      this._outputRenderTexture = new _globals.Engine.RenderTexture(renderer, inputTarget.getWidth(), inputTarget.getHeight(), inputTarget.getPixelRatio());
	    }
	
	    if (!this._lastStart.equals(this._options.start) || !this._lastEnd.equals(this._options.end) || this._lastGradientRadius !== this._options.size || dimensionsChanged) {
	      this._renderMask();
	
	      this._lastStart = this._options.start.clone();
	      this._lastEnd = this._options.end.clone();
	      this._lastGradientRadius = this._options.size;
	    }
	
	    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
	      this._blurImage(inputTarget);
	      this._lastBlurRadius = this._options.blurRadius;
	    }
	
	    this._applyMask(inputTarget, outputTarget);
	  };
	
	  /**
	   * Creates a blurred copy of the image
	   * @param  {CanvasRenderTarget} inputTarget
	   * @return {Canvas}
	   * @private
	   */
	
	
	  LinearFocusFilter.prototype._blurImage = function _blurImage(inputTarget) {
	    var inputCanvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	
	    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, this._options.blurRadius);
	
	    var blurryContext = this._blurredRenderTarget.getContext();
	    blurryContext.putImageData(blurryImageData, 0, 0);
	  };
	
	  /**
	   * Renders the mask canvas
	   * @private
	   */
	
	
	  LinearFocusFilter.prototype._renderMask = function _renderMask() {
	    var canvas = this._maskRenderTarget.getCanvas();
	    var context = this._maskRenderTarget.getContext();
	    var pixelRatio = this._maskRenderTarget.getPixelRatio();
	
	    var canvasDimensions = new _globals.Vector2(canvas.width, canvas.height);
	
	    var size = this._options.size * pixelRatio;
	    var gradientSize = this._options.gradientSize * pixelRatio;
	    var start = this._options.start.clone();
	    var end = this._options.end.clone();
	
	    start.multiply(canvasDimensions);
	    end.multiply(canvasDimensions);
	
	    var dist = end.clone().subtract(start);
	    var middle = start.clone().add(dist.clone().divide(2));
	
	    var totalDist = dist.len();
	    var factor = dist.clone().divide(totalDist);
	
	    var gradientStart = middle.clone().add((size + gradientSize) * factor.y, -(size + gradientSize) * factor.x);
	    var gradientEnd = middle.clone().add(-(size + gradientSize) * factor.y, (size + gradientSize) * factor.x);
	
	    // Build gradient
	    var gradient = context.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
	    var fullGradientSize = gradientEnd.clone().subtract(gradientStart).len();
	    gradient.addColorStop(0, '#000000');
	    gradient.addColorStop(gradientSize / 2 / fullGradientSize, '#FFFFFF');
	    gradient.addColorStop(1.0 - gradientSize / 2 / fullGradientSize, '#FFFFFF');
	    gradient.addColorStop(1, '#000000');
	
	    // Draw gradient
	    context.fillStyle = gradient;
	    context.fillRect(0, 0, canvas.width, canvas.height);
	  };
	
	  /**
	   * Applies the blur and mask to the input canvas
	   * @param {CanvasRenderTarget} inputTarget
	   * @param {CanvasRenderTarget} outputTarget
	   * @private
	   */
	
	
	  LinearFocusFilter.prototype._applyMask = function _applyMask(inputTarget, outputTarget) {
	    var outputContext = outputTarget.getContext();
	    var inputCanvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var blurredContext = this._blurredRenderTarget.getContext();
	    var maskContext = this._maskRenderTarget.getContext();
	
	    var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	    var pixels = inputImageData.data;
	    var blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	    var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	
	    var alpha = void 0;
	    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
	      alpha = maskPixels[i] / 255;
	
	      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
	      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
	      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
	    }
	
	    outputContext.putImageData(inputImageData, 0, 0);
	  };
	
	  return LinearFocusFilter;
	}(_globals.Engine.Filter);
	
	LinearFocusFilter.prototype.availableOptions = {
	  blurRadius: { type: 'number', default: 30, uniformType: 'f' },
	  size: { type: 'number', default: 50, uniformType: 'f' },
	  gradientSize: { type: 'number', default: 50, uniformType: 'f' },
	  start: { type: 'vector2', default: new _globals.Vector2(0, 0.5), uniformType: '2f' },
	  end: { type: 'vector2', default: new _globals.Vector2(1, 0.5), uniformType: '2f' },
	  delta: { type: 'vector2', default: new _globals.Vector2(1, 1), uniformType: '2f' },
	  texSize: { type: 'vector2', default: new _globals.Vector2(100, 100), uniformType: '2f' }
	};
	
	exports.default = LinearFocusFilter;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _stackBlur = __webpack_require__(80);
	
	var _stackBlur2 = _interopRequireDefault(_stackBlur);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var RadialFocusFilter = function (_Engine$Filter) {
	  (0, _inherits3.default)(RadialFocusFilter, _Engine$Filter);
	
	  function RadialFocusFilter() {
	    (0, _classCallCheck3.default)(this, RadialFocusFilter);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Engine$Filter.call.apply(_Engine$Filter, [this].concat(args)));
	
	    _this._fragmentSource = __webpack_require__(210);
	
	    _this._lastBlurRadius = null;
	    _this._lastGradientRadius = null;
	    _this._lastPosition = new _globals.Vector2();
	
	    _this._blurredRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
	
	    _this._maskRenderTarget = new _globals.Engine.CanvasRenderTarget(100, 100, 1);
	    return _this;
	  }
	
	  /**
	   * Applies this filter to the given inputTarget and renders it to
	   * the given outputTarget using the CanvasRenderer
	   * @param  {CanvasRenderer} renderer
	   * @param  {RenderTarget} inputTarget
	   * @param  {RenderTarget} outputTarget
	   * @param  {Boolean} clear = false
	   * @private
	   */
	
	
	  RadialFocusFilter.prototype._applyCanvas = function _applyCanvas(renderer, inputTarget, outputTarget) {
	    var clear = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];
	
	    var inputDimensions = inputTarget.getDimensions();
	    var dimensionsChanged = !this._blurredRenderTarget.getDimensions().equals(inputDimensions);
	
	    this._blurredRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
	    this._blurredRenderTarget.resizeTo(inputTarget.getDimensions());
	
	    this._maskRenderTarget.setPixelRatio(inputTarget.getPixelRatio());
	    this._maskRenderTarget.resizeTo(inputTarget.getDimensions());
	
	    if (!this._outputRenderTexture) {
	      this._outputRenderTexture = new _globals.Engine.RenderTexture(renderer, inputTarget.getWidth(), inputTarget.getHeight(), inputTarget.getPixelRatio());
	    }
	
	    if (!this._lastPosition.equals(this._options.position) || this._lastGradientRadius !== this._options.gradientRadius || dimensionsChanged) {
	      this._renderMask();
	
	      this._lastPosition = this._options.position.clone();
	      this._lastGradientRadius = this._options.gradientRadius;
	    }
	
	    if (this._lastBlurRadius !== this._options.blurRadius || dimensionsChanged) {
	      this._blurImage(inputTarget);
	      this._lastBlurRadius = this._options.blurRadius;
	    }
	
	    this._applyMask(inputTarget, outputTarget);
	  };
	
	  /**
	   * Creates a blurred copy of the image
	   * @param  {CanvasRenderTarget} inputTarget
	   * @return {Canvas}
	   * @private
	   */
	
	
	  RadialFocusFilter.prototype._blurImage = function _blurImage(inputTarget) {
	    var inputCanvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	
	    var blurryImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	    _stackBlur2.default.stackBlurCanvasRGBA(blurryImageData, 0, 0, inputCanvas.width, inputCanvas.height, this._options.blurRadius);
	
	    var blurryContext = this._blurredRenderTarget.getContext();
	    blurryContext.putImageData(blurryImageData, 0, 0);
	  };
	
	  /**
	   * Renders the mask canvas
	   * @private
	   */
	
	
	  RadialFocusFilter.prototype._renderMask = function _renderMask() {
	    var canvas = this._maskRenderTarget.getCanvas();
	    var context = this._maskRenderTarget.getContext();
	
	    var canvasDimensions = new _globals.Vector2(canvas.width, canvas.height);
	    var pixelRatio = this._maskRenderTarget.getPixelRatio();
	
	    var _options = this._options;
	    var radius = _options.radius;
	    var gradientRadius = _options.gradientRadius;
	
	    var position = this._options.position.clone().multiply(this._options.texSize).multiply(pixelRatio);
	
	    // Build gradient
	    var gradient = context.createRadialGradient(position.x, position.y, 0, position.x, position.y, (radius + gradientRadius) * pixelRatio);
	    gradient.addColorStop(0, '#FFFFFF');
	    gradient.addColorStop(radius / (radius + gradientRadius), '#FFFFFF');
	    gradient.addColorStop(1, '#000000');
	
	    // Draw gradient
	    context.fillStyle = gradient;
	    context.fillRect(0, 0, canvasDimensions.x, canvasDimensions.y);
	  };
	
	  /**
	   * Applies the blur and mask to the input canvas
	   * @param {CanvasRenderTarget} inputTarget
	   * @param {CanvasRenderTarget} outputTarget
	   * @private
	   */
	
	
	  RadialFocusFilter.prototype._applyMask = function _applyMask(inputTarget, outputTarget) {
	    var outputContext = outputTarget.getContext();
	    var inputCanvas = inputTarget.getCanvas();
	    var inputContext = inputTarget.getContext();
	    var blurredContext = this._blurredRenderTarget.getContext();
	    var maskContext = this._maskRenderTarget.getContext();
	
	    var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	    var pixels = inputImageData.data;
	    var blurredPixels = blurredContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	    var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	
	    var alpha = void 0;
	    for (var i = 0; i < inputCanvas.width * inputCanvas.height * 4; i += 4) {
	      alpha = maskPixels[i] / 255;
	
	      pixels[i] = alpha * pixels[i] + (1 - alpha) * blurredPixels[i];
	      pixels[i + 1] = alpha * pixels[i + 1] + (1 - alpha) * blurredPixels[i + 1];
	      pixels[i + 2] = alpha * pixels[i + 2] + (1 - alpha) * blurredPixels[i + 2];
	    }
	
	    outputContext.putImageData(inputImageData, 0, 0);
	  };
	
	  return RadialFocusFilter;
	}(_globals.Engine.Filter);
	
	RadialFocusFilter.prototype.availableOptions = {
	  blurRadius: { type: 'number', default: 30, uniformType: 'f' },
	  radius: { type: 'number', default: 50, uniformType: 'f' },
	  gradientRadius: { type: 'number', default: 25, uniformType: 'f' },
	  position: { type: 'vector2', default: new _globals.Vector2(0.5, 0.5), uniformType: '2f' },
	  delta: { type: 'vector2', default: new _globals.Vector2(1, 1), uniformType: '2f' },
	  texSize: { type: 'vector2', default: new _globals.Vector2(100, 100), uniformType: '2f' }
	};
	
	exports.default = RadialFocusFilter;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _linearFocusFilter = __webpack_require__(156);
	
	var _linearFocusFilter2 = _interopRequireDefault(_linearFocusFilter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can draw a linear focus
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var LinearFocusOperation = function (_Operation) {
	  (0, _inherits3.default)(LinearFocusOperation, _Operation);
	
	  /**
	   * Creates a new LinearFocusOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function LinearFocusOperation() {
	    (0, _classCallCheck3.default)(this, LinearFocusOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._lastBlurRadius = _this._options.blurRadius;
	    _this._lastSize = _this._options.size;
	    _this._lastGradientSize = _this._options.gradientSize;
	
	    _this._horizontalFilter = new _linearFocusFilter2.default();
	    _this._verticalFilter = new _linearFocusFilter2.default();
	    _this._sprite.setFilters([_this._horizontalFilter, _this._verticalFilter]);
	
	    _this._horizontalFilter.setDelta(new _globals.Vector2(1, 1));
	    _this._verticalFilter.setDelta(new _globals.Vector2(-1, 1));
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._sdk.on(_globals.Constants.Events.OPERATION_UPDATED, _this._onOperationUpdate);
	
	    _this._filter = new _linearFocusFilter2.default();
	    return _this;
	  }
	
	  /**
	   * Gets called when an operation is about to be updated. If the crop
	   * or rotation operation is updated, this will be recognized and the
	   * blur will be updated accordingly
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  LinearFocusOperation.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    var identifier = operation.constructor.identifier;
	
	
	    if (identifier === 'orientation' && 'rotation' in options) {
	      this._applyRotation(operation, options);
	    }
	
	    if (identifier === 'orientation' && ('flipHorizontally' in options || 'flipVertically' in options)) {
	      this._applyFlip(operation, options);
	    }
	  };
	
	  /**
	   * Applies the given rotation change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  LinearFocusOperation.prototype._applyRotation = function _applyRotation(operation, options) {
	    var oldRotation = operation.getRotation();
	    var newRotation = options.rotation;
	    var degreesDifference = newRotation - oldRotation;
	
	    var start = this._options.start;
	    var end = this._options.end;
	
	    if (degreesDifference === 90 || oldRotation === 270 && newRotation === 0) {
	      start.flip();
	      start.x = 1 - start.x;
	      end.flip();
	      end.x = 1 - end.x;
	    } else if (degreesDifference === -90 || oldRotation === -270 && newRotation === 0) {
	      start.flip();
	      start.y = 1 - start.y;
	      end.flip();
	      end.y = 1 - end.y;
	    }
	
	    this.set({ start: start, end: end });
	  };
	
	  /**
	   * Applies the given flip change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  LinearFocusOperation.prototype._applyFlip = function _applyFlip(operation, options) {
	    if ('flipVertically' in options && operation.getFlipVertically() !== options.flipVertically) {
	      this._applyFlipDirection(operation, 'vertical');
	    }
	
	    if ('flipHorizontally' in options && operation.getFlipHorizontally() !== options.flipHorizontally) {
	      this._applyFlipDirection(operation, 'horizontal');
	    }
	  };
	
	  /**
	   * Applies a flip with the given direction
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {String} direction
	   * @private
	   */
	
	
	  LinearFocusOperation.prototype._applyFlipDirection = function _applyFlipDirection(operation, direction) {
	    var rotation = operation.getRotation();
	    if (rotation === 90 || rotation === 270) {
	      if (direction === 'vertical') {
	        direction = 'horizontal';
	      } else {
	        direction = 'vertical';
	      }
	    }
	
	    var start = this._options.start;
	    var end = this._options.end;
	
	    switch (direction) {
	      case 'horizontal':
	        start.x = 1 - start.x;
	        end.x = 1 - end.x;
	        break;
	      case 'vertical':
	        start.y = 1 - start.y;
	        end.y = 1 - end.y;
	        break;
	    }
	
	    this.set({ start: start, end: end });
	  };
	
	  /**
	   * Crops this image using WebGL
	   * @param  {PhotoEditorSDK} sdk
	   * @override
	   * @private
	   */
	  /* istanbul ignore next */
	
	
	  LinearFocusOperation.prototype._renderWebGL = function _renderWebGL(sdk) {
	    var renderer = sdk.getRenderer();
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var spriteBounds = outputSprite.getBounds();
	    var outputDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	
	    var start = this._options.start.clone();
	    var end = this._options.end.clone();
	
	    start.multiply(outputDimensions);
	    end.multiply(outputDimensions);
	
	    var _options = this._options;
	    var blurRadius = _options.blurRadius;
	    var size = _options.size;
	    var gradientSize = _options.gradientSize;
	
	    var commonOptions = {
	      blurRadius: blurRadius, size: size, gradientSize: gradientSize,
	
	      start: start,
	      end: end,
	      texSize: outputDimensions
	    };
	
	    this._horizontalFilter.set(commonOptions);
	    this._verticalFilter.set(commonOptions);
	
	    var bounds = this._sprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(bounds.width, bounds.height));
	    renderTexture.render(this._container);
	
	    outputSprite.setTexture(renderTexture);
	    this.setDirtyForRenderer(false, renderer);
	
	    return _promise2.default.resolve();
	  };
	
	  /**
	   * Renders the radial blur using Canvas2D
	   * @param  {PhotoEditorSDK} sdk
	   * @override
	   * @private
	   */
	
	
	  LinearFocusOperation.prototype._renderCanvas = function _renderCanvas(sdk) {
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    var _options2 = this._options;
	    var blurRadius = _options2.blurRadius;
	    var size = _options2.size;
	    var gradientSize = _options2.gradientSize;
	    var start = _options2.start;
	    var end = _options2.end;
	
	    this._filter.set({
	      blurRadius: blurRadius, gradientSize: gradientSize, size: size, start: start, end: end,
	      texSize: sdk.getOutputDimensions()
	    });
	
	    this._sprite.setTexture(outputSprite.getTexture());
	    this._sprite.setFilters([this._filter]);
	
	    var bounds = this._sprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(bounds.width, bounds.height));
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	
	    return _promise2.default.resolve();
	  };
	
	  return LinearFocusOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	LinearFocusOperation.identifier = 'linear-focus';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	LinearFocusOperation.prototype.availableOptions = {
	  start: { type: 'vector2', default: new _globals.Vector2(0.0, 0.5) },
	  end: { type: 'vector2', default: new _globals.Vector2(1.0, 0.5) },
	  blurRadius: { type: 'number', default: 30 },
	  size: { type: 'number', default: 50 },
	  gradientSize: { type: 'number', default: 50 }
	};
	
	exports.default = LinearFocusOperation;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _vector = __webpack_require__(23);
	
	var _vector2 = _interopRequireDefault(_vector);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can rotate and flip an image
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var OrientationOperation = function (_Operation) {
	  (0, _inherits3.default)(OrientationOperation, _Operation);
	
	  /**
	   * Creates a new OrientationOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function OrientationOperation() {
	    (0, _classCallCheck3.default)(this, OrientationOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._sprite = new _globals.Engine.Sprite();
	    _this._container = new _globals.Engine.Container();
	    _this._container.addChild(_this._sprite);
	    return _this;
	  }
	
	  /**
	   * Rotates and/or flips the image
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   * @override
	   * @private
	   */
	
	
	  OrientationOperation.prototype._render = function _render(sdk) {
	    var renderer = sdk.getRenderer();
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    var actualDegrees = this._options.rotation % 360;
	    var radians = actualDegrees * (Math.PI / 180);
	
	    this._sprite.setScale(this._options.flipHorizontally ? -1 : 1, this._options.flipVertically ? -1 : 1);
	    this._sprite.setRotation(radians);
	    this._sprite.setAnchor(0.5, 0.5);
	    this._sprite.setTexture(outputSprite.getTexture());
	    this._sprite.updateTransform();
	
	    var bounds = this._sprite.getBounds();
	    renderTexture.resizeTo(new _vector2.default(bounds.width, bounds.height));
	
	    // Make sure we're rendering to top left corner
	    this._sprite.setPosition(renderTexture.getWidth() / 2, renderTexture.getHeight() / 2);
	
	    // Draw
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	    this.setDirtyForRenderer(false, renderer);
	
	    return _promise2.default.resolve();
	  };
	
	  /**
	   * Returns the dimensions the given dimensions will have after this operation
	   * has been applied
	   * @param {PhotoEditorSDK.Math.Vector2} dimensions
	   * @return {PhotoEditorSDK.Math.Vector2}
	   * @override
	   */
	
	
	  OrientationOperation.prototype.getNewDimensions = function getNewDimensions(dimensions) {
	    dimensions = dimensions.clone();
	    if (this._options.rotation % 180) {
	      dimensions.flip();
	    }
	    return dimensions;
	  };
	
	  return OrientationOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	OrientationOperation.identifier = 'orientation';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	OrientationOperation.prototype.availableOptions = {
	  rotation: { type: 'number', default: 0, validation: function validation(value) {
	      if (value % 90 !== 0) {
	        throw new Error('OrientationOperation: `rotation` has to be a multiple of 90.');
	      }
	    }, setter: function setter(value) {
	      return value % 360;
	    } },
	  flipVertically: { type: 'boolean', default: false },
	  flipHorizontally: { type: 'boolean', default: false }
	};
	
	exports.default = OrientationOperation;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _promise = __webpack_require__(8);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _radialFocusFilter = __webpack_require__(157);
	
	var _radialFocusFilter2 = _interopRequireDefault(_radialFocusFilter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can draw a radial focus
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var RadialFocusOperation = function (_Operation) {
	  (0, _inherits3.default)(RadialFocusOperation, _Operation);
	
	  /**
	   * Creates a new RadialFocusOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function RadialFocusOperation() {
	    (0, _classCallCheck3.default)(this, RadialFocusOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._lastBlurRadius = _this._options.blurRadius;
	    _this._lastGradientRadius = _this._options.gradientRadius;
	
	    _this._horizontalFilter = new _radialFocusFilter2.default();
	    _this._verticalFilter = new _radialFocusFilter2.default();
	    _this._sprite.setFilters([_this._horizontalFilter, _this._verticalFilter]);
	
	    _this._horizontalFilter.setDelta(new _globals.Vector2(1, 1));
	    _this._verticalFilter.setDelta(new _globals.Vector2(-1, 1));
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._sdk.on(_globals.Constants.Events.OPERATION_UPDATED, _this._onOperationUpdate);
	
	    _this._filter = new _radialFocusFilter2.default();
	    return _this;
	  }
	
	  /**
	   * Gets called when an operation is about to be updated. If the crop
	   * or rotation operation is updated, this will be recognized and the
	   * blur will be updated accordingly
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  RadialFocusOperation.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    var identifier = operation.constructor.identifier;
	
	
	    if (identifier === 'orientation' && 'rotation' in options) {
	      this._applyRotation(operation, options);
	    }
	
	    if (identifier === 'orientation' && ('flipHorizontally' in options || 'flipVertically' in options)) {
	      this._applyFlip(operation, options);
	    }
	  };
	
	  /**
	   * Applies the given rotation change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  RadialFocusOperation.prototype._applyRotation = function _applyRotation(operation, options) {
	    var oldRotation = operation.getRotation();
	    var newRotation = options.rotation;
	    var degreesDifference = newRotation - oldRotation;
	
	    var position = this._options.position;
	
	    if (degreesDifference === 90 || oldRotation === 270 && newRotation === 0) {
	      position.flip();
	      position.x = 1 - position.x;
	    } else if (degreesDifference === -90 || oldRotation === -270 && newRotation === 0) {
	      position.flip();
	      position.y = 1 - position.y;
	    }
	
	    this.set({ position: position });
	  };
	
	  /**
	   * Applies the given flip change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  RadialFocusOperation.prototype._applyFlip = function _applyFlip(operation, options) {
	    if ('flipVertically' in options && operation.getFlipVertically() !== options.flipVertically) {
	      this._applyFlipDirection(operation, 'vertical');
	    }
	
	    if ('flipHorizontally' in options && operation.getFlipHorizontally() !== options.flipHorizontally) {
	      this._applyFlipDirection(operation, 'horizontal');
	    }
	  };
	
	  /**
	   * Applies a flip with the given direction
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {String} direction
	   * @private
	   */
	
	
	  RadialFocusOperation.prototype._applyFlipDirection = function _applyFlipDirection(operation, direction) {
	    var rotation = operation.getRotation();
	    if (rotation === 90 || rotation === 270) {
	      if (direction === 'vertical') {
	        direction = 'horizontal';
	      } else {
	        direction = 'vertical';
	      }
	    }
	
	    var position = this._options.position;
	
	    switch (direction) {
	      case 'horizontal':
	        position.x = 1 - position.x;
	        break;
	      case 'vertical':
	        position.y = 1 - position.y;
	        break;
	    }
	
	    this.set({ position: position });
	  };
	
	  /**
	   * Renders the radial blur using WebGL
	   * @param  {PhotoEditorSDK} sdk
	   * @private
	   * @override
	   */
	  /* istanbul ignore next */
	
	
	  RadialFocusOperation.prototype._renderWebGL = function _renderWebGL(sdk) {
	    var renderer = sdk.getRenderer();
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    this._sprite.setTexture(outputSprite.getTexture());
	    var spriteBounds = outputSprite.getBounds();
	    var outputDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	
	    // Invert Y
	    var position = this._options.position.clone();
	    position.multiply(outputDimensions);
	
	    var _options = this._options;
	    var blurRadius = _options.blurRadius;
	    var radius = _options.radius;
	    var gradientRadius = _options.gradientRadius;
	
	    var commonOptions = {
	      blurRadius: blurRadius, radius: radius, gradientRadius: gradientRadius,
	      position: position,
	      texSize: outputDimensions
	    };
	
	    this._horizontalFilter.set(commonOptions);
	    this._verticalFilter.set(commonOptions);
	
	    var bounds = this._sprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(bounds.width, bounds.height));
	
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	    this.setDirtyForRenderer(false, renderer);
	
	    return _promise2.default.resolve();
	  };
	
	  /**
	   * Renders the radial blur using Canvas2D
	   * @param  {PhotoEditorSDK} sdk
	   * @private
	   * @override
	   */
	
	
	  RadialFocusOperation.prototype._renderCanvas = function _renderCanvas(sdk) {
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    var _options2 = this._options;
	    var blurRadius = _options2.blurRadius;
	    var radius = _options2.radius;
	    var gradientRadius = _options2.gradientRadius;
	    var position = _options2.position;
	
	    this._filter.set({
	      blurRadius: blurRadius, radius: radius, gradientRadius: gradientRadius, position: position,
	      texSize: sdk.getOutputDimensions()
	    });
	
	    this._sprite.setTexture(outputSprite.getTexture());
	    this._sprite.setFilters([this._filter]);
	
	    var bounds = this._sprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(bounds.width, bounds.height));
	    renderTexture.render(this._container);
	    outputSprite.setTexture(renderTexture);
	
	    return _promise2.default.resolve();
	  };
	
	  return RadialFocusOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	RadialFocusOperation.identifier = 'radial-focus';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	RadialFocusOperation.prototype.availableOptions = {
	  position: { type: 'vector2', default: new _globals.Vector2(0.5, 0.5) },
	  radius: { type: 'number', default: 50 },
	  gradientRadius: { type: 'number', default: 25 },
	  blurRadius: { type: 'number', default: 20 }
	};
	
	exports.default = RadialFocusOperation;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _sprite = __webpack_require__(47);
	
	var _sprite2 = _interopRequireDefault(_sprite);
	
	var _sticker = __webpack_require__(162);
	
	var _sticker2 = _interopRequireDefault(_sticker);
	
	var _text = __webpack_require__(163);
	
	var _text2 = _interopRequireDefault(_text);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can draw sprites (text and stickers) on the canvas
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	
	var SpriteOperation = function (_Operation) {
	  (0, _inherits3.default)(SpriteOperation, _Operation);
	
	  /**
	   * Creates a new SpriteOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function SpriteOperation() {
	    (0, _classCallCheck3.default)(this, SpriteOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._renderers = {};
	
	    _this._onOperationUpdate = _this._onOperationUpdate.bind(_this);
	    _this._onSpriteUpdate = _this._onSpriteUpdate.bind(_this);
	    _this._sdk.on(_globals.Constants.Events.OPERATION_UPDATED, _this._onOperationUpdate);
	
	    var sprites = _this._options.sprites.slice();
	    sprites.forEach(function (sprite) {
	      _this.removeSprite(sprite);
	      _this.addSprite(sprite);
	    });
	    return _this;
	  }
	
	  /**
	   * Returns the sprites that are instances of the given class
	   * @param  {Class} Klass
	   * @return {PhotoEditorSDK.Sprite[]}
	   * @todo   Do we still need this?
	   */
	
	
	  SpriteOperation.prototype.getSpritesOfType = function getSpritesOfType(Klass) {
	    return this._options.sprites.filter(function (sprite) {
	      return sprite instanceof Klass;
	    });
	  };
	
	  /**
	   * Gets called when an operation is about to be updated. If the crop
	   * or rotation operation is updated, this will be recognized and the
	   * stickers will be updated accordingly
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  SpriteOperation.prototype._onOperationUpdate = function _onOperationUpdate(operation, options) {
	    var identifier = operation.constructor.identifier;
	
	
	    if (identifier === 'crop' && 'start' in options && 'end' in options) {
	      this._applyCrop(operation, options);
	    }
	
	    if (identifier === 'orientation') {
	      if ('rotation' in options) {
	        this._applyRotation(operation, options);
	      }
	
	      if ('flipVertically' in options && operation.getFlipVertically() !== options.flipVertically) {
	        this._applyFlip(operation, 'vertical');
	      }
	
	      if ('flipHorizontally' in options && operation.getFlipHorizontally() !== options.flipHorizontally) {
	        this._applyFlip(operation, 'horizontal');
	      }
	    }
	  };
	
	  /**
	   * Applies a flip with the given direction
	   * @param  {PhotoEditorSDK.Operation} operation
	   * @param  {String} direction
	   * @private
	   */
	
	
	  SpriteOperation.prototype._applyFlip = function _applyFlip(operation, direction) {
	    var _this2 = this;
	
	    var rotation = operation.getRotation();
	    if (rotation === 90 || rotation === 270) {
	      if (direction === 'vertical') {
	        direction = 'horizontal';
	      } else {
	        direction = 'vertical';
	      }
	    }
	
	    this._options.sprites.forEach(function (sprite) {
	      sprite.applyFlip(_this2._sdk, direction);
	    });
	  };
	
	  /**
	   * Gets called when a sprite is flagged as dirty / its options changed
	   * @param  {PhotoEditorSDK.Sprite} sprite
	   * @param  {Object} options
	   * @private
	   */
	
	
	  SpriteOperation.prototype._onSpriteUpdate = function _onSpriteUpdate(sprite, options) {
	    this.setDirty(true);
	  };
	
	  /**
	   * Applies the given rotation change
	   * @param  {PhotoEditorSDK.Operations.RotationOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  SpriteOperation.prototype._applyRotation = function _applyRotation(operation, options) {
	    var oldRotation = operation.getRotation();
	    var newRotation = options.rotation;
	    var degreesDifference = newRotation - oldRotation;
	
	    var finalDimensions = this._sdk.getFinalDimensions();
	    this._options.sprites.forEach(function (sprite) {
	      // Update sprite rotation
	      var spriteDegrees = sprite.getRotation() * 180 / Math.PI;
	      spriteDegrees += degreesDifference;
	      sprite.setRotation(spriteDegrees * Math.PI / 180);
	
	      // Flip X and Y unless we're rotating by 180 degrees
	      var spritePosition = sprite.getPosition().clone();
	      if (degreesDifference === 90 || oldRotation === 270 && newRotation === 0) {
	        var tempX = spritePosition.x;
	        spritePosition.x = finalDimensions.y - spritePosition.y;
	        spritePosition.y = tempX;
	      } else if (degreesDifference === -90 || oldRotation === -270 && newRotation === 0) {
	        var tempY = spritePosition.y;
	        spritePosition.y = finalDimensions.x - spritePosition.x;
	        spritePosition.x = tempY;
	      }
	      sprite.setPosition(spritePosition);
	    });
	  };
	
	  /**
	   * Applies the given crop change
	   * @param  {PhotoEditorSDK.Operations.CropOperation} operation
	   * @param  {Object} options
	   * @private
	   */
	
	
	  SpriteOperation.prototype._applyCrop = function _applyCrop(operation, options) {
	    var inputDimensions = this._sdk.getInputDimensions();
	
	    var oldStart = operation.getStart();
	    var newStart = options.start;
	
	    this._options.sprites.forEach(function (sprite) {
	      var position = sprite.getPosition().clone();
	      sprite.set({
	        position: position.add(oldStart.clone().subtract(newStart).multiply(inputDimensions))
	      }, false);
	    });
	  };
	
	  /**
	   * Returns a serialized version of the given option
	   * @param {String} optionName
	   * @return {*} optionName
	   * @private
	   * @override
	   */
	
	
	  SpriteOperation.prototype._serializeOption = function _serializeOption(optionName) {
	    // Since `sprites` is an array of configurables, we need
	    // to serialize them as well
	    if (optionName === 'sprites') {
	      return this._options.sprites.map(function (sprite) {
	        return sprite.serializeOptions();
	      });
	    }
	    return _Operation.prototype._serializeOption.call(this, optionName);
	  };
	
	  /**
	   * Creates a new sticker object and returns it
	   * @param  {Object} options
	   * @return {PhotoEditorSDK.Operations.SpriteOperation.Sticker}
	   */
	
	
	  SpriteOperation.prototype.createSticker = function createSticker(options) {
	    return new _sticker2.default(this, options);
	  };
	
	  /**
	   * Creates a new sticker object and returns it
	   * @param  {Object} options
	   * @return {PhotoEditorSDK.Operations.SpriteOperation.Text}
	   */
	
	
	  SpriteOperation.prototype.createText = function createText(options) {
	    return new _text2.default(this, options);
	  };
	
	  /**
	   * Gets called when a sprite has been added
	   * @param {PhotoEditorSDK.Sprite} sprite
	   */
	
	
	  SpriteOperation.prototype.addSprite = function addSprite(sprite) {
	    this._options.sprites.push(sprite);
	    this._container.addChild(sprite.getDisplayObject());
	
	    // This operation needs to be rerendered
	    this.setDirty(true);
	
	    sprite.on('update', this._onSpriteUpdate);
	  };
	
	  /**
	   * Removes the given sprite from the list of sprites
	   * @param  {PhotoEditorSDK.Sprite} sprite
	   * @return {Boolean}
	   */
	
	
	  SpriteOperation.prototype.removeSprite = function removeSprite(sprite) {
	    var sprites = this._options.sprites;
	    var index = sprites.indexOf(sprite);
	    if (index !== -1) {
	      sprite.off('update', this._onSpriteUpdate);
	      this._container.removeChild(sprite.getDisplayObject());
	
	      sprites.splice(index, 1);
	      return true;
	    }
	    return false;
	  };
	
	  /**
	   * Renders this operation
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   * @override
	   * @private
	   */
	
	
	  SpriteOperation.prototype._render = function _render(sdk) {
	    var outputSprite = sdk.getSprite();
	    var renderTexture = this._getRenderTexture(sdk);
	
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var container = this._container;
	    var sprites = this._options.sprites;
	
	    var outputBounds = outputSprite.getBounds();
	    renderTexture.resizeTo(new _globals.Vector2(outputBounds.width, outputBounds.height));
	
	    return _globals.Promise.all(sprites.map(function (s) {
	      return s.validateSettings();
	    })).then(function () {
	      sprites.forEach(function (sprite) {
	        sprite.update(sdk);
	      });
	
	      renderTexture.clear();
	      renderTexture.render(container);
	      outputSprite.setTexture(renderTexture);
	    });
	  };
	
	  /**
	   * Takes the given Sprite to front
	   * @param  {PhotoEditorSDK.Operations.SpriteOperation.Sprite} sprite
	   */
	
	
	  SpriteOperation.prototype.takeSpriteToFront = function takeSpriteToFront(sprite) {
	    var sprites = this._options.sprites;
	
	    var spriteIndex = sprites.indexOf(sprite);
	    if (spriteIndex === -1) return;
	
	    _globals.Utils.moveArrayItem(sprites, spriteIndex, sprites.length - 1);
	
	    var displayObject = sprite.getDisplayObject();
	    this._container.removeChild(displayObject);
	    this._container.addChild(displayObject);
	
	    this.setDirty(true);
	  };
	
	  /**
	   * Returns the sprite at the given position on the canvas
	   * @param  {PhotoEditorSDK.Math.Vector2} position
	   * @param  {Class} [type]
	   * @return {PhotoEditorSDK.Sprite}
	   */
	
	
	  SpriteOperation.prototype.getSpriteAtPosition = function getSpriteAtPosition(position, type) {
	    var _this3 = this;
	
	    this._options.sprites.forEach(function (s) {
	      return s.update(_this3._sdk);
	    });
	
	    // Translate canvas position to relative position on sprite by
	    // applying the inverse of our outputSprite's world transform matrix
	    var outputSprite = this._sdk.getSprite();
	    var actualPosition = outputSprite.getWorldTransform().applyInverseToVector(position);
	
	    // Apply anchor
	
	    var _outputSprite$getText = outputSprite.getTexture().getFrame();
	
	    var width = _outputSprite$getText.width;
	    var height = _outputSprite$getText.height;
	
	    var anchorOffset = outputSprite.getAnchor().clone().multiply(-width, -height);
	    actualPosition.subtract(anchorOffset);
	
	    // Find intersecting sprite
	    var intersectingSprite = null;
	    var sprites = this._options.sprites.slice(0).reverse();
	    for (var i = 0, c = sprites.length; i < c; i++) {
	      var sprite = sprites[i];
	      if (type && !(sprite instanceof type)) {
	        continue;
	      }
	      if (sprite.getDisplayObject().isAtPosition(actualPosition)) {
	        intersectingSprite = sprite;
	        break;
	      }
	    }
	    return intersectingSprite;
	  };
	
	  /**
	   * Disposes this operation
	   */
	
	
	  SpriteOperation.prototype.dispose = function dispose() {
	    this._sdk.off(_globals.Constants.Events.OPERATION_UPDATED, this._onOperationUpdate);
	  };
	
	  return SpriteOperation;
	}(_operation2.default); /*
	                         * This file is part of PhotoEditorSDK.
	                         *
	                         * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                         * All rights reserved.
	                         *
	                         * Redistribution and use in source and binary forms, without
	                         * modification, are permitted provided that the following license agreement
	                         * is approved and a legal/financial contract was signed by the user.
	                         * The license agreement can be found under following link:
	                         *
	                         * https://www.photoeditorsdk.com/LICENSE.txt
	                         */
	
	SpriteOperation.Sticker = _sticker2.default;
	SpriteOperation.Text = _text2.default;
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	SpriteOperation.identifier = 'sprite';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	SpriteOperation.prototype.availableOptions = {
	  sprites: {
	    type: 'array', default: [],
	    setter: function setter(sprites, initial) {
	      var _this4 = this;
	
	      sprites = sprites.map(function (sprite, i) {
	        if (sprite instanceof _sprite2.default) {
	          return sprite;
	        }
	
	        var type = sprite.type;
	
	        delete sprite.type;
	
	        // Create sprite from the given options
	        switch (type) {
	          case 'text':
	            return new _text2.default(_this4, sprite);
	          case 'sticker':
	            return new _sticker2.default(_this4, sprite);
	          default:
	            _globals.Log.error(_this4.constructor.name, 'Invalid sprite type: ' + sprite.type);
	        }
	      });
	
	      // Remove all sprites
	      if (!initial) {
	        if (this._options.sprites) {
	          var spritesToRemove = this._options.sprites.slice();
	          spritesToRemove.forEach(function (sprite) {
	            _this4.removeSprite(sprite);
	          });
	        }
	
	        // Add all sprites
	        sprites.forEach(function (sprite) {
	          _this4.addSprite(sprite);
	        });
	      }
	
	      return sprites;
	    }
	  }
	};
	
	exports.default = SpriteOperation;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _sprite = __webpack_require__(47);
	
	var _sprite2 = _interopRequireDefault(_sprite);
	
	var _adjustmentsFilter = __webpack_require__(76);
	
	var _adjustmentsFilter2 = _interopRequireDefault(_adjustmentsFilter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A sticker that can be drawn by SpriteOperation. Should only be created via {@link PhotoEditorSDK.Operations.SpriteOperation#createSticker}
	 * @class
	 * @memberof PhotoEditorSDK.Operations.SpriteOperation
	 */
	
	var Sticker = function (_Sprite) {
	  (0, _inherits3.default)(Sticker, _Sprite);
	
	  /**
	   * Creates a new Sticker
	   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
	   * @param  {Object} [options]
	   */
	
	  function Sticker() {
	    (0, _classCallCheck3.default)(this, Sticker);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Sprite.call.apply(_Sprite, [this].concat(args)));
	
	    if (_this._options.image) {
	      _this._onImageUpdate();
	    }
	
	    _this._renderTextures = {};
	    _this._adjustmentsFilter = new _adjustmentsFilter2.default();
	    return _this;
	  }
	
	  /**
	   * Returns a serialized version of this configurable
	   * @return {Object}
	   */
	
	
	  Sticker.prototype.serializeOptions = function serializeOptions() {
	    var options = _Sprite.prototype.serializeOptions.call(this);
	    options.type = 'sticker';
	    return options;
	  };
	
	  /**
	   * Updates this sprite
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   */
	
	
	  Sticker.prototype.update = function update(sdk) {
	    _Sprite.prototype.update.call(this, sdk);
	
	    var renderer = sdk.getRenderer();
	
	    var renderTexture = this._getRenderTexture(renderer);
	    var hasAdjustments = this._hasAdjustments();
	
	    this._identitySprite.setFilters(hasAdjustments ? [this._adjustmentsFilter] : []);
	
	    // Stickers with adjustments are rendered to a render texture that
	    // can be re-used
	    if (hasAdjustments) {
	      this._identitySprite.setTexture(this._inputTexture);
	
	      var adjustments = this._options.adjustments;
	      this._adjustmentsFilter.set({
	        brightness: adjustments.getBrightness(),
	        saturation: adjustments.getSaturation(),
	        contrast: adjustments.getContrast()
	      });
	
	      var _options$image = this._options.image;
	      var width = _options$image.width;
	      var height = _options$image.height;
	
	      renderTexture.resizeTo(new _globals.Vector2(width, height));
	      renderTexture.clear();
	      renderTexture.render(this._identitySprite);
	      this._sprite.setTexture(renderTexture);
	    } else {
	      this._sprite.setTexture(this._inputTexture);
	    }
	
	    // Flip
	    var scale = this._sprite.getScale();
	    if (this._options.flipVertically) {
	      scale.y *= -1;
	    }
	    if (this._options.flipHorizontally) {
	      scale.x *= -1;
	    }
	    this._sprite.setScale(scale);
	
	    return _globals.Promise.resolve();
	  };
	
	  /**
	   * Creates and/or returns a RenderTexture
	   * @param {PhotoEditorSDK.Engine.BaseRenderer} renderer
	   * @return {PhotoEditorSDK.Engine.RenderTexture}
	   * @private
	   */
	
	
	  Sticker.prototype._getRenderTexture = function _getRenderTexture(renderer) {
	    if (!this._renderTextures[renderer.id]) {
	      var _options$image2 = this._options.image;
	      var width = _options$image2.width;
	      var height = _options$image2.height;
	
	      this._renderTextures[renderer.id] = new _globals.Engine.RenderTexture(renderer, width, height, 1);
	    }
	    return this._renderTextures[renderer.id];
	  };
	
	  /**
	   * Checks if this sticker has any adjustments and a filter is needed
	   * @return {Boolean}
	   * @private
	   */
	
	
	  Sticker.prototype._hasAdjustments = function _hasAdjustments() {
	    var adjustments = this._options.adjustments;
	    return adjustments.getBrightness() !== 0 || adjustments.getSaturation() !== 1 || adjustments.getContrast() !== 1;
	  };
	
	  /**
	   * Gets called when this sticker's image is updated
	   * @private
	   */
	
	
	  Sticker.prototype._onImageUpdate = function _onImageUpdate() {
	    this._inputTexture = _globals.Engine.Texture.fromImage(this._options.image);
	    this._identitySprite.setTexture(this._inputTexture);
	    this._sprite.setTexture(this._inputTexture);
	    this.setDirty(true);
	  };
	
	  /**
	   * Sets the value for the given option, validates it
	   * @param {String} optionName
	   * @param {*} value
	   * @param {Boolean} update = true
	   * @override
	   */
	
	
	  Sticker.prototype.setOption = function setOption(optionName, value) {
	    var update = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	    _Sprite.prototype.setOption.call(this, optionName, value, update);
	
	    if (optionName === 'image' && this._identitySprite) {
	      this._onImageUpdate();
	    }
	  };
	
	  return Sticker;
	}(_sprite2.default); /*
	                      * This file is part of PhotoEditorSDK.
	                      *
	                      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                      * All rights reserved.
	                      *
	                      * Redistribution and use in source and binary forms, without
	                      * modification, are permitted provided that the following license agreement
	                      * is approved and a legal/financial contract was signed by the user.
	                      * The license agreement can be found under following link:
	                      *
	                      * https://www.photoeditorsdk.com/LICENSE.txt
	                      */
	
	Sticker.prototype.availableOptions = {
	  name: { type: 'string', default: '' },
	  image: { type: 'object', required: true },
	  position: { type: 'vector2', default: new _globals.Vector2(0, 0) },
	  scale: { type: 'vector2', default: new _globals.Vector2(1.0, 1.0) },
	  anchor: { type: 'vector2', default: new _globals.Vector2(0.0, 0.0) },
	  pivot: { type: 'vector2', default: new _globals.Vector2(0.5, 0.5) },
	  rotation: { type: 'number', default: 0 },
	  flipHorizontally: { type: 'boolean', default: false },
	  flipVertically: { type: 'boolean', default: false },
	  adjustments: { type: 'configurable', structure: {
	      brightness: { type: 'number', default: 0 },
	      saturation: { type: 'number', default: 1 },
	      contrast: { type: 'number', default: 1 }
	    } }
	};
	
	exports.default = Sticker;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _sprite = __webpack_require__(47);
	
	var _sprite2 = _interopRequireDefault(_sprite);
	
	var _textRenderer = __webpack_require__(164);
	
	var _textRenderer2 = _interopRequireDefault(_textRenderer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * A text that can be drawn by SpriteOperation. Should only be created via {@link PhotoEditorSDK.Operations.SpriteOperation#createText}
	 * @class
	 * @memberof PhotoEditorSDK.Operations.SpriteOperation
	 */
	
	var Text = function (_Sprite) {
	  (0, _inherits3.default)(Text, _Sprite);
	
	  /**
	   * Creates a new Text
	   * @param  {PhotoEditorSDK.Operations.SpriteOperation} operation
	   * @param  {Object} [options]
	   */
	
	  function Text() {
	    (0, _classCallCheck3.default)(this, Text);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Sprite.call.apply(_Sprite, [this].concat(args)));
	
	    _this._textRenderer = new _textRenderer2.default(_this, _this._operation);
	    _this._sprite.setTexture(_this._textRenderer.getTexture());
	    return _this;
	  }
	
	  /**
	   * Returns a serialized version of this configurable
	   * @return {Object}
	   */
	
	
	  Text.prototype.serializeOptions = function serializeOptions() {
	    var options = _Sprite.prototype.serializeOptions.call(this);
	    options.type = 'text';
	    return options;
	  };
	
	  /**
	   * Returns a style object for this text
	   * @param {PhotoEditorSDK} SDK
	   * @param {PhotoEditorSDK.Math.Vector2} outputDimensions
	   * @return {Object}
	   */
	
	
	  Text.prototype.getDOMStyle = function getDOMStyle(sdk, outputDimensions) {
	    var textOptions = this._textRenderer.calculateFontStyles(sdk, true);
	
	    return {
	      fontWeight: this._options.fontWeight,
	      fontSize: textOptions.fontSize,
	      fontFamily: this._options.fontFamily,
	      lineHeight: textOptions.lineHeight + 'px',
	      color: this._options.color.toRGBA(),
	      backgroundColor: this._options.backgroundColor.toRGBA(),
	      textAlign: this._options.alignment
	    };
	  };
	
	  /**
	   * Returns the bounding box for this text
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Boolean} considerZoom = false
	   * @return {PhotoEditorSDK.Math.Vector2}
	   */
	
	
	  Text.prototype.getBoundingBox = function getBoundingBox(sdk) {
	    var considerZoom = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    return this._textRenderer.getBoundingBox(sdk, considerZoom);
	  };
	
	  /**
	   * Applies a flip in the given direction
	   * @param  {String} direction
	   */
	
	
	  Text.prototype.applyFlip = function applyFlip(direction) {
	    _Sprite.prototype.applyFlip.call(this, direction);
	
	    var rotation = this._options.rotation;
	    switch (direction) {
	      case 'horizontal':
	        rotation += (Math.PI - rotation) * 2;
	        this.setRotation(rotation);
	        break;
	      case 'vertical':
	        rotation += (Math.PI / 2 - rotation) * 2;
	        this.setRotation(rotation);
	        break;
	    }
	  };
	
	  /**
	   * Updates this sprite
	   * @param  {PhotoEditorSDK} sdk
	   * @return {Promise}
	   */
	
	
	  Text.prototype.update = function update(sdk) {
	    // Re-render text
	    this._textRenderer.update(sdk);
	    var textTexture = this._textRenderer.getTexture();
	    var baseTexture = textTexture.getBaseTexture();
	    baseTexture.update();
	
	    // Upload texture
	    var renderer = sdk.getRenderer();
	
	    /* istanbul ignore next */
	    if (renderer.isOfType('webgl')) {
	      renderer.updateTexture(textTexture.getBaseTexture());
	    }
	
	    return _Sprite.prototype.update.call(this, sdk);
	  };
	
	  return Text;
	}(_sprite2.default); /*
	                      * This file is part of PhotoEditorSDK.
	                      *
	                      * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	                      * All rights reserved.
	                      *
	                      * Redistribution and use in source and binary forms, without
	                      * modification, are permitted provided that the following license agreement
	                      * is approved and a legal/financial contract was signed by the user.
	                      * The license agreement can be found under following link:
	                      *
	                      * https://www.photoeditorsdk.com/LICENSE.txt
	                      */
	
	Text.prototype.availableOptions = {
	  fontSize: { type: 'number', default: 30 },
	  lineHeight: { type: 'number', default: 1.1 },
	  fontFamily: { type: 'string', default: 'Times New Roman' },
	  fontWeight: { type: 'string', default: 'normal' },
	  alignment: { type: 'string', default: 'left', available: ['left', 'center', 'right'] },
	  verticalAlignment: { type: 'string', default: 'top', available: ['top', 'center', 'bottom'] },
	  color: { type: 'color', default: new _globals.Color(1, 0, 0, 1) },
	  backgroundColor: { type: 'color', default: new _globals.Color(0, 0, 0, 0) },
	  position: { type: 'vector2', default: new _globals.Vector2(0, 0) },
	  anchor: { type: 'vector2', default: new _globals.Vector2(0.5, 0.5) },
	  pivot: { type: 'vector2', default: new _globals.Vector2(0, 0) },
	  rotation: { type: 'number', default: 0 },
	  text: { type: 'string', required: true },
	  maxWidth: { type: 'number', default: 100 },
	  maxHeight: { type: 'number', default: 0 },
	  flipHorizontally: { type: 'boolean', default: false },
	  flipVertically: { type: 'boolean', default: false }
	};
	
	exports.default = Text;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _globals = __webpack_require__(5);
	
	var _textSplitter = __webpack_require__(165);
	
	var _textSplitter2 = _interopRequireDefault(_textSplitter);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var TextRenderer = function () {
	  function TextRenderer(text, operation) {
	    (0, _classCallCheck3.default)(this, TextRenderer);
	
	    this._text = text;
	    this._operation = operation;
	
	    this._createCanvas();
	    this._createTexture();
	  }
	
	  /**
	   * Creates the canvas and initializes the text splitter
	   * @private
	   */
	
	
	  TextRenderer.prototype._createCanvas = function _createCanvas() {
	    this._canvas = _globals.Utils.createCanvas();
	    this._context = this._canvas.getContext('2d');
	    this._textSplitter = new _textSplitter2.default(this._context);
	  };
	
	  /**
	   * Creates the texture
	   * @private
	   */
	
	
	  TextRenderer.prototype._createTexture = function _createTexture() {
	    this._texture = _globals.Engine.Texture.fromCanvas(this._canvas);
	  };
	
	  /**
	   * Applies the text options on the given context
	   * @param  {Object} textOptions
	   * @private
	   */
	
	
	  TextRenderer.prototype._applyTextOptions = function _applyTextOptions(textOptions) {
	    this._context.font = this._text.getFontWeight() + ' ' + textOptions.fontSize + 'px ' + this._text.getFontFamily();
	    this._context.textBaseline = 'top';
	    this._context.textAlign = this._text.getAlignment();
	    this._context.fillStyle = this._text.getColor().toRGBA();
	  };
	
	  /**
	   * Iterate over all lines and split them into multiple lines, depending
	   * on the width they need
	   * @param {Number} maxWidth
	   * @return {Array.<string>}
	   * @private
	   */
	
	
	  TextRenderer.prototype._buildOutputLines = function _buildOutputLines(maxWidth) {
	    this._textSplitter.setText(this._text.getText());
	    this._textSplitter.setMaxWidth(maxWidth);
	    return this._textSplitter.getLines();
	  };
	
	  /**
	   * Draws the given line onto context at the given Y position
	   * @param  {String} text
	   * @param  {Number} y
	   * @private
	   */
	
	
	  TextRenderer.prototype._renderTextLine = function _renderTextLine(text, y) {
	    var textAlignment = this._text.getAlignment();
	    if (textAlignment === 'center') {
	      this._context.fillText(text, this._canvas.width / 2, y);
	    } else if (textAlignment === 'left') {
	      this._context.fillText(text, 0, y);
	    } else if (textAlignment === 'right') {
	      this._context.fillText(text, this._canvas.width, y);
	    }
	  };
	
	  /**
	   * Renders this sprite
	   * @param  {PhotoEditorSDK} sdk
	   * @returns {Promise}
	   */
	
	
	  TextRenderer.prototype.update = function update(sdk) {
	    var textOptions = this.calculateFontStyles(sdk);
	
	    var _calculateText2 = this._calculateText(sdk, textOptions);
	
	    var boundingBox = _calculateText2.boundingBox;
	    var lines = _calculateText2.lines;
	
	    return this._renderText(sdk, boundingBox, lines, textOptions);
	  };
	
	  /**
	   * Renders the text
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Vector2} boundingBox
	   * @param  {Array.<String>} lines
	   * @param  {Object} textOptions
	   * @return {Promise}
	   * @private
	   */
	
	
	  TextRenderer.prototype._renderText = function _renderText(sdk, boundingBox, lines, textOptions) {
	    var _this = this;
	
	    return new _globals.Promise(function (resolve, reject) {
	      // Resize the canvas
	      _this._canvas.width = boundingBox.x;
	      _this._canvas.height = boundingBox.y;
	
	      if (_this._text.getMaxHeight()) {
	        _this._canvas.height = Math.min(_this._text.getMaxHeight(), _this._canvas.height);
	      }
	
	      // Update the context
	      _this._context = _this._canvas.getContext('2d');
	
	      // Render background color
	      _this._context.fillStyle = _this._text.getBackgroundColor().toRGBA();
	      _this._context.fillRect(0, 0, boundingBox.x, boundingBox.y);
	
	      // Apply text options
	      _this._applyTextOptions(textOptions);
	
	      // Draw lines
	      for (var lineNum = 0; lineNum < lines.length; lineNum++) {
	        var line = lines[lineNum];
	        _this._renderTextLine(line, textOptions.lineHeight * lineNum);
	      }
	
	      resolve();
	    });
	  };
	
	  /**
	   * Calculates the actual font size and line height
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Boolean} considerZoom
	   */
	
	
	  TextRenderer.prototype.calculateFontStyles = function calculateFontStyles(sdk) {
	    var considerZoom = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    var fontSize = this._text.getFontSize();
	    var lineHeight = this._text.getLineHeight() * fontSize;
	
	    if (considerZoom) {
	      var zoom = sdk.getZoom();
	      fontSize *= zoom;
	      lineHeight *= zoom;
	    }
	
	    return { fontSize: fontSize, lineHeight: lineHeight };
	  };
	
	  /**
	   * Calculates the bounding box and new lines according to max width
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} textOptions
	   * @return {Object}
	   * @private
	   */
	
	
	  TextRenderer.prototype._calculateText = function _calculateText(sdk, textOptions) {
	    // Calculate max width
	    var maxWidth = this._text.getMaxWidth();
	
	    // Apply text options
	    this._applyTextOptions(textOptions);
	
	    // Calculate bounding box
	    var boundingBox = new _globals.Vector2();
	    var lines = this._text.getText().split('\n');
	    if (typeof maxWidth !== 'undefined') {
	      // Calculate the bounding box
	      boundingBox.x = maxWidth;
	      lines = this._buildOutputLines(maxWidth);
	    } else {
	      for (var lineNum = 0; lineNum < lines.length; lineNum++) {
	        var line = lines[lineNum];
	        boundingBox.x = Math.max(boundingBox.x, this._context.measureText(line).width);
	      }
	    }
	
	    // Calculate boundingbox height
	    boundingBox.y = textOptions.lineHeight * lines.length;
	
	    return { boundingBox: boundingBox, lines: lines };
	  };
	
	  /**
	   * Returns this renderer's texture
	   * @return {Engine.Texture}
	   */
	
	
	  TextRenderer.prototype.getTexture = function getTexture() {
	    return this._texture;
	  };
	
	  /**
	   * Returns the bounding box for this text
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Boolean} considerZoom = false
	   * @return {Vector2}
	   */
	
	
	  TextRenderer.prototype.getBoundingBox = function getBoundingBox(sdk) {
	    var considerZoom = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	    var textOptions = this.calculateFontStyles(sdk);
	
	    var _calculateText3 = this._calculateText(sdk, textOptions);
	
	    var boundingBox = _calculateText3.boundingBox;
	
	    if (considerZoom) {
	      boundingBox.multiply(sdk.getZoom());
	    }
	    return boundingBox;
	  };
	
	  return TextRenderer;
	}();
	
	exports.default = TextRenderer;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var TextSplitter = function () {
	  function TextSplitter(context) {
	    (0, _classCallCheck3.default)(this, TextSplitter);
	
	    this._context = context;
	    this._lastFontStyle = {};
	    this._characterWidthCache = {};
	  }
	
	  /**
	   * Returns the lines that fit the maxWidth
	   * @return {Array.<String>}
	   */
	
	
	  TextSplitter.prototype.getLines = function getLines() {
	    if (this._fontStyleChanged()) {
	      this._characterWidthCache = {};
	    }
	
	    var lines = [];
	    var newLineWords = [];
	
	    // Iterate over lines
	    var linesCount = this._lines.length;
	    for (var l = 0; l < linesCount; l++) {
	      var line = this._lines[l];
	
	      // Iterate over words
	      var words = this._buildWords(line);
	      var wordsCount = words.length;
	      for (var w = 0; w < wordsCount; w++) {
	        var word = words[w];
	
	        // Check if line is too wide for the maxwidth
	        var currentLine = newLineWords.concat(word).join('').replace(/\s+$/i, '');
	        var width = this._getWidth(currentLine);
	        if (width > this._maxWidth) {
	          // If there have been words before this one, start
	          // a new line
	          if (newLineWords.length > 0) {
	            // Line too long -> line ended
	            lines.push(newLineWords.join(''));
	
	            // Start a new line with the word
	            newLineWords = [word];
	          }
	
	          // If the next word is too long (without trailing spaces), split it up
	          var _word = word.replace(/\s+$/i, '');
	          if (this._getWidth(_word) > this._maxWidth) {
	            var splitWord = this._splitWord(word);
	            lines = lines.concat(splitWord.lines);
	            if (splitWord.rest) {
	              newLineWords = [splitWord.rest];
	            }
	          }
	        } else {
	          newLineWords.push(word);
	        }
	      }
	
	      lines.push(newLineWords.join(''));
	      newLineWords = [];
	    }
	
	    return lines;
	  };
	
	  /**
	   * Builds an array of words from the given line
	   * @param  {String} line
	   * @return {Array.<String>}
	   * @private
	   */
	
	
	  TextSplitter.prototype._buildWords = function _buildWords(line) {
	    var words = [];
	    var word = '';
	
	    var len = line.length;
	    for (var i = 0; i < len; i++) {
	      var char = line[i];
	      word += char;
	      if (char === ' ' || char === '-' || i === len - 1) {
	        words.push(word);
	        word = '';
	      }
	    }
	
	    return words;
	  };
	
	  /**
	   * Splits up the given word to fit the max width
	   * @param  {String} word
	   * @return {Object}
	   * @private
	   */
	
	
	  TextSplitter.prototype._splitWord = function _splitWord(word) {
	    var response = {
	      lines: [],
	      rest: null
	    };
	
	    var wordLength = word.length;
	    var chars = [];
	    for (var c = 0; c < wordLength; c++) {
	      var char = word[c];
	      if (this._getWidth(chars.concat(char).join('')) > this._maxWidth) {
	        if (chars.length > 0) {
	          response.lines.push(chars.join(''));
	        }
	        chars = [char];
	      } else {
	        chars.push(char);
	      }
	
	      if (c === wordLength - 1 && chars.length > 0) {
	        response.rest = chars.join('');
	      }
	    }
	
	    return response;
	  };
	
	  /**
	   * Checks if the font style changed from the last call
	   * @return {Boolean}
	   * @private
	   */
	
	
	  TextSplitter.prototype._fontStyleChanged = function _fontStyleChanged() {
	    if (this._context.font !== this._lastFontStyle) {
	      this._lastFontStyle = this._context.font;
	      return true;
	    }
	    return false;
	  };
	
	  /**
	   * Returns the measured width for the given string
	   * @param  {String} string
	   * @return {Number}
	   * @private
	   */
	
	
	  TextSplitter.prototype._getWidth = function _getWidth(string) {
	    var width = 0;
	    var stringLength = string.length;
	    for (var c = 0; c < stringLength; c++) {
	      var char = string[c];
	      if (!this._characterWidthCache[char]) {
	        var charWidth = this._context.measureText(char).width;
	        this._characterWidthCache[char] = charWidth;
	      }
	      width += this._characterWidthCache[char];
	    }
	    return width;
	  };
	
	  /**
	   * Sets the text
	   * @param {String} text
	   */
	
	
	  TextSplitter.prototype.setText = function setText(text) {
	    this._text = text;
	    this._lines = text.split('\n');
	  };
	
	  /**
	   * Sets the max width
	   * @param {Number} maxWidth
	   */
	
	
	  TextSplitter.prototype.setMaxWidth = function setMaxWidth(maxWidth) {
	    this._maxWidth = maxWidth;
	  };
	
	  return TextSplitter;
	}();
	
	exports.default = TextSplitter;

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _classCallCheck2 = __webpack_require__(0);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _possibleConstructorReturn2 = __webpack_require__(2);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(1);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _globals = __webpack_require__(5);
	
	var _operation = __webpack_require__(9);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * An operation that can draw a watermark on top of the image
	 * @class
	 * @extends PhotoEditorSDK.Operation
	 * @memberof PhotoEditorSDK.Operations
	 */
	/*
	 * This file is part of PhotoEditorSDK.
	 *
	 * Copyright (C) 2016 9elements GmbH <contact@9elements.com>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, without
	 * modification, are permitted provided that the following license agreement
	 * is approved and a legal/financial contract was signed by the user.
	 * The license agreement can be found under following link:
	 *
	 * https://www.photoeditorsdk.com/LICENSE.txt
	 */
	
	var WatermarkOperation = function (_Operation) {
	  (0, _inherits3.default)(WatermarkOperation, _Operation);
	
	  /**
	   * Creates a new WatermarkOperation
	   * @param  {PhotoEditorSDK} sdk
	   * @param  {Object} [options]
	   */
	
	  function WatermarkOperation() {
	    (0, _classCallCheck3.default)(this, WatermarkOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    var _this = (0, _possibleConstructorReturn3.default)(this, _Operation.call.apply(_Operation, [this].concat(args)));
	
	    _this._watermarkSprite = new _globals.Engine.Sprite();
	    _this._watermarkSprite.setAnchor(0.5, 0.5);
	    _this._container.addChild(_this._watermarkSprite);
	    return _this;
	  }
	
	  /**
	   * Renders the watermark
	   * @param  {PhotoEditorSDK} sdk
	   * @private
	   * @override
	   */
	
	
	  WatermarkOperation.prototype._render = function _render(sdk) {
	    if (!this._watermarkTexture) {
	      this._watermarkTexture = _globals.Engine.Texture.fromImage(this._options.image);
	      this._watermarkSprite.setTexture(this._watermarkTexture);
	    }
	
	    var outputSprite = sdk.getSprite();
	    var spriteBounds = outputSprite.getBounds();
	    var spriteDimensions = new _globals.Vector2(spriteBounds.width, spriteBounds.height);
	    var renderTexture = this._getRenderTexture(sdk);
	    renderTexture.resizeTo(spriteDimensions);
	    this._sprite.setTexture(outputSprite.getTexture());
	
	    var _options$image = this._options.image;
	    var width = _options$image.width;
	    var height = _options$image.height;
	
	    var dimensions = _globals.Utils.resizeVectorToFit(new _globals.Vector2(width, height), spriteDimensions);
	    this._watermarkSprite.setPosition(spriteDimensions.x / 2, spriteDimensions.y / 2);
	    this._watermarkSprite.setWidth(dimensions.x);
	    this._watermarkSprite.setHeight(dimensions.y);
	
	    renderTexture.render(this._container);
	
	    outputSprite.setTexture(renderTexture);
	    return _globals.Promise.resolve();
	  };
	
	  return WatermarkOperation;
	}(_operation2.default);
	
	/**
	 * A unique string that identifies this operation. Can be used to select
	 * operations.
	 * @type {String}
	 * @default
	 */
	
	
	WatermarkOperation.identifier = 'watermark';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 * @ignore
	 */
	WatermarkOperation.prototype.availableOptions = {
	  image: { type: 'object', required: true }
	};
	
	exports.default = WatermarkOperation;

/***/ },
/* 167 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/*!
	 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	 * http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
	 * requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
	 * MIT license
	 */
	var root = typeof window === 'undefined' ? global : window;
	var rAF = root.requestAnimationFrame;
	var cAF = root.cancelAnimationFrame;
	
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for (var x = 0; x < vendors.length && !rAF; ++x) {
	  exports.requestAnimationFrame = rAF = root[vendors[x] + 'RequestAnimationFrame'];
	  exports.cancelAnimationFrame = cAF = root[vendors[x] + 'CancelAnimationFrame'] || root[vendors[x] + 'CancelRequestAnimationFrame'];
	}
	
	if (!rAF) {
	  exports.requestAnimationFrame = rAF = function rAF(callback, element) {
	    var currTime = new Date().getTime();
	    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
	    var id = setTimeout(function () {
	      callback(currTime + timeToCall);
	    }, timeToCall);
	    lastTime = currTime + timeToCall;
	    return id;
	  };
	}
	
	if (!cAF) {
	  exports.cancelAnimationFrame = cAF = function cAF(id) {
	    clearTimeout(id);
	  };
	}
	
	exports.requestAnimationFrame = rAF;
	exports.cancelAnimationFrame = cAF;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(173), __esModule: true };

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(175), __esModule: true };

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(176), __esModule: true };

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(177), __esModule: true };

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(81);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	
	  return obj;
	};

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(198);
	var $Object = __webpack_require__(18).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(199);
	var $Object = __webpack_require__(18).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(200);
	module.exports = __webpack_require__(18).Object.setPrototypeOf;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(203);
	__webpack_require__(201);
	__webpack_require__(204);
	__webpack_require__(205);
	module.exports = __webpack_require__(18).Symbol;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(202);
	__webpack_require__(206);
	module.exports = __webpack_require__(60).f('iterator');

/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(16)
	  , toLength  = __webpack_require__(195)
	  , toIndex   = __webpack_require__(194);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(34)
	  , gOPS    = __webpack_require__(90)
	  , pIE     = __webpack_require__(53);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11).document && document.documentElement;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(83);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(83);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(52)
	  , descriptor     = __webpack_require__(35)
	  , setToStringTag = __webpack_require__(54)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(19)(IteratorPrototype, __webpack_require__(20)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(34)
	  , toIObject = __webpack_require__(16);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(36)('meta')
	  , isObject = __webpack_require__(27)
	  , has      = __webpack_require__(14)
	  , setDesc  = __webpack_require__(15).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(33)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(15)
	  , anObject = __webpack_require__(25)
	  , getKeys  = __webpack_require__(34);
	
	module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(16)
	  , gOPN      = __webpack_require__(89).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(14)
	  , toObject    = __webpack_require__(196)
	  , IE_PROTO    = __webpack_require__(55)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(27)
	  , anObject = __webpack_require__(25);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(84)(Function.call, __webpack_require__(88).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(57)
	  , defined   = __webpack_require__(48);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(57)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(57)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(48);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(179)
	  , step             = __webpack_require__(186)
	  , Iterators        = __webpack_require__(50)
	  , toIObject        = __webpack_require__(16);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(87)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(26)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(52)});

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(26);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(13), 'Object', {defineProperty: __webpack_require__(15).f});

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(26);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(192).set});

/***/ },
/* 201 */
/***/ function(module, exports) {



/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(193)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(87)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(11)
	  , has            = __webpack_require__(14)
	  , DESCRIPTORS    = __webpack_require__(13)
	  , $export        = __webpack_require__(26)
	  , redefine       = __webpack_require__(92)
	  , META           = __webpack_require__(188).KEY
	  , $fails         = __webpack_require__(33)
	  , shared         = __webpack_require__(56)
	  , setToStringTag = __webpack_require__(54)
	  , uid            = __webpack_require__(36)
	  , wks            = __webpack_require__(20)
	  , wksExt         = __webpack_require__(60)
	  , wksDefine      = __webpack_require__(59)
	  , keyOf          = __webpack_require__(187)
	  , enumKeys       = __webpack_require__(181)
	  , isArray        = __webpack_require__(184)
	  , anObject       = __webpack_require__(25)
	  , toIObject      = __webpack_require__(16)
	  , toPrimitive    = __webpack_require__(58)
	  , createDesc     = __webpack_require__(35)
	  , _create        = __webpack_require__(52)
	  , gOPNExt        = __webpack_require__(190)
	  , $GOPD          = __webpack_require__(88)
	  , $DP            = __webpack_require__(15)
	  , $keys          = __webpack_require__(34)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  var D = gOPD(it = toIObject(it), key = toPrimitive(key, true));
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);
	  return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
	      configurable: true,
	      set: function(value){
	        if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	        setSymbolDesc(this, tag, createDesc(1, value));
	      }
	    });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(89).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(53).f  = $propertyIsEnumerable;
	  __webpack_require__(90).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(51)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(19)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(59)('asyncIterator');

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(59)('observable');

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(197);
	var global        = __webpack_require__(11)
	  , hide          = __webpack_require__(19)
	  , Iterators     = __webpack_require__(50)
	  , TO_STRING_TAG = __webpack_require__(20)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 207 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nuniform sampler2D u_image;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\n\nvoid main() {\n  gl_FragColor = texture2D(u_image, v_texCoord) * v_color;\n}\n"

/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = "attribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec2 v_texCoord;\nvarying vec4 v_color;\nuniform mat3 u_projMatrix;\n\nvoid main() {\n  gl_Position = vec4((u_projMatrix * vec3(a_position, 1)).xy, 0, 1);\n  v_texCoord = a_texCoord;\n  v_color = vec4(a_color.rgb * a_color.a, a_color.a);\n}\n"

/***/ },
/* 209 */
/***/ function(module, exports) {

	module.exports = "/*!\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n */\n\nprecision mediump float;\nuniform sampler2D u_image;\nuniform float u_blurRadius;\nuniform float u_gradientSize;\nuniform float u_size;\nuniform vec2 u_start;\nuniform vec2 u_end;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n    vec2 normal = normalize(vec2(u_start.y - u_end.y, u_end.x - u_start.x));\n    float radius = smoothstep(0.0, 1.0,\n      (abs(\n        dot(v_texCoord * u_texSize - u_start, normal)\n      ) - u_size) / u_gradientSize\n    ) * u_blurRadius;\n\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"

/***/ },
/* 210 */
/***/ function(module, exports) {

	module.exports = "/*!\n * Based on evanw's glfx.js tilt shift shader:\n * https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js\n */\n\nprecision mediump float;\nuniform sampler2D u_image;\nuniform float u_radius;\nuniform float u_blurRadius;\nuniform float u_gradientRadius;\nuniform vec2 u_position;\nuniform vec2 u_delta;\nuniform vec2 u_texSize;\nvarying vec2 v_texCoord;\n\nfloat random(vec3 scale, float seed) {\n  return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    float radius = smoothstep(\n      0.0, 1.0,\n      (abs(\n        distance(v_texCoord * u_texSize, u_position)\n      ) - u_radius) / (u_gradientRadius * 2.0)\n    ) * u_blurRadius;\n    for (float t = -30.0; t <= 30.0; t++) {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture2D(u_image, v_texCoord + u_delta * percent * radius / u_texSize);\n\n        sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n    }\n\n    gl_FragColor = color / total;\n    gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n}\n"

/***/ },
/* 211 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\nuniform float u_saturation;\nuniform float u_contrast;\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec4 color = texColor;\n\n  // Apply brightness\n  color.rgb = (color.rgb + u_brightness);\n\n  // Apply saturation\n  float luminance = dot(color.rgb, luminanceWeighting);\n  vec3 greyScaleColor = vec3(luminance);\n  color.rgb = mix(greyScaleColor, color.rgb, u_saturation);\n\n  // Apply contrast\n  color.rgb = (color.rgb - 0.5) * u_contrast + 0.5;\n\n  // Apply alpha\n  color = vec4(color.rgb * texColor.a, texColor.a);\n\n  gl_FragColor = color;\n}\n"

/***/ },
/* 212 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_filteredImage;\nuniform float u_intensity;\n\nvoid main() {\n  vec4 color0 = texture2D(u_image, v_texCoord);\n  vec4 color1 = texture2D(u_filteredImage, v_texCoord);\n  gl_FragColor = mix(color0, color1, u_intensity);\n}\n"

/***/ },
/* 213 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_frameImage;\nuniform vec4 u_color;\nuniform float u_thickness;\nuniform vec2 u_textureSize;\n\nvoid main() {\n  vec4 fragColor = texture2D(u_image, v_texCoord);\n  float scaledThicknessX = u_thickness / u_textureSize.x;\n  float scaledThicknessY = u_thickness / u_textureSize.y;\n  if (v_texCoord.x < scaledThicknessX ||\n    v_texCoord.x > 1.0 - scaledThicknessX ||\n    v_texCoord.y < scaledThicknessY || v_texCoord.y > 1.0 - scaledThicknessY) {\n      fragColor = mix(fragColor, u_color, u_color.a);\n    }\n\n  gl_FragColor = fragColor;\n}\n"

/***/ },
/* 214 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_brightness;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4((texColor.rgb + vec3(u_brightness) * texColor.a), texColor.a);;\n}\n"

/***/ },
/* 215 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_contrast;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5) * texColor.a), texColor.a);\n}\n"

/***/ },
/* 216 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_desaturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n  vec3 gray = vec3(dot(grayXfer, texColor.xyz));\n  gl_FragColor = vec4(mix(texColor.xyz, gray, u_desaturation) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 217 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n\n  vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n  textureCoord /= 0.75;\n\n  float d = 1.0 - dot(textureCoord, textureCoord);\n  d = clamp(d, 0.2, 1.0);\n  vec3 newColor = texColor.rgb * d * u_color.rgb;\n  gl_FragColor = vec4(vec3(newColor) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 218 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  texColor.b = texColor.g * 0.33;\n  texColor.r = texColor.r * 0.6;\n  texColor.b += texColor.r * 0.33;\n  texColor.g = texColor.g * 0.7;\n  gl_FragColor = texColor;\n}\n"

/***/ },
/* 219 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nvec3 W = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, W);\n  gl_FragColor = vec4(vec3(luminance) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 220 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform sampler2D u_lookupTable;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n  float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n  float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n  gl_FragColor = vec4(vec3(r, g, b) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 221 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform float u_saturation;\n\nconst vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float luminance = dot(texColor.rgb, luminanceWeighting);\n\n  vec3 greyScaleColor = vec3(luminance);\n\n  gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation) * texColor.a, texColor.a);\n}\n"

/***/ },
/* 222 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\nuniform vec3 u_color;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  vec4 overlayVec4 = vec4(u_color, texColor.a);\n  gl_FragColor = max(overlayVec4 * texColor.a, texColor);\n}\n"

/***/ },
/* 223 */
/***/ function(module, exports) {

	module.exports = "precision mediump float;\nvarying vec2 v_texCoord;\nuniform sampler2D u_image;\n\nvoid main() {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n  gray -= 0.2;\n  gray = clamp(gray, 0.0, 1.0);\n  gray += 0.15;\n  gray *= 1.4;\n  gl_FragColor = vec4(vec3(gray) * texColor.a, texColor.a);\n}\n"

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2YTgxODlhMjA3NzU2ZTc4NGRhMiIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL2xpYi9jb2xvci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjYW52YXNcIiIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovLy8uL2xpYi9ldmVudC1lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbWF0aC92ZWN0b3IyLmpzIiwid2VicGFjazovLy8uLi9zaGFyZWQvbG9nLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImdsXCIiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL2VuZ2luZS91dGlscy93ZWJnbC1yZW5kZXItdGFyZ2V0LmpzIiwid2VicGFjazovLy8uL2xpYi9jb25maWd1cmFibGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZXhpZi5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvZGlzcGxheS9kaXNwbGF5LW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvbWFuYWdlcnMvY2FudmFzLWZpbHRlci1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhZGVycy9zaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3NoYWRlcnMvdGV4dHVyZS1zaGFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3RleHR1cmVzL2Jhc2UtdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3ByaXRlLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9saWIvbWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvb3BlcmF0aW9ucy1zdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2luZGV4LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9wYWNrYWdlLmpzb24iLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL2Rpc3BsYXkvY29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXJlcnMvYmFzZS1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvcmVuZGVyZXJzL3dlYmdsL29iamVjdC1yZW5kZXJlcnMvb2JqZWN0LXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS90ZXh0dXJlcy90ZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS91dGlscy9jb250ZXh0LXBlcmZvcm1hbmNlLWhvb2suanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL3BpeGVsLWFycmF5LWltYWdlLmpzIiwid2VicGFjazovLy8uL2xpYi9leHRlbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hdGgvbWF0cml4LmpzIiwid2VicGFjazovLy8uL2xpYi9tYXRoL3JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcGVyZm9ybWFuY2UtdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2FkanVzdG1lbnRzL2FkanVzdG1lbnRzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2JydXNoL2NvbnRyb2wtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2lkZW50aXR5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL3N0YWNrLWJsdXIuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3BlcmZvcm1hbmNlLW5vdy9saWIvcGVyZm9ybWFuY2Utbm93LmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zZGsuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL2ZpbHRlcnMvZmlsdGVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXJlcnMvY2FudmFzL2NhbnZhcy1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvcmVuZGVyZXJzL3dlYmdsL29iamVjdC1yZW5kZXJlcnMvc3ByaXRlLXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS9yZW5kZXJlcnMvd2ViZ2wvd2ViZ2wtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3NoYWRlcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3Nwcml0ZXMvc3ByaXRlLmpzIiwid2VicGFjazovLy8uL2VuZ2luZS90ZXh0dXJlcy9yZW5kZXItdGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdXRpbHMvcXVhZC5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvdXRpbHMvdGV4dHVyZS11dnMuanMiLCJ3ZWJwYWNrOi8vLy4vZW5naW5lL3V0aWxzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL2luZGV4LmpzIiwid2VicGFjazovLy8uL2xpYi9hcnJheS1zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2ltYWdlLWV4cG9ydGVyLmpzIiwid2VicGFjazovLy8uL2xpYi9ub2RlLWdsLWV4cG9ydGVyLmpzIiwid2VicGFjazovLy8uL2xpYi92ZXJzaW9uLWNoZWNrZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9ib3JkZXItb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvYnJ1c2gtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvYnJ1c2gvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVyLW9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvYTE1LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnJlZXplLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnctZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9id2hhcmQtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9jZWxzaXVzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2hlc3QtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9maXhpZS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2Zvb2QtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9mcmlkZ2UtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9mcm9udC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2dsYW0tZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9nb2JibGluLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvazEtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9rMi1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2s2LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9sZW5pbi1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2xvbW8tZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9tZWxsb3ctZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9tb3JuaW5nLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvb3JjaGlkLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGE2NjktZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzLXN0YWNrLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2JyaWdodG5lc3MuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvY29udHJhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZGVzYXR1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ29iYmxpbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9ncmF5c2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvdG9uZS1jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy94NDAwLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9xdW96aS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3NlbWlyZWQtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9zdW5ueS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3RleGFzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMveDQwMC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9mb2N1cy9saW5lYXItZm9jdXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZm9jdXMvcmFkaWFsLWZvY3VzLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2xpbmVhci1mb2N1cy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9vcmllbnRhdGlvbi1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9yYWRpYWwtZm9jdXMtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc3ByaXRlLW9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3Nwcml0ZXMvdGV4dC90ZXh0LXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc3ByaXRlcy90ZXh0L3RleHQtc3BsaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy93YXRlcm1hcmstb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uLi9zaGFyZWQvYW5pbWF0aW9uLWZyYW1lLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2tleW9mLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovLy8vVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhZGVycy9zb3VyY2UvdGV4dHVyZS5mcmFnIiwid2VicGFjazovLy8uL2VuZ2luZS9zaGFkZXJzL3NvdXJjZS90ZXh0dXJlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9mb2N1cy9saW5lYXItZm9jdXMuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL2ZvY3VzL3JhZGlhbC1mb2N1cy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvZ2VuZXJpYy9hZGp1c3RtZW50cy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvZ2VuZXJpYy9ibGVuZC5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvb3BlcmF0aW9ucy9ib3JkZXIuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzcy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ2xvdy5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc2hhZGVycy9wcmltaXRpdmVzL2dyYXlzY2FsZS5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5mcmFnIiwid2VicGFjazovLy8uL3NoYWRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuZnJhZyIsIndlYnBhY2s6Ly8vLi9zaGFkZXJzL3ByaW1pdGl2ZXMveDQwMC5mcmFnIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO0FDVkE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3RDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ1JBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEc7Ozs7OztBQ2hDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1Q0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHOzs7Ozs7Ozs7Ozs7Ozs7O0FDREE7Ozs7Ozs7Ozs7OztLQU9NLE07QUFDSixxQkFBOEI7QUFBQSxTQUFqQixTQUFpQix5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QWdFLGtFQUFrRSxHQUFHLEc7Ozs7OztBQ0EzYywyQ0FBMEMsMEJBQTBCLDRCQUE0Qiw2QkFBNkIsaUVBQWlFLGlCQUFpQixtREFBbUQsNERBQTRELDRDQUE0QyxvR0FBb0csR0FBRyxHOzs7Ozs7QUNBamQsMkNBQTBDLDBCQUEwQiw0QkFBNEIsdUJBQXVCLGlCQUFpQixtREFBbUQsaURBQWlELDJEQUEyRCxHQUFHLEc7Ozs7OztBQ0ExUywyQ0FBMEMsMEJBQTBCLDRCQUE0QixpQkFBaUIsbURBQW1ELHdFQUF3RSxnQkFBZ0IsaUNBQWlDLGlCQUFpQixnQkFBZ0IsNkRBQTZELEdBQUcsRyIsImZpbGUiOiJQaG90b0VkaXRvclNESy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNhbnZhc1wiKSwgcmVxdWlyZShcImdsXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNhbnZhc1wiLCBcImdsXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlBob3RvRWRpdG9yU0RLXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiY2FudmFzXCIpLCByZXF1aXJlKFwiZ2xcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlBob3RvRWRpdG9yU0RLXCJdID0gZmFjdG9yeShyb290W1wiY2FudmFzXCJdLCByb290W1wiZ2xcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xN19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzI4X18pIHtcbnJldHVybiBcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cbiAqKi8iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTA2KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIDZhODE4OWEyMDc3NTZlNzg0ZGEyXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGpzaGludCB1bnVzZWQ6IGZhbHNlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUHJpbWl0aXZlc1N0YWNrIGZyb20gJy4vcHJpbWl0aXZlcy1zdGFjaydcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBmaWx0ZXJzLiBFeHRlbmRhYmxlIHZpYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRmlsdGVyI2V4dGVuZH1cbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yIChpbnRlbnNpdHkgPSAxLjApIHtcbiAgICB0aGlzLl9pbnRlbnNpdHkgPSBpbnRlbnNpdHlcbiAgICB0aGlzLl9zdGFjayA9IG5ldyBQcmltaXRpdmVzU3RhY2soaW50ZW5zaXR5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUZXh0dXJlfVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChzZGssIHJlbmRlclRleHR1cmUpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2sucmVuZGVyKHNkaywgcmVuZGVyVGV4dHVyZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbnRlbnNpdHkgdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlbnNpdHlcbiAgICovXG4gIHNldEludGVuc2l0eSAoaW50ZW5zaXR5KSB7XG4gICAgdGhpcy5faW50ZW5zaXR5ID0gaW50ZW5zaXR5XG4gICAgdGhpcy5fc3RhY2suc2V0SW50ZW5zaXR5KGludGVuc2l0eSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlcikge1xuICAgIHRoaXMuX3N0YWNrLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB0aGlzIGluc3RhbmNlIHVwXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9zdGFjay5kaXNwb3NlKClcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZpbHRlci5pZGVudGlmaWVyID0gbnVsbFxuXG4vKipcbiAqIElmIGBpc0lkZW50aXR5YCBpcyB0cnVlLCB0aGlzIGZpbHRlciBkb2VzIG5vdCBkbyBhbnl0aGluZyBhbmQgY2FuIGJlIHNlZW4gYXNcbiAqIHRoZSBkZWZhdWx0IGZpbHRlci5cbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5GaWx0ZXIuaXNJZGVudGl0eSA9IGZhbHNlXG5cbi8qKlxuICogVGhpcyBzdHJpbmcgaXMgdXNlZCBieSB0aGUgVUlcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkZpbHRlci5kaXNwbGF5TmFtZSA9IG51bGxcblxuLyoqXG4gKiBUbyBjcmVhdGUgYW4ge0BsaW5rIFBob3RvRWRpdG9yU0RLLkZpbHRlcn0gY2xhc3Mgb2YgeW91ciBvd24sIGNhbGwgdGhpc1xuICogbWV0aG9kIGFuZCBwcm92aWRlIGluc3RhbmNlIHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucy5cbiAqIEBmdW5jdGlvblxuICovXG5GaWx0ZXIuZXh0ZW5kID0gcmVxdWlyZSgnLi4vLi4vbGliL2V4dGVuZCcpXG5cbi8vIEV4cG9zZWQgY2xhc3Nlc1xuRmlsdGVyLlByaW1pdGl2ZXNTdGFjayA9IFByaW1pdGl2ZXNTdGFja1xuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogRmlsdGVyIHByaW1pdGl2ZXMgYXJlIHRoZSBjb3JlIG9mIGZpbHRlcnMuIE9uZSBmaWx0ZXIgY29uc2lzdHMgb2YgbXVsdGlwbGUgZmlsdGVyIHByaW1pdGl2ZXMuXG4gKiBGb3IgYW4gZXhhbXBsZSwgbG9vayBhdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgYSBmaWx0ZXIsIGUuZy4ge0BsaW5rIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuQTE1RmlsdGVyfVxuICogb3Igc2VlIG91ciBkb2N1bWVudGF0aW9uIGF0IHtAbGluayBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vZG9jc30uXG4gKiBAbmFtZXNwYWNlIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCcmlnaHRuZXNzIH0gZnJvbSAnLi9icmlnaHRuZXNzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDb250cmFzdCB9IGZyb20gJy4vY29udHJhc3QnXG5leHBvcnQgeyBkZWZhdWx0IGFzIERlc2F0dXJhdGlvbiB9IGZyb20gJy4vZGVzYXR1cmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHbG93IH0gZnJvbSAnLi9nbG93J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHb2JibGluIH0gZnJvbSAnLi9nb2JibGluJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmF5c2NhbGUgfSBmcm9tICcuL2dyYXlzY2FsZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9va3VwVGFibGUgfSBmcm9tICcuL2xvb2t1cC10YWJsZSdcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2F0dXJhdGlvbiB9IGZyb20gJy4vc2F0dXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU29mdENvbG9yT3ZlcmxheSB9IGZyb20gJy4vc29mdC1jb2xvci1vdmVybGF5J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUb25lQ3VydmUgfSBmcm9tICcuL3RvbmUtY3VydmUnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFg0MDAgfSBmcm9tICcuL3g0MDAnXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2luZGV4LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuL2VuZ2luZSdcblxuaW1wb3J0ICogYXMgQ29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJ1xuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vbGliL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnXG5pbXBvcnQgQ29uZmlndXJhYmxlIGZyb20gJy4vbGliL2NvbmZpZ3VyYWJsZSdcbmltcG9ydCBDb2xvciBmcm9tICcuL2xpYi9jb2xvcidcbmltcG9ydCBMb2cgZnJvbSAnLi4vc2hhcmVkL2xvZydcbmltcG9ydCBQcm9taXNlIGZyb20gJy4vdmVuZG9yL3Byb21pc2UnXG5cbmV4cG9ydCB7IHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsQW5pbWF0aW9uRnJhbWUgfSBmcm9tICcuLi9zaGFyZWQvYW5pbWF0aW9uLWZyYW1lJ1xuXG5leHBvcnQge1xuICBFbmdpbmUsXG5cbiAgRXZlbnRFbWl0dGVyLFxuICBVdGlscyxcbiAgQ29uZmlndXJhYmxlLFxuICBDb2xvcixcbiAgQ29uc3RhbnRzLFxuICBMb2csXG4gIFByb21pc2Vcbn1cblxuZXhwb3J0ICogZnJvbSAnLi9saWIvbWF0aC8nXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2dsb2JhbHMuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3NoYXJlZC9sb2cnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vbGliL2NvbG9yJ1xuaW1wb3J0IE1hdHJpeCBmcm9tICcuLi9saWIvbWF0aC9tYXRyaXgnXG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJy4uL2xpYi9tYXRoL3JlY3RhbmdsZSdcbmltcG9ydCBWZWN0b3IyIGZyb20gJy4uL2xpYi9tYXRoL3ZlY3RvcjInXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uL2xpYi9ldmVudC1lbWl0dGVyJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL2xpYi91dGlscydcblxuZXhwb3J0cy5CQVRDSF9TSVpFID0gMjAwMFxuZXhwb3J0cy5WRVJURVhfU0laRSA9IDVcbmV4cG9ydHMuVkVSVEVYX0JZVEVfU0laRSA9IGV4cG9ydHMuVkVSVEVYX1NJWkUgKiA0XG5cbmV4cG9ydHMuQ29sb3IgPSBDb2xvclxuZXhwb3J0cy5NYXRyaXggPSBNYXRyaXhcbmV4cG9ydHMuVmVjdG9yMiA9IFZlY3RvcjJcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlXG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlclxuZXhwb3J0cy5Mb2cgPSBMb2dcbmV4cG9ydHMuVXRpbHMgPSBVdGlsc1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvZ2xvYmFscy5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBDYW52YXNSZW5kZXJlciBmcm9tICcuL3JlbmRlcmVycy9jYW52YXMvY2FudmFzLXJlbmRlcmVyJ1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSAnLi9yZW5kZXJlcnMvd2ViZ2wvd2ViZ2wtcmVuZGVyZXInXG5pbXBvcnQgQ2FudmFzRmlsdGVyTWFuYWdlciBmcm9tICcuL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBXZWJHTEZpbHRlck1hbmFnZXIgZnJvbSAnLi9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gJy4vZGlzcGxheS9kaXNwbGF5LW9iamVjdCdcbmltcG9ydCBDb250YWluZXIgZnJvbSAnLi9kaXNwbGF5L2NvbnRhaW5lcidcbmltcG9ydCBCYXNlVGV4dHVyZSBmcm9tICcuL3RleHR1cmVzL2Jhc2UtdGV4dHVyZSdcbmltcG9ydCBUZXh0dXJlIGZyb20gJy4vdGV4dHVyZXMvdGV4dHVyZSdcbmltcG9ydCBSZW5kZXJUZXh0dXJlIGZyb20gJy4vdGV4dHVyZXMvcmVuZGVyLXRleHR1cmUnXG5pbXBvcnQgV2ViR0xSZW5kZXJUYXJnZXQgZnJvbSAnLi91dGlscy93ZWJnbC1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IENhbnZhc1JlbmRlclRhcmdldCBmcm9tICcuL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IFNwcml0ZSBmcm9tICcuL3Nwcml0ZXMvc3ByaXRlJ1xuaW1wb3J0IFNoYWRlcnMgZnJvbSAnLi9zaGFkZXJzLydcbmltcG9ydCBTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3NoYWRlcidcbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXJzL2ZpbHRlcidcbmltcG9ydCBQaXhlbEFycmF5SW1hZ2UgZnJvbSAnLi91dGlscy9waXhlbC1hcnJheS1pbWFnZSdcblxuLyoqXG4gKiBUaGUgaGVhcnQgb2YgUGhvdG9FZGl0b3JTREsuIEhhbmRsZXMgYWxsIHRoZSByZW5kZXJpbmcgaW4gYSBzY2VuZS1ncmFwaCBmYXNoaW9uXG4gKiBAbmFtZXNwYWNlIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jb25zdCBFbmdpbmUgPSB7XG4gIFdlYkdMUmVuZGVyZXIsXG4gIENhbnZhc1JlbmRlcmVyLFxuICBXZWJHTEZpbHRlck1hbmFnZXIsXG4gIENhbnZhc0ZpbHRlck1hbmFnZXIsXG4gIERpc3BsYXlPYmplY3QsXG4gIENvbnRhaW5lcixcbiAgQmFzZVRleHR1cmUsXG4gIFRleHR1cmUsXG4gIFJlbmRlclRleHR1cmUsXG4gIFdlYkdMUmVuZGVyVGFyZ2V0LFxuICBDYW52YXNSZW5kZXJUYXJnZXQsXG4gIFNwcml0ZSxcbiAgU2hhZGVycyxcbiAgU2hhZGVyLFxuICBGaWx0ZXIsXG4gIFBpeGVsQXJyYXlJbWFnZSxcblxuICAvKipcbiAgICogSWYgV2ViR0wgaXMgc3VwcG9ydGVkLCB0aGlzIHJldHVybnMgYSBXZWJHTFJlbmRlcmVyIGFuZCBmYWxscyBiYWNrIHRvIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucyA9IHt9IF1cbiAgICogQHJldHVybiB7KFBob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfFBob3RvRWRpdG9yU0RLLkVuZ2luZS5DYW52YXNSZW5kZXJlcil9XG4gICAqL1xuICBhdXRvRGV0ZWN0UmVuZGVyZXI6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoV2ViR0xSZW5kZXJlci5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICByZXR1cm4gbmV3IFdlYkdMUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgb3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDYW52YXNSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbmdpbmVcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL2luZGV4LmpzXG4gKiovIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIVxuICogTmF0aXZlIFByb21pc2UgT25seVxuICogdjAuOC4wLWEgKGMpIEt5bGUgU2ltcHNvblxuICogTUlUIExpY2Vuc2U6IGh0dHA6Ly9nZXRpZnkubWl0LWxpY2Vuc2Uub3JnXG4gKiBAbGljZW5zZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG4gIC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuICBjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG4gIGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRleHRbbmFtZV07XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAkQU1EJCgpeyByZXR1cm4gY29udGV4dFtuYW1lXTsgfSk7XG4gIH1cbn0pKFwiUHJvbWlzZVwiLHR5cGVvZiBnbG9iYWwgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMsZnVuY3Rpb24gREVGKCl7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBidWlsdEluUHJvcCwgY3ljbGUsIHNjaGVkdWxpbmdfcXVldWUsXG4gICAgVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgIHRpbWVyID0gKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT0gXCJ1bmRlZmluZWRcIikgP1xuICAgICAgZnVuY3Rpb24gdGltZXIoZm4pIHsgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7IH0gOlxuICAgICAgc2V0VGltZW91dFxuICA7XG5cbiAgLy8gZGFtbWl0LCBJRTguXG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LFwieFwiLHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLG5hbWUse1xuICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBjb25maWcgIT09IGZhbHNlXG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGNhdGNoIChlcnIpIHtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuICAgICAgb2JqW25hbWVdID0gdmFsO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9XG5cbiAgLy8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG4gIHNjaGVkdWxpbmdfcXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG4gICAgZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgICB0aGlzLnNlbGYgPSBzZWxmO1xuICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChmbixzZWxmKSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICBsYXN0Lm5leHQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0ID0gaXRlbTtcbiAgICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICBkcmFpbjogZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgICAgIHZhciBmID0gZmlyc3Q7XG4gICAgICAgIGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG4gICAgICAgIHdoaWxlIChmKSB7XG4gICAgICAgICAgZi5mbi5jYWxsKGYuc2VsZik7XG4gICAgICAgICAgZiA9IGYubmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuICAgIHNjaGVkdWxpbmdfcXVldWUuYWRkKGZuLHNlbGYpO1xuICAgIGlmICghY3ljbGUpIHtcbiAgICAgIGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ19xdWV1ZS5kcmFpbik7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuICBmdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sIG9fdHlwZSA9IHR5cGVvZiBvO1xuXG4gICAgaWYgKG8gIT0gbnVsbCAmJlxuICAgICAgKFxuICAgICAgICBvX3R5cGUgPT0gXCJvYmplY3RcIiB8fCBvX3R5cGUgPT0gXCJmdW5jdGlvblwiXG4gICAgICApXG4gICAgKSB7XG4gICAgICBfdGhlbiA9IG8udGhlbjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBfdGhlbiA9PSBcImZ1bmN0aW9uXCIgPyBfdGhlbiA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3RpZnlJc29sYXRlZChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgKHRoaXMuc3RhdGUgPT09IDEpID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLFxuICAgICAgICB0aGlzLmNoYWluW2ldXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNoYWluLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvLyBOT1RFOiBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gaXNvbGF0ZVxuICAvLyB0aGUgYHRyeS4uY2F0Y2hgIHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gYmVcbiAgLy8gb3B0aW1pemVkIGJldHRlclxuICBmdW5jdGlvbiBub3RpZnlJc29sYXRlZChzZWxmLGNiLGNoYWluKSB7XG4gICAgdmFyIHJldCwgX3RoZW47XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2IgPT09IHRydWUpIHtcbiAgICAgICAgICByZXQgPSBzZWxmLm1zZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXQgPSBjYi5jYWxsKHZvaWQgMCxzZWxmLm1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG4gICAgICAgICAgY2hhaW4ucmVqZWN0KFR5cGVFcnJvcihcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgX3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNoYWluLnJlc29sdmUocmV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICBjaGFpbi5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG4gICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIGRlZl93cmFwcGVyID0gbmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdGhlbi5jYWxsKG1zZyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmUkKCl7IHJlc29sdmUuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfSxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlamVjdCQoKXsgcmVqZWN0LmFwcGx5KGRlZl93cmFwcGVyLGFyZ3VtZW50cyk7IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZl93cmFwcGVyLGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGYubXNnID0gbXNnO1xuICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICByZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3QobXNnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICBzZWxmID0gc2VsZi5kZWY7XG4gICAgfVxuXG4gICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgc2VsZi5zdGF0ZSA9IDI7XG4gICAgaWYgKHNlbGYuY2hhaW4ubGVuZ3RoID4gMCkge1xuICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIscmVzb2x2ZXIscmVqZWN0ZXIpIHtcbiAgICBmb3IgKHZhciBpZHg9MDsgaWR4PGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAoZnVuY3Rpb24gSUlGRShpZHgpe1xuICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGFycltpZHhdKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZXIkKG1zZyl7XG4gICAgICAgICAgICByZXNvbHZlcihpZHgsbXNnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlamVjdGVyXG4gICAgICAgICk7XG4gICAgICB9KShpZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIE1ha2VEZWZXcmFwcGVyKHNlbGYpIHtcbiAgICB0aGlzLmRlZiA9IHNlbGY7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuICAgIHRoaXMucHJvbWlzZSA9IHNlbGY7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoYWluID0gW107XG4gICAgdGhpcy5tc2cgPSB2b2lkIDA7XG4gIH1cblxuICBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fTlBPX18gIT09IDApIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIHByb21pc2VcIik7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFuY2Ugc2hhZG93aW5nIHRoZSBpbmhlcml0ZWQgXCJicmFuZFwiXG4gICAgLy8gdG8gc2lnbmFsIGFuIGFscmVhZHkgXCJpbml0aWFsaXplZFwiIHByb21pc2VcbiAgICB0aGlzLl9fTlBPX18gPSAxO1xuXG4gICAgdmFyIGRlZiA9IG5ldyBNYWtlRGVmKHRoaXMpO1xuXG4gICAgdGhpc1tcInRoZW5cIl0gPSBmdW5jdGlvbiB0aGVuKHN1Y2Nlc3MsZmFpbHVyZSkge1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09IFwiZnVuY3Rpb25cIiA/IHN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PSBcImZ1bmN0aW9uXCIgPyBmYWlsdXJlIDogZmFsc2VcbiAgICAgIH07XG4gICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgIG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cblxuICAgICAgICBvLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBvLnJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgZGVmLmNoYWluLnB1c2gobyk7XG5cbiAgICAgIGlmIChkZWYuc3RhdGUgIT09IDApIHtcbiAgICAgICAgc2NoZWR1bGUobm90aWZ5LGRlZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvLnByb21pc2U7XG4gICAgfTtcbiAgICB0aGlzW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAkY2F0Y2gkKGZhaWx1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odm9pZCAwLGZhaWx1cmUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IuY2FsbChcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZXNvbHZlKG1zZyl7XG4gICAgICAgICAgcmVzb2x2ZS5jYWxsKGRlZixtc2cpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG4gICAgICAgICAgcmVqZWN0LmNhbGwoZGVmLG1zZyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdC5jYWxsKGRlZixlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sXCJjb25zdHJ1Y3RvclwiLFByb21pc2UsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuICApO1xuXG4gIC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG4gIFByb21pc2UucHJvdG90eXBlID0gUHJvbWlzZVByb3RvdHlwZTtcblxuICAvLyBidWlsdC1pbiBcImJyYW5kXCIgdG8gc2lnbmFsIGFuIFwidW5pbml0aWFsaXplZFwiIHByb21pc2VcbiAgYnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSxcIl9fTlBPX19cIiwwLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2VcbiAgKTtcblxuICBidWlsdEluUHJvcChQcm9taXNlLFwicmVzb2x2ZVwiLGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICAvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG4gICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnLl9fTlBPX18gPT09IDEpIHtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKG1zZyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZWplY3RcIixmdW5jdGlvbiBQcm9taXNlJHJlamVjdChtc2cpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG1zZyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJhbGxcIixmdW5jdGlvbiBQcm9taXNlJGFsbChhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoXCJOb3QgYW4gYXJyYXlcIikpO1xuICAgIH1cbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cbiAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZykge1xuICAgICAgICBtc2dzW2lkeF0gPSBtc2c7XG4gICAgICAgIGlmICgrK2NvdW50ID09PSBsZW4pIHtcbiAgICAgICAgICByZXNvbHZlKG1zZ3MpO1xuICAgICAgICB9XG4gICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyYWNlXCIsZnVuY3Rpb24gUHJvbWlzZSRyYWNlKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlO1xufSk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3ZlbmRvci9wcm9taXNlLmpzXG4gKiovIiwiLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuLyoganNoaW50IC1XMDgzICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgUHJvbWlzZSBmcm9tICcuLi92ZW5kb3IvcHJvbWlzZSdcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vc2hhcmVkL2xvZydcbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vZW5naW5lLydcbmltcG9ydCBDb25maWd1cmFibGUgZnJvbSAnLi4vbGliL2NvbmZpZ3VyYWJsZSdcbmltcG9ydCBQZXJmb3JtYW5jZVRlc3QgZnJvbSAnLi4vbGliL3BlcmZvcm1hbmNlLXRlc3QnXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgT3BlcmF0aW9uc1xuICogQGNsYXNzXG4gKiBAYWxpYXMgT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5Db25maWd1cmFibGVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBPcGVyYXRpb24gZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHNkaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucywge1xuICAgICAgZW5hYmxlZDogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IHRydWUgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9zZGsgPSBzZGtcbiAgICB0aGlzLl9kaXJ0aW5lc3MgPSB7fVxuXG4gICAgdGhpcy5fc3ByaXRlID0gbmV3IEVuZ2luZS5TcHJpdGUoKVxuICAgIHRoaXMuX2NvbnRhaW5lciA9IG5ldyBFbmdpbmUuQ29udGFpbmVyKClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fc3ByaXRlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZC4gU2V0cyB0aGlzIG9wZXJhdGlvbiB0byBkaXJ0eS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wdGlvbnNDaGFuZ2UgKCkge1xuICAgIHRoaXMuc2V0RGlydHkodHJ1ZSlcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgcmVuZGVyIHRleHR1cmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2dldFJlbmRlclRleHR1cmUgKHNkaykge1xuICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZSA9IHNkay5jcmVhdGVSZW5kZXJUZXh0dXJlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmVcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICByZW5kZXIgKHNkaykge1xuICAgIGlmICghdGhpcy5nZXRFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyID0gc2RrLmdldFJlbmRlcmVyKClcbiAgICBsZXQgcHJvbWlzZVxuICAgIGxldCBwZXJmXG4gICAgaWYgKExvZy5jYW5Mb2coJ2luZm8nKSkge1xuICAgICAgcGVyZiA9IG5ldyBQZXJmb3JtYW5jZVRlc3QodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnUmVuZGVyaW5nJylcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2FjaGluZ1xuICAgIGlmICh0aGlzLmlzRGlydHlGb3JSZW5kZXJlcihyZW5kZXJlcikpIHtcbiAgICAgIHByb21pc2UgPSB0aGlzLl9yZW5kZXIoc2RrKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXREaXJ0eUZvclJlbmRlcmVyKGZhbHNlLCByZW5kZXJlcilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnUmVuZGVyaW5nIGZyb20gY2FjaGUnKVxuICAgICAgcHJvbWlzZSA9IHRoaXMucmVuZGVyQ2FjaGVkKHNkaylcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAocGVyZikgcGVyZi5zdG9wKClcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY2FjaGVkIHZlcnNpb24gb2YgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyQ2FjaGVkIChzZGspIHtcbiAgICBjb25zdCBvdXRwdXRTcHJpdGUgPSBzZGsuZ2V0U3ByaXRlKClcbiAgICBvdXRwdXRTcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaykpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICBsZXQgcmVuZGVyRm5cbiAgICBpZiAoc2RrLmdldFJlbmRlcmVyKCkgaW5zdGFuY2VvZiBFbmdpbmUuV2ViR0xSZW5kZXJlcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHJlbmRlckZuID0gdGhpcy5fcmVuZGVyV2ViR0wuYmluZCh0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW5kZXJGbiA9IHRoaXMuX3JlbmRlckNhbnZhcy5iaW5kKHRoaXMpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlckZuKHNkaylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgb3BlcmF0aW9uIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfcmVuZGVyV2ViR0wgKHNkaykge1xuICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uI19yZW5kZXJXZWJHTCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcy4nKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb24gdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfcmVuZGVyQ2FudmFzIChzZGspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiNfcmVuZGVyQ2FudmFzIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyB0aGF0IGFuIGltYWdlIHdpdGggdGhlIGdpdmVuIGBkaW1lbnNpb25zYFxuICAgKiB3b3VsZCBoYXZlIGFmdGVyIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGFwcGxpZWRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldE5ld0RpbWVuc2lvbnMgKGRpbWVuc2lvbnMpIHtcbiAgICByZXR1cm4gZGltZW5zaW9ucy5jbG9uZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgdGhpcy5fZGlydHkgPSB0cnVlXG4gICAgdGhpcy5fZ2xzbFByb2dyYW1zID0ge31cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERJUlRJTkVTU1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBvcGVyYXRpb24gaXMgZGlydHkgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSAgcmVuZGVyZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRGlydHlGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICBpZiAoIShyZW5kZXJlci5pZCBpbiB0aGlzLl9kaXJ0aW5lc3MpKSB7XG4gICAgICB0aGlzLl9kaXJ0aW5lc3NbcmVuZGVyZXIuaWRdID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgc2V0RGlydHlGb3JSZW5kZXJlciAoZGlydHksIHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXSA9IGRpcnR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciBhbGwgcmVuZGVyZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICovXG4gIHNldERpcnR5IChkaXJ0eSkge1xuICAgIGZvciAobGV0IHJlbmRlcmVySWQgaW4gdGhpcy5fZGlydGluZXNzKSB7XG4gICAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHsgaWQ6IHJlbmRlcmVySWQgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhlIFJlbmRlclRleHR1cmVcbiAgICovXG4gIGRpc3Bvc2VSZW5kZXJUZXh0dXJlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcblxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuT3BlcmF0aW9uLmlkZW50aWZpZXIgPSBudWxsXG5cbi8qKlxuICogVG8gY3JlYXRlIGFuIHtAbGluayBQaG90b0VkaXRvclNESy5PcGVyYXRpb259IGNsYXNzIG9mIHlvdXIgb3duLCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBhbmQgcHJvdmlkZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXG4gKiBAZnVuY3Rpb25cbiAqL1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi9saWIvZXh0ZW5kJ1xuT3BlcmF0aW9uLmV4dGVuZCA9IGV4dGVuZFxuXG5leHBvcnQgZGVmYXVsdCBPcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9vcGVyYXRpb24uanNcbiAqKi8iLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENvbmZpZ3VyYWJsZSBmcm9tICcuLi8uLi8uLi9saWIvY29uZmlndXJhYmxlJ1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGZpbHRlciBwcmltaXRpdmVzLlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBQcmltaXRpdmUgZXh0ZW5kcyBDb25maWd1cmFibGUge1xuICAvKipcbiAgICogR2V0cyBjYWxsZWQgYmVmb3JlIHRoaXMgcHJpbWl0aXZlJ3MgZmlsdGVyIGlzIGJlaW5nIGFwcGxpZWRcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmVcbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1dlYkdMVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwYXJhbSAge1dlYkdMRnJhbWVidWZmZXJ9IG91dHB1dEZCT1xuICAgKiBAcGFyYW0gIHtXZWJHTFRleHR1cmV9IG91dHB1dFRleHR1cmVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHJlbmRlciAocmVuZGVyZXIsIGlucHV0VGV4dHVyZSwgb3V0cHV0RkJPLCBvdXRwdXRUZXh0dXJlKSB7XG4gICAgaWYgKHJlbmRlcmVyLmlkZW50aWZpZXIgPT09ICd3ZWJnbCcpIHtcbiAgICAgIHRoaXMucmVuZGVyV2ViR0wocmVuZGVyZXIsIGlucHV0VGV4dHVyZSwgb3V0cHV0RkJPLCBvdXRwdXRUZXh0dXJlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlckNhbnZhcyhyZW5kZXJlcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1dlYkdMVGV4dHVyZX0gaW5wdXRUZXh0dXJlXG4gICAqIEBwYXJhbSAge1dlYkdMRnJhbWVidWZmZXJ9IG91dHB1dEZCT1xuICAgKiBAcGFyYW0gIHtXZWJHTFRleHR1cmV9IG91dHB1dFRleHR1cmVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlbmRlcldlYkdMIChyZW5kZXJlciwgaW5wdXRUZXh0dXJlLCBvdXRwdXRGQk8sIG91dHB1dFRleHR1cmUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IG5ldyBFcnJvcignUHJpbWl0aXZlI3JlbmRlcldlYkdMIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChDYW52YXMyRClcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICByZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1pdGl2ZSNyZW5kZXJDYW52YXMgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgcHJpbWl0aXZlJ3MgZmlsdGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJ9XG4gICAqL1xuICBnZXRGaWx0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9maWx0ZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcikge1xuICAgICAgdGhpcy5fZmlsdGVyLmRpc3Bvc2UoKVxuICAgICAgdGhpcy5fZmlsdGVyID0gbnVsbFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmltaXRpdmVcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvcHJpbWl0aXZlLmpzXG4gKiovIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb2xvclxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqL1xuY2xhc3MgQ29sb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbG9yXG4gICAqIEBwYXJhbSAge051bWJlcn0gclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGdcbiAgICogQHBhcmFtICB7TnVtYmVyfSBiXG4gICAqIEBwYXJhbSAge051bWJlcn0gW2EgPSAxXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHIsIGcsIGIsIGEgPSAxLjApIHtcbiAgICB0aGlzLnIgPSByXG4gICAgdGhpcy5nID0gZ1xuICAgIHRoaXMuYiA9IGJcbiAgICB0aGlzLmEgPSBhXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiByZ2JhKCkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb2xvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1JHQkEgKCkge1xuICAgIHZhciBjb2xvcnMgPSBbXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSksXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSksXG4gICAgICB0aGlzLmFcbiAgICBdXG4gICAgcmV0dXJuICdyZ2JhKCcgKyBjb2xvcnMuam9pbignLCcpICsgJyknXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvSGV4ICgpIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtcbiAgICAgIHRoaXMuX2NvbXBvbmVudFRvSGV4KE1hdGgucm91bmQodGhpcy5yICogMjU1KSksXG4gICAgICB0aGlzLl9jb21wb25lbnRUb0hleChNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSkpLFxuICAgICAgdGhpcy5fY29tcG9uZW50VG9IZXgoTWF0aC5yb3VuZCh0aGlzLmIgKiAyNTUpKVxuICAgIF1cbiAgICByZXR1cm4gJyMnICsgY29tcG9uZW50cy5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCA0IHZhbHVlcyAoMC4uLjEpXG4gICAqIEByZXR1cm4ge051bWJlcltdfVxuICAgKi9cbiAgdG9HTENvbG9yICgpIHtcbiAgICByZXR1cm4gW3RoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYV1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggMyB2YWx1ZXMgKDAuLi4xKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJbXX1cbiAgICovXG4gIHRvUkdCR0xDb2xvciAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBSR0IgdmFsdWUgdG8gSFNWXG4gICAqIEByZXR1cm4ge051bWJlcltdfVxuICAgKi9cbiAgdG9IU1YgKCkge1xuICAgIGxldCBtYXggPSBNYXRoLm1heCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKVxuICAgIGxldCBtaW4gPSBNYXRoLm1pbih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKVxuICAgIGxldCBoXG4gICAgbGV0IHNcbiAgICBsZXQgdiA9IG1heFxuICAgIGxldCBkID0gbWF4IC0gbWluXG4gICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSAwIC8vIGFjaHJvbWF0aWNcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgY2FzZSB0aGlzLnI6XG4gICAgICAgICAgaCA9ICh0aGlzLmcgLSB0aGlzLmIpIC8gZFxuICAgICAgICAgIGlmICh0aGlzLmcgPCB0aGlzLmIpIHtcbiAgICAgICAgICAgIGggKz0gNlxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIHRoaXMuZzpcbiAgICAgICAgICBoID0gKHRoaXMuYiAtIHRoaXMucikgLyBkICsgMlxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgdGhpcy5iOlxuICAgICAgICAgIGggPSAodGhpcy5yIC0gdGhpcy5nKSAvIGQgKyA0XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGggLz0gNlxuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgdl1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIFJHQkEgY29sb3IgZnJvbSB0aGUgZ2l2ZW4gSFNWIGFuZCBhbHBoYSB2YWx1ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthID0gMV1cbiAgICovXG4gIHN0YXRpYyBmcm9tSFNWIChoLCBzLCB2LCBhID0gMSkge1xuICAgIGxldCBbciwgZywgYl0gPSBbXVxuXG4gICAgbGV0IGkgPSBNYXRoLmZsb29yKGggKiA2KVxuICAgIGxldCBmID0gaCAqIDYgLSBpXG4gICAgbGV0IHAgPSB2ICogKDEgLSBzKVxuICAgIGxldCBxID0gdiAqICgxIC0gZiAqIHMpXG4gICAgbGV0IHQgPSB2ICogKDEgLSAoMSAtIGYpICogcylcblxuICAgIHN3aXRjaCAoaSAlIDYpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgciA9IHZcbiAgICAgICAgZyA9IHRcbiAgICAgICAgYiA9IHBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgciA9IHFcbiAgICAgICAgZyA9IHZcbiAgICAgICAgYiA9IHBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHBcbiAgICAgICAgZyA9IHZcbiAgICAgICAgYiA9IHRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgciA9IHBcbiAgICAgICAgZyA9IHFcbiAgICAgICAgYiA9IHZcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgciA9IHRcbiAgICAgICAgZyA9IHBcbiAgICAgICAgYiA9IHZcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHZcbiAgICAgICAgZyA9IHBcbiAgICAgICAgYiA9IHFcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigpXG4gICAgY29sb3IuciA9IHJcbiAgICBjb2xvci5nID0gZ1xuICAgIGNvbG9yLmIgPSBiXG4gICAgY29sb3IuYSA9IGFcbiAgICByZXR1cm4gY29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuQ29sb3J9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgY29sb3IgZXF1YWxzIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuQ29sb3J9IGNvbG9yXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMgKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuciA9PT0gY29sb3IuciAmJlxuICAgICAgdGhpcy5nID09PSBjb2xvci5nICYmXG4gICAgICB0aGlzLmIgPT09IGNvbG9yLmIgJiZcbiAgICAgIHRoaXMuYSA9PT0gY29sb3IuYVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIG51bWJlciBhcyBoZXhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBjb21wb25lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXBvbmVudFRvSGV4IChjb21wb25lbnQpIHtcbiAgICB2YXIgaGV4ID0gY29tcG9uZW50LnRvU3RyaW5nKDE2KVxuICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29sb3JcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gYENvbG9yKCR7dGhpcy5yfSwgJHt0aGlzLmd9LCAke3RoaXMuYn0sICR7dGhpcy5hfSlgXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLkNvbG9yfVxuICAgKi9cbiAgc3RhdGljIGdldCBUUkFOU1BBUkVOVCAoKSB7IHJldHVybiBuZXcgQ29sb3IoMCwgMCwgMCwgMCkgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7UGhvdG9FZGl0b3JTREsuQ29sb3J9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFdISVRFICgpIHsgcmV0dXJuIG5ldyBDb2xvcigxLCAxLCAxLCAxKSB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtQaG90b0VkaXRvclNESy5Db2xvcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgQkxBQ0sgKCkgeyByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDEpIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sb3JcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2NvbG9yLmpzXG4gKiovIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4gKiogbW9kdWxlIGlkID0gMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBhbk9iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgdG9QcmltaXRpdmUgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGRQICAgICAgICAgICAgID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyl7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZignZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKU9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTdfXztcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIGV4dGVybmFsIFwiY2FudmFzXCJcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi4zLjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogRXZlbnRFbWl0dGVyIChFUzYpIGZyb206XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ibG9vZHlvd2wvNDFiMWRlMzM4OGM2MjY3OTZlY2FcbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL3NoYXJlZC9sb2cnXG5jb25zdCBERUZBVUxUX01BWF9MSVNURU5FUlMgPSAxMlxuXG4vKipcbiAqIFJlY2VpdmVzIGFuZCBlbWl0cyBldmVudHNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEV2ZW50RW1pdHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX21heExpc3RlbmVycyA9IERFRkFVTFRfTUFYX0xJU1RFTkVSU1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9XG4gICAgdGhpcy5fcGlwZURlc3RpbmF0aW9ucyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUGlwZXMgYWxsIGV2ZW50cyB0byB0aGUgZ2l2ZW4gRXZlbnRFbWl0dGVyXG4gICAqIEBwYXJhbSAge0V2ZW50RW1pdHRlcn0gZGVzdGluYXRpb25cbiAgICovXG4gIHBpcGVFdmVudHMgKGRlc3RpbmF0aW9uKSB7XG4gICAgdGhpcy5fcGlwZURlc3RpbmF0aW9ucy5wdXNoKGRlc3RpbmF0aW9uKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHBpcGluZyBldmVudHMgdG8gdGhlIGdpdmVuIEV2ZW50RW1pdHRlclxuICAgKiBAcGFyYW0gIHtFdmVudEVtaXR0ZXJ9IGRlc3RpbmF0aW9uXG4gICAqL1xuICB1bnBpcGVFdmVudHMgKGRlc3RpbmF0aW9uKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3BpcGVEZXN0aW5hdGlvbnMuaW5kZXhPZihkZXN0aW5hdGlvbilcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9waXBlRGVzdGluYXRpb25zLnNwbGljZShpLCAxKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGxpc3RlbmVyIHRvIHRoZSBnaXZlbiB0eXBlIG9mIGV2ZW50c1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAqL1xuICBvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKClcbiAgICB9XG5cbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8ICh0aGlzLl9ldmVudHNbdHlwZV0gPSBbXSlcbiAgICBpZiAobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IHRoaXMuX21heExpc3RlbmVycykge1xuICAgICAgTG9nLndhcm4oJ0V2ZW50RW1pdHRlcicsXG4gICAgICAgIGBQb3NzaWJsZSBtZW1vcnkgbGVhayBkZXRlY3RlZCwgYWRkZWQgJHtsaXN0ZW5lcnMubGVuZ3RofSBcXGAke3R5cGV9XFxgIGxpc3RlbmVycyAoY3VycmVudCBsaW1pdCBpcyAke3RoaXMuX21heExpc3RlbmVyc30pYFxuICAgICAgKVxuICAgICAgY29uc29sZS50cmFjZSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gbGlzdGVuZXIgdG8gdGhlIGdpdmVuIHR5cGUgb2YgZXZlbnRzIGFuZCByZW1vdmVzIGl0XG4gICAqIG9uY2UgaXQgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICovXG4gIG9uY2UgKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgbGV0IGV2ZW50c0luc3RhbmNlID0gdGhpc1xuICAgIGZ1bmN0aW9uIG9uY2VDYWxsYmFjayAoKSB7XG4gICAgICBldmVudHNJbnN0YW5jZS5vZmYodHlwZSwgb25jZUNhbGxiYWNrKVxuICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vbih0eXBlLCBvbmNlQ2FsbGJhY2spXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gbGlzdGVuZXIgZnJvbSB0aGUgZ2l2ZW4gdHlwZSBvZiBldmVudHNcbiAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSAgeyp9IC4uLmFyZ3NcbiAgICovXG4gIG9mZiAodHlwZSwgLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbFxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBsZXQgbGlzdGVuZXIgPSBhcmdzWzBdXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpXG4gICAgfVxuXG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXVxuICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGxldCBpbmRleE9mTGlzdGVuZXIgPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcilcbiAgICBpZiAoaW5kZXhPZkxpc3RlbmVyID09PSAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4T2ZMaXN0ZW5lciwgMSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtICB7Kn0gLi4uYXJnc1xuICAgKi9cbiAgZW1pdCAodHlwZSwgLi4uYXJncykge1xuICAgIHRoaXMuX3BpcGVEZXN0aW5hdGlvbnMuZm9yRWFjaCgoZGVzdCkgPT4ge1xuICAgICAgZGVzdC5lbWl0KHR5cGUsIC4uLmFyZ3MpXG4gICAgfSlcblxuICAgIGxldCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV1cbiAgICBpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goKGZuKSA9PiBmbi5hcHBseShudWxsLCBhcmdzKSlcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWF4aW11bSBhbW9udXQgb2YgbGlzdGVuZXJzIGJlZm9yZSBhIHdhcm5pbmcgaXMgcHJpbnRlZFxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV3TWF4TGlzdGVuZXJzXG4gICAqL1xuICBzZXRNYXhMaXN0ZW5lcnMgKG5ld01heExpc3RlbmVycykge1xuICAgIGlmIChwYXJzZUludChuZXdNYXhMaXN0ZW5lcnMsIDEwKSAhPT0gbmV3TWF4TGlzdGVuZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKClcbiAgICB9XG5cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuZXdNYXhMaXN0ZW5lcnNcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL2V2ZW50LWVtaXR0ZXIuanNcbiAqKi8iLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBCYXNlNjQgZnJvbSAnLi9iYXNlNjQnXG5cbi8qKlxuICogUHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFV0aWxzIHtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFuIEFycmF5XG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9iamVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzQXJyYXkgKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdpdmVuIG9iamVjdCdzIHZhbHVlcyBhcyBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm5zIHtBcnJheTwqPn1cbiAgICovXG4gIHN0YXRpYyB2YWx1ZXMgKG9iamVjdCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXVxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIHZhbHVlcy5wdXNoKG9iamVjdFtrZXldKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBET00gZWxlbWVudFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBzdGF0aWMgaXNET01FbGVtZW50IChvKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcgPyBvIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgIDogbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGggZ2l2ZW4gZXZlbnQgaXMgYSB0b3VjaCBldmVudFxuICAgKiBAcGFyYW0gIHtFdmVudH0gIGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1RvdWNoRXZlbnQgKGUpIHtcbiAgICByZXR1cm4gKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpICE9PSAtMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBnaXZlbiB2ZWN0b3IgdG8gZml0IGluc2lkZSB0aGUgZ2l2ZW4gbWF4IHNpemUgd2hpbGUgbWFpbnRhaW5pbmdcbiAgICogdGhlIGFzcGVjdCByYXRpb1xuICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2ZWN0b3JcbiAgICogQHBhcmFtICB7VmVjdG9yMn0gbWF4XG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuICBzdGF0aWMgcmVzaXplVmVjdG9yVG9GaXQgKHZlY3RvciwgbWF4KSB7XG4gICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1pbihtYXgueCAvIHZlY3Rvci54LCBtYXgueSAvIHZlY3Rvci55KVxuICAgIGNvbnN0IG5ld1NpemUgPSB2ZWN0b3IuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KHNjYWxlKVxuICAgIHJldHVybiBuZXdTaXplXG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gdGhlIGRlc3RpbmF0aW9uXG4gICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIHVuZGVmaW5lZC4gT25jZSBhXG4gICAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gLi4uc291cmNlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgKG9iamVjdCwgLi4uc291cmNlcykge1xuICAgIC8vIFNoYWxsb3cgY2xvbmVcbiAgICBsZXQgbmV3T2JqZWN0ID0ge31cbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IG9iamVjdFtrZXldXG4gICAgfVxuXG4gICAgLy8gQ2xvbmUgc291cmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5ld09iamVjdFtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG5ld09iamVjdFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAqIHNvdXJjZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGV4dGVuZCAob2JqZWN0LCAuLi5zb3VyY2VzKSB7XG4gICAgLy8gU2hhbGxvdyBjbG9uZVxuICAgIGxldCBuZXdPYmplY3QgPSB7fVxuICAgIGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgIG5ld09iamVjdFtrZXldID0gb2JqZWN0W2tleV1cbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgc291cmNlc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpXVxuICAgICAgZm9yIChsZXQga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iamVjdFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGNsb25lIChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe30sIG9iamVjdClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmxvYiBVUkkgZnJvbSB0aGUgZ2l2ZW4gRGF0YSBVUklcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVCbG9iVVJJRnJvbURhdGFVUkkgKGRhdGEpIHtcbiAgICBpZiAoIXdpbmRvdy5CbG9iIHx8ICF3aW5kb3cuVVJMIHx8ICFBcnJheUJ1ZmZlciB8fCAhVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG5cbiAgICBjb25zdCByYXdEYXRhID0gQmFzZTY0LmRlY29kZShkYXRhLnNwbGl0KCcsJylbMV0pXG4gICAgY29uc3QgbWltZVN0cmluZyA9IGRhdGEuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF1cblxuICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIocmF3RGF0YS5sZW5ndGgpXG4gICAgY29uc3QgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludEFycmF5W2ldID0gcmF3RGF0YVtpXVxuICAgIH1cblxuICAgIC8vIHdyaXRlIHRoZSBBcnJheUJ1ZmZlciB0byBhIGJsb2IsIGFuZCB5b3UncmUgZG9uZVxuICAgIGNvbnN0IGJsb2IgPSBuZXcgd2luZG93LkJsb2IoW2FycmF5QnVmZmVyXSwge1xuICAgICAgdHlwZTogbWltZVN0cmluZ1xuICAgIH0pXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gIH1cblxuICAvKipcbiAgICogVmVuZG9yIHByb3h5IGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKGNiKSB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxsYmFjayhjYilcbiAgICB9XG5cbiAgICByZXR1cm4gKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgIGZhbGxiYWNrKShjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBVVUlEXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXRVVUlEICgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgbGV0IHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwXG4gICAgICBsZXQgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OClcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRmxhdHRlbnMgdGhlIGdpdmVuIG11bHRpZGltZW5zaW9uYWwgYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgZmxhdHRlbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChmbGF0LCB0b0ZsYXR0ZW4pIHtcbiAgICAgIHJldHVybiBmbGF0LmNvbmNhdChBcnJheS5pc0FycmF5KHRvRmxhdHRlbikgPyBVdGlscy5mbGF0dGVuKHRvRmxhdHRlbikgOiB0b0ZsYXR0ZW4pXG4gICAgfSwgW10pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhcyBET00gZWxlbWVudCAoYnJvd3Nlcikgb3IgYSBub2RlLWNhbnZhcyBjYW52YXMgKG5vZGUpXG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDYW52YXMgKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgTm9kZUNhbnZhcyA9IHJlcXVpcmUoJ2NhbnZhcycpXG4gICAgICByZXR1cm4gbmV3IE5vZGVDYW52YXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBkaW1lbnNpb25zIGFyZSBQT1RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSAgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzUG93ZXJPZlR3byAoZGltZW5zaW9ucykge1xuICAgIHJldHVybiAoZGltZW5zaW9ucy54ICYgKGRpbWVuc2lvbnMueCAtIDEpKSA9PT0gMCAmJlxuICAgICAgKGRpbWVuc2lvbnMueSAmIChkaW1lbnNpb25zLnkgLSAxKSkgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IGxvd2VzdCBwb3dlciBvZiB0d28gb2YgdGhlIGdpdmVuIG51bWJlclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIG5leHRMb3dlc3RQT1QgKHgpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMyOyBpIDw8PSAxKSB7XG4gICAgICB4ID0geCB8IHggPj4gaVxuICAgIH1cbiAgICByZXR1cm4geCAtICh4ID4+IDEpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBvZiB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgbmV4dEhpZ2hlc3RQT1QgKHgpIHtcbiAgICB4LS1cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMyOyBpIDw8PSAxKSB7XG4gICAgICB4ID0geCB8IHggPj4gaVxuICAgIH1cbiAgICByZXR1cm4geCArIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgYXJyYXkgaXRlbSBhdCBgb2xkSW5kZXhgIHRvIGBuZXdJbmRleGBcbiAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IG9sZEluZGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gbmV3SW5kZXhcbiAgICovXG4gIHN0YXRpYyBtb3ZlQXJyYXlJdGVtIChhcnIsIG9sZEluZGV4LCBuZXdJbmRleCkge1xuICAgIGlmIChuZXdJbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICBsZXQgayA9IG5ld0luZGV4IC0gYXJyLmxlbmd0aFxuICAgICAgd2hpbGUgKChrLS0pICsgMSkge1xuICAgICAgICBhcnIucHVzaCh1bmRlZmluZWQpXG4gICAgICB9XG4gICAgfVxuICAgIGFyci5zcGxpY2UobmV3SW5kZXgsIDAsIGFyci5zcGxpY2Uob2xkSW5kZXgsIDEpWzBdKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxzXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi91dGlscy5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIDItZGltZW5zaW9uYWwgdmVjdG9yIHdoaWxlIHByb3ZpZGluZyBtYXRoIGZ1bmN0aW9ucyB0b1xuICogbW9kaWZ5IC8gY2xvbmUgdGhlIHZlY3Rvci4gRnVsbHkgY2hhaW5hYmxlLlxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuTWF0aFxuICovXG5jbGFzcyBWZWN0b3IyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBWZWN0b3IyXG4gICAqIEBwYXJhbSAge051bWJlcn0geFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh4LCB5KSB7XG4gICAgdGhpcy54ID0geFxuICAgIHRoaXMueSA9IHlcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMueCA9IDBcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnkgPSAwXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlc1xuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBzZXQgKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4XG4gICAgdGhpcy55ID0geVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpXG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIHZlY3RvclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IG90aGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGNvcHkgKG90aGVyKSB7XG4gICAgdGhpcy54ID0gb3RoZXIueFxuICAgIHRoaXMueSA9IG90aGVyLnlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIENsYW1wcyB0aGlzIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBWZWN0b3IyIC8gTnVtYmVyXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gbWluaW11bVxuICAgKiBAcGFyYW0gIHsoTnVtYmVyfFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMil9IG1heGltdW1cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgY2xhbXAgKG1pbmltdW0sIG1heGltdW0pIHtcbiAgICBsZXQgbWluaW11bVNldCA9IG1pbmltdW0gIT09IG51bGwgJiYgdHlwZW9mIG1pbmltdW0gIT09ICd1bmRlZmluZWQnXG4gICAgbGV0IG1heGltdW1TZXQgPSBtYXhpbXVtICE9PSBudWxsICYmIHR5cGVvZiBtYXhpbXVtICE9PSAndW5kZWZpbmVkJ1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG4gICAgaWYgKCEobWluaW11bSBpbnN0YW5jZW9mIFZlY3RvcjIpICYmIG1pbmltdW1TZXQpIHtcbiAgICAgIG1pbmltdW0gPSBuZXcgVmVjdG9yMihtaW5pbXVtLCBtaW5pbXVtKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICBpZiAoIShtYXhpbXVtIGluc3RhbmNlb2YgVmVjdG9yMikgJiYgbWF4aW11bVNldCkge1xuICAgICAgbWF4aW11bSA9IG5ldyBWZWN0b3IyKG1heGltdW0sIG1heGltdW0pXG4gICAgfVxuXG4gICAgaWYgKG1pbmltdW1TZXQpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWF4KG1pbmltdW0ueCwgdGhpcy54KVxuICAgICAgdGhpcy55ID0gTWF0aC5tYXgobWluaW11bS55LCB0aGlzLnkpXG4gICAgfVxuXG4gICAgaWYgKG1heGltdW1TZXQpIHtcbiAgICAgIHRoaXMueCA9IE1hdGgubWluKG1heGltdW0ueCwgdGhpcy54KVxuICAgICAgdGhpcy55ID0gTWF0aC5taW4obWF4aW11bS55LCB0aGlzLnkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRGl2aWRlcyB0aGlzIHZlY3RvciBieSB0aGUgZ2l2ZW4gVmVjdG9yMiAvIE51bWJlclxuICAgKiBAcGFyYW0gIHsoTnVtYmVyfFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMil9IGRpdmlzb3JcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbeV1cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZGl2aWRlIChkaXZpc29yLCB5KSB7XG4gICAgaWYgKGRpdmlzb3IgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLnggLz0gZGl2aXNvci54XG4gICAgICB0aGlzLnkgLz0gZGl2aXNvci55XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCAvPSBkaXZpc29yXG4gICAgICB0aGlzLnkgLz0gKHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJyA/IGRpdmlzb3IgOiB5KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnRyYWN0cyB0aGUgZ2l2ZW4gVmVjdG9yMiAvIE51bWJlciBmcm9tIHRoaXMgdmVjdG9yXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gc3VidHJhaGVuZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt5XVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBzdWJ0cmFjdCAoc3VidHJhaGVuZCwgeSkge1xuICAgIGlmIChzdWJ0cmFoZW5kIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54IC09IHN1YnRyYWhlbmQueFxuICAgICAgdGhpcy55IC09IHN1YnRyYWhlbmQueVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggLT0gc3VidHJhaGVuZFxuICAgICAgdGhpcy55IC09ICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBzdWJ0cmFoZW5kIDogeSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHRoZSBnaXZlbiBWZWN0b3IyIC8gTnVtYmVyIHdpdGggdGhpcyB2ZWN0b3JcbiAgICogQHBhcmFtICB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIpfSBzdWJ0cmFoZW5kXG4gICAqIEBwYXJhbSAge051bWJlcn0gW3ldXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIG11bHRpcGx5IChmYWN0b3IsIHkpIHtcbiAgICBpZiAoZmFjdG9yIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy54ICo9IGZhY3Rvci54XG4gICAgICB0aGlzLnkgKj0gZmFjdG9yLnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ICo9IGZhY3RvclxuICAgICAgdGhpcy55ICo9ICh0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3IgOiB5KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIFZlY3RvcjIgLyBOdW1iZXJzIHRvIHRoaXMgdmVjdG9yXG4gICAqIEBwYXJhbSB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjIpfSBhZGRlbmRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBhZGQgKGFkZGVuZCwgeSkge1xuICAgIGlmIChhZGRlbmQgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLnggKz0gYWRkZW5kLnhcbiAgICAgIHRoaXMueSArPSBhZGRlbmQueVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggKz0gYWRkZW5kXG4gICAgICB0aGlzLnkgKz0gKHR5cGVvZiB5ID09PSAndW5kZWZpbmVkJyA/IGFkZGVuZCA6IHkpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgdmFsdWUgYXJlIHRoZSBzYW1lIGFzIHRoZSBnaXZlbiBvbmVzXG4gICAqIEBwYXJhbSAgeyhOdW1iZXJ8UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyKX0gdmVjXG4gICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZXF1YWxzICh2ZWMsIHkpIHtcbiAgICBpZiAodmVjIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgcmV0dXJuIHZlYy54ID09PSB0aGlzLnggJiYgdmVjLnkgPT09IHRoaXMueVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmVjID09PSB0aGlzLnggJiYgeSA9PT0gdGhpcy55XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsaXBzIHRoZSB4IGFuZCB5IHZhbHVlcyBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBmbGlwICgpIHtcbiAgICBsZXQgdGVtcFggPSB0aGlzLnhcbiAgICB0aGlzLnggPSB0aGlzLnlcbiAgICB0aGlzLnkgPSB0ZW1wWFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUm91bmRzIHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3JcbiAgICogQHJldHVybnMge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIHJvdW5kICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueClcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJvdW5kcyB1cCB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBjZWlsICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KVxuICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSb3VuZHMgZG93biB0aGUgdmFsdWVzIG9mIHRoaXMgdmVjdG9yXG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBmbG9vciAoKSB7XG4gICAgdGhpcy54ID0gdGhpcy54IHwgMFxuICAgIHRoaXMueSA9IHRoaXMueSB8IDBcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGJvdGggbnVtYmVycyBvZiB0aGlzIHZlY3RvciBwb3NpdGl2ZVxuICAgKiBAcmV0dXJucyB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgYWJzICgpIHtcbiAgICB0aGlzLnggPSBNYXRoLmFicyh0aGlzLngpXG4gICAgdGhpcy55ID0gTWF0aC5hYnModGhpcy55KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXVjbGlkZWFuIGxlbmd0aCBvZiB0aGlzIHZlY3RvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBsZW4gKCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2ZWN0b3JcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBgVmVjdG9yMih7IHg6ICR7dGhpcy54fSwgeTogJHt0aGlzLnl9IH0pYFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZlY3RvcjJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL21hdGgvdmVjdG9yMi5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmxldCBtYXhMb2dMZXZlbCA9ICd3YXJuJ1xuXG5jb25zdCBMRVZFTFMgPSBbXG4gIHsgdHlwZTogJ3RyYWNlJywgYmFja2dyb3VuZDogJyNFRUVFRUUnLCBjb2xvcjogJyNBQUFBQUEnIH0sXG4gIHsgdHlwZTogJ2luZm8nLCBiYWNrZ3JvdW5kOiAnI0JERTVGOCcsIGNvbG9yOiAnIzAwNTI5QicgfSxcbiAgeyB0eXBlOiAnd2FybicsIGJhY2tncm91bmQ6ICcjRkVFRkIzJywgY29sb3I6ICcjOUY2MDAwJyB9LFxuICB7IHR5cGU6ICdlcnJvcicsIGJhY2tncm91bmQ6ICcjRkZCQUJBJywgY29sb3I6ICcjRDgwMDBDJyB9LFxuICB7IHR5cGU6ICdsb2cnLCBiYWNrZ3JvdW5kOiAnI0VFRUVFRScsIGNvbG9yOiAnIzFmNGY2YicgfVxuXVxuY29uc3QgTEVWRUxfVFlQRVMgPSBMRVZFTFMubWFwKChsKSA9PiBsLnR5cGUpXG5cbmxldCBMb2cgPSB7fVxuXG5Mb2cuc2V0TGV2ZWwgPSAoX2xldmVsKSA9PiB7IG1heExvZ0xldmVsID0gX2xldmVsIH1cbkxvZy5jYW5Mb2cgPSAodHlwZSkgPT4ge1xuICBpZiAobWF4TG9nTGV2ZWwgPT09IG51bGwpIHJldHVybiBmYWxzZVxuICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IExFVkVMX1RZUEVTLmluZGV4T2YodHlwZSlcbiAgY29uc3QgbWF4TGV2ZWxJbmRleCA9IExFVkVMX1RZUEVTLmluZGV4T2YobWF4TG9nTGV2ZWwpXG4gIGlmIChjdXJyZW50TGV2ZWxJbmRleCA8IG1heExldmVsSW5kZXgpIHJldHVybiBmYWxzZVxuICByZXR1cm4gdHJ1ZVxufVxuTG9nLmhhc0NvbG9yZnVsT3V0cHV0ID0gKCkgPT4ge1xuICByZXR1cm4gKCFwcm9jZXNzIHx8IChwcm9jZXNzICYmIHByb2Nlc3MuYnJvd3NlcikpICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvR2Vja298V2ViS2l0L2kpICYmXG4gICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVHJpZGVudC8pXG4gICAgKVxufVxuXG5Mb2cucHJpbnRFcnJvciA9IChlKSA9PiB7XG4gIGNvbnN0IGxpbmVzID0gZS5zdGFjay5zcGxpdCgnXFxuJylcbiAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIExvZy5lcnJvcignRXJyb3InLCBsaW5lKVxuICB9KVxufVxuXG5MRVZFTFMuZm9yRWFjaCgobGV2ZWwpID0+IHtcbiAgY29uc3QgeyB0eXBlLCBiYWNrZ3JvdW5kLCBjb2xvciB9ID0gbGV2ZWxcbiAgTG9nW3R5cGVdID0gZnVuY3Rpb24gKHRhZywgLi4uYXJncykge1xuICAgIGlmICghTG9nLmNhbkxvZyh0eXBlKSkgcmV0dXJuXG5cbiAgICBjb25zdCBvdXRwdXQgPSBhcmdzXG4gICAgICAubWFwKChhKSA9PiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSA/IGEgOiBhLnRvU3RyaW5nKCkpXG4gICAgICAuam9pbignICcpXG4gICAgaWYgKCFMb2cuaGFzQ29sb3JmdWxPdXRwdXQoKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKGBQaG90b0VkaXRvclNESyB8ICR7dGFnfSB8ICR7b3V0cHV0fWApXG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYCVjICAlYyBQaG90b0VkaXRvclNESyAlYyAgJWMgJHt0YWd9ICVjICAke291dHB1dH0gICVjICBgLFxuICAgICAgJ2JhY2tncm91bmQ6ICM0M0FERUI7IHBhZGRpbmc6IDVweCAwJyxcbiAgICAgICdiYWNrZ3JvdW5kOiAjMkIyQjJCOyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDVweCAwJyxcbiAgICAgICdiYWNrZ3JvdW5kOiAjNDNBREVCOyBwYWRkaW5nOiA1cHggMCcsXG4gICAgICBgYmFja2dyb3VuZDogJHtiYWNrZ3JvdW5kfTsgY29sb3I6ICR7Y29sb3J9OyBwYWRkaW5nOiA1cHggMDsgZm9udC13ZWlnaHQ6IGJvbGRgLFxuICAgICAgJ2JhY2tncm91bmQ6ICMyQjJCMkI7IGNvbG9yOiB3aGl0ZTsgcGFkZGluZzogNXB4IDAnLFxuICAgICAgJ2JhY2tncm91bmQ6ICM0M0FERUI7IHBhZGRpbmc6IDVweCAwJylcbiAgfVxufSlcblxuZXhwb3J0IGRlZmF1bHQgTG9nXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuLi9zaGFyZWQvbG9nLmpzXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIElTX1dSQVAgICA9IHR5cGUgJiAkZXhwb3J0LldcbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV1cbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGtleSwgb3duLCBvdXQ7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbihDKXtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBDKXtcbiAgICAgICAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQztcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYoSVNfUFJPVE8pe1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0paGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZXhwb3J0LmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzI4X187XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiBleHRlcm5hbCBcImdsXCJcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgVXRpbHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG4vKipcbiAqIEEgY2FudmFzIHJlbmRlciB0YXJnZXQgdGhhdCB5b3UgY2FuIHJlbmRlciB0by5cbiAqIENhbnZhcyBlcXVpdmFsZW50IG9mIHtAbGluayBQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJUYXJnZXR9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgQ2FudmFzUmVuZGVyVGFyZ2V0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDYW52YXNSZW5kZXJUYXJnZXRcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBpeGVsUmF0aW9cbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvLCBjYW52YXMsIGNvbnRleHQpIHtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW9cblxuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhcyB8fCB0aGlzLl9jcmVhdGVDYW52YXMoKVxuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG5cbiAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLl93aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW9cbiAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpb1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrID0gW1xuICAgICAge1xuICAgICAgICByZW5kZXJUYXJnZXQ6IHRoaXMsXG4gICAgICAgIGZpbHRlcjogW11cbiAgICAgIH1cbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNhbnZhc1xuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2FudmFzICgpIHtcbiAgICByZXR1cm4gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhpcyBDYW52YXNSZW5kZXJUYXJnZXRcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jb250ZXh0XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvLCB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhpcyBjYW52YXMgYnVmZmVyIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICBpZiAodGhpcy5fd2lkdGggIT09IGRpbWVuc2lvbnMueCkge1xuICAgICAgdGhpcy5fd2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX3dpZHRoICogdGhpcy5fcGl4ZWxSYXRpb1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9oZWlnaHQgIT09IGRpbWVuc2lvbnMueSkge1xuICAgICAgdGhpcy5faGVpZ2h0ID0gZGltZW5zaW9ucy55XG4gICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpb1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjYW52YXNcbiAgICogQHJldHVybiB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAqL1xuICBnZXRDYW52YXMgKCkgeyByZXR1cm4gdGhpcy5fY2FudmFzIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHJldHVybiB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBnZXRDb250ZXh0ICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRleHQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXIgc3RhY2tcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRGaWx0ZXJTdGFjayAoKSB7IHJldHVybiB0aGlzLl9maWx0ZXJTdGFjayB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFdpZHRoICgpIHsgcmV0dXJuIHRoaXMuX3dpZHRoIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCAoKSB7IHJldHVybiB0aGlzLl9oZWlnaHQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwaXhlbCByYXRpb1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRQaXhlbFJhdGlvICgpIHsgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW8gfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpb1xuICAgKi9cbiAgc2V0UGl4ZWxSYXRpbyAocGl4ZWxSYXRpbykgeyB0aGlzLl9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0RGltZW5zaW9ucyAoKSB7IHJldHVybiBuZXcgVmVjdG9yMih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIGNhbnZhcyBidWZmZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX2NhbnZhcyA9IG51bGxcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlbmRlclRhcmdldFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdXRpbHMvY2FudmFzLXJlbmRlci10YXJnZXQuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb2xvciwgVmVjdG9yMiwgTWF0cml4LCBSZWN0YW5nbGUgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IHlvdSBjYW4gcmVuZGVyIHRvLiBXZWJHTCBlcXVpdmFsZW50IG9mIHtAbGluayBQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0fVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBXZWJHTFJlbmRlclRhcmdldCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgV2ViR0xSZW5kZXJUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gIHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge051bWJlcn0gIHdpZHRoXG4gICAqIEBwYXJhbSAge051bWJlcn0gIGhlaWdodFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBwaXhlbFJhdGlvXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtpc1Jvb3QgPSBmYWxzZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlciwgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgaXNSb290ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyXG4gICAgdGhpcy5fZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5fZnJhbWUgPSBudWxsXG4gICAgdGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW9cbiAgICB0aGlzLl9wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cbiAgICAvLyBgbnVsbGAgbWVhbnMgcmVuZGVyIHRvIGNhbnZhcyBkaXJlY3RseVxuICAgIHRoaXMuX2ZyYW1lYnVmZmVyID0gbnVsbFxuICAgIHRoaXMuX2lzUm9vdCA9IGlzUm9vdFxuICAgIHRoaXMuX2ZpbHRlclN0YWNrID0gW1xuICAgICAge1xuICAgICAgICByZW5kZXJUYXJnZXQ6IHRoaXMsXG4gICAgICAgIGZpbHRlcjogW11cbiAgICAgIH1cbiAgICBdXG5cbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdGhpcy5faW5pdEZyYW1lQnVmZmVyKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGlzIFdlYkdMUmVuZGVyVGFyZ2V0IHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMueCB8IDAgLy8gcm91bmRlZFxuICAgIHRoaXMuX2hlaWdodCA9IGRpbWVuc2lvbnMueSB8IDAgLy8gcm91bmRlZFxuXG4gICAgaWYgKCF0aGlzLl9pc1Jvb3QpIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZVRleHR1cmUoZGltZW5zaW9ucylcbiAgICB9XG5cbiAgICB0aGlzLl9jYWxjdWxhdGVQcm9qZWN0aW9uTWF0cml4KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBGQk8ncyB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2l6ZVRleHR1cmUgKGRpbWVuc2lvbnMpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2dsXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSlcblxuICAgIGNvbnN0IHJlYWxXaWR0aCA9IHRoaXMuX3dpZHRoICogdGhpcy5fcGl4ZWxSYXRpb1xuICAgIGNvbnN0IHJlYWxIZWlnaHQgPSB0aGlzLl9oZWlnaHQgKiB0aGlzLl9waXhlbFJhdGlvXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLFxuICAgICAgcmVhbFdpZHRoLCByZWFsSGVpZ2h0LFxuICAgICAgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbClcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgZnJhbWVidWZmZXIgYW5kIHJlc2l6ZXMgdGhlIHZpZXdwb3J0XG4gICAqL1xuICBhY3RpdmF0ZSAoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbFxuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVidWZmZXIpXG5cbiAgICB0aGlzLl9jYWxjdWxhdGVQcm9qZWN0aW9uTWF0cml4KClcblxuICAgIGdsLnZpZXdwb3J0KDAsXG4gICAgICAwLFxuICAgICAgdGhpcy5fd2lkdGggKiB0aGlzLl9waXhlbFJhdGlvLFxuICAgICAgdGhpcy5faGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpbylcbiAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGZyYW1lYnVmZmVyXG4gICAqL1xuICBjbGVhciAoY29sb3IgPSBDb2xvci5UUkFOU1BBUkVOVCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fZ2xcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lYnVmZmVyKVxuXG4gICAgZ2wuY2xlYXJDb2xvci5hcHBseShnbCwgY29sb3IudG9HTENvbG9yKCkpXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBmb3IgdGhpcyByZW5kZXIgdGFyZ2V0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FsY3VsYXRlUHJvamVjdGlvbk1hdHJpeCAoKSB7XG4gICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuX3Byb2plY3Rpb25NYXRyaXhcbiAgICBwcm9qZWN0aW9uTWF0cml4LnJlc2V0KClcblxuICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fZnJhbWUgfHwgbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuXG4gICAgY29uc3QgeyB4LCB5IH0gPSBmcmFtZVxuICAgIGlmICghdGhpcy5faXNSb290KSB7XG4gICAgICBwcm9qZWN0aW9uTWF0cml4LmEgPSAxIC8gdGhpcy5fd2lkdGggKiAyXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LmQgPSAxIC8gdGhpcy5faGVpZ2h0ICogMlxuXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LnR4ID0gLTEgLSB4ICogcHJvamVjdGlvbk1hdHJpeC5hXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LnR5ID0gLTEgLSB5ICogcHJvamVjdGlvbk1hdHJpeC5kXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2plY3Rpb25NYXRyaXguYSA9IDEgLyB0aGlzLl93aWR0aCAqIDJcbiAgICAgIHByb2plY3Rpb25NYXRyaXguZCA9IC0xIC8gdGhpcy5faGVpZ2h0ICogMlxuXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LnR4ID0gLTEgLSB4ICogcHJvamVjdGlvbk1hdHJpeC5hXG4gICAgICBwcm9qZWN0aW9uTWF0cml4LnR5ID0gMSAtIHkgKiBwcm9qZWN0aW9uTWF0cml4LmRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIFdlYkdMIEZCTyBhbmQgVGV4dHVyZSBmb3IgdGhpcyBXZWJHTFJlbmRlclRhcmdldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRGcmFtZUJ1ZmZlciAoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbFxuXG4gICAgLy8gSW5pdCB0aGUgRkJPXG4gICAgdGhpcy5fZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXG5cbiAgICAvLyBDcmVhdGUgdGhlIHRleHR1cmVcbiAgICB0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSlcblxuICAgIC8vIFNldCBzY2FsZSBhbmQgcmVwZWF0IHBhcmFtZXRlcnNcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVClcblxuICAgIC8vIEJpbmQgdGV4dHVyZSB0byBGQk9cbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2ZyYW1lYnVmZmVyKVxuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSwgMClcblxuICAgIHRoaXMucmVzaXplVG8obmV3IFZlY3RvcjIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5NYXRyaXh9XG4gICAqL1xuICBnZXRQcm9qZWN0aW9uTWF0cml4ICgpIHsgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25NYXRyaXggfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfVxuICAgKi9cbiAgZ2V0VGV4dHVyZSAoKSB7IHJldHVybiB0aGlzLl90ZXh0dXJlIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZnJhbWVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBnZXRGcmFtZSAoKSB7IHJldHVybiB0aGlzLl9mcmFtZSB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZyYW1lXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9IGZyYW1lXG4gICAqL1xuICBzZXRGcmFtZSAoZnJhbWUpIHsgdGhpcy5fZnJhbWUgPSBmcmFtZSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbHRlciBzdGFja1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICovXG4gIGdldEZpbHRlclN0YWNrICgpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlclN0YWNrIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBXZWJHTFJlbmRlclRhcmdldFxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9nbFxuICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fdGV4dHVyZSlcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9mcmFtZWJ1ZmZlcilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXZWJHTFJlbmRlclRhcmdldFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdXRpbHMvd2ViZ2wtcmVuZGVyLXRhcmdldC5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IExvZyBmcm9tICcuLi8uLi9zaGFyZWQvbG9nJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2V2ZW50LWVtaXR0ZXInXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuL21hdGgvdmVjdG9yMidcbmltcG9ydCBDb2xvciBmcm9tICcuL2NvbG9yJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4vdXRpbHMnXG5cbi8qKlxuICogQWRkcyBgc2V0e09wdGlvbk5hbWV9YCBhbmQgYGdldHtPcHRpb25OYW1lfWAgbWV0aG9kcyB0byBhbiBvYmplY3QuIE1ldGhvZCBuYW1lc1xuICogYXJlIHNwZWNpZmllZCB2aWEgdGhlIGBhdmFpbGFibGVPcHRpb25zYCBvYmplY3QuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIENvbmZpZ3VyYWJsZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zID0ge30sIGFkZGl0aW9uYWxBdmFpbGFibGVPcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0gdGhpcy5hdmFpbGFibGVPcHRpb25zIHx8IHt9XG4gICAgdGhpcy5hdmFpbGFibGVPcHRpb25zID0gVXRpbHMuZXh0ZW5kKHRoaXMuYXZhaWxhYmxlT3B0aW9ucywgYWRkaXRpb25hbEF2YWlsYWJsZU9wdGlvbnMpXG5cbiAgICB0aGlzLl9vbkNvbmZpZ3VyYWJsZVVwZGF0ZSA9IHRoaXMuX29uQ29uZmlndXJhYmxlVXBkYXRlLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2luaXRPcHRpb25zKG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGVycm9yIG1lc3NhZ2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcmV0dXJuIHtFcnJvcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9idWlsZENvbmZpZ0Vycm9yIChtZXNzYWdlKSB7XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9ICcnXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogYFxuICAgIH1cbiAgICBlcnJvck1lc3NhZ2UgKz0gbWVzc2FnZVxuICAgIHJldHVybiBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25PcHRpb25zQ2hhbmdlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFsbCByZXF1aXJlZCBvcHRpb25zIGFyZSBzcGVjaWZpZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHZhbGlkYXRlU2V0dGluZ3MgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBDaGVjayBmb3IgcmVxdWlyZWQgb3B0aW9uc1xuICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiB0aGlzLmF2YWlsYWJsZU9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG9wdGlvbkNvbmZpZyA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgICAgICBpZiAob3B0aW9uQ29uZmlnLnJlcXVpcmVkICYmIHR5cGVvZiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBpcyByZXF1aXJlZC5gKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgYXZhaWxhYmxlIG9wdGlvbnMsIHNldHMgX29wdGlvbnMgZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9pbml0T3B0aW9ucyAodXNlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB7fVxuXG4gICAgLy8gU2V0IGRlZmF1bHRzLCBjcmVhdGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIHZhciBvcHRpb25OYW1lLCBvcHRpb24sIGNhcGl0YWxpemVkXG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgZm9yIChvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY2FwaXRhbGl6ZWQgPSBvcHRpb25OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0aW9uTmFtZS5zbGljZSgxKVxuICAgICAgb3B0aW9uID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICAgIGlmIChbXG4gICAgICAgICdzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nLCAnb2JqZWN0JyxcbiAgICAgICAgJ3ZlY3RvcjInLCAnY29sb3InLCAnY29uZmlndXJhYmxlJyxcbiAgICAgICAgJ2FycmF5J1xuICAgICAgXS5pbmRleE9mKG9wdGlvbi50eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgVW5rbm93biBvcHRpb24gdHlwZTogXFxgJHtvcHRpb24udHlwZX1cXGBgKVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgc2V0dGVyIGFuZCBnZXR0ZXJcbiAgICAgIGxldCBmbiA9IGZ1bmN0aW9uIChvcHRpb25OYW1lLCBvcHRpb24pIHtcbiAgICAgICAgc2VsZlsnc2V0JyArIGNhcGl0YWxpemVkXSA9IGZ1bmN0aW9uICh2YWx1ZSwgdXBkYXRlLCBpbml0aWFsKSB7XG4gICAgICAgICAgc2VsZi5zZXRPcHRpb24ob3B0aW9uTmFtZSwgdmFsdWUsIHVwZGF0ZSwgaW5pdGlhbClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgZ2V0dGVyXG4gICAgICAgIHNlbGZbJ2dldCcgKyBjYXBpdGFsaXplZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0T3B0aW9uKG9wdGlvbk5hbWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZuKG9wdGlvbk5hbWUsIG9wdGlvbilcblxuICAgICAgLy8gSGFuZGxlIGNvbmZpZ3VyYWJsZSBpbml0aWFsaXphdGlvblxuICAgICAgaWYgKG9wdGlvbi50eXBlID09PSAnY29uZmlndXJhYmxlJykge1xuICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gbmV3IENvbmZpZ3VyYWJsZSh1bmRlZmluZWQsIG9wdGlvbi5zdHJ1Y3R1cmUgfHwge30pXG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0ub24oJ3VwZGF0ZScsIHRoaXMuX29uQ29uZmlndXJhYmxlVXBkYXRlKVxuICAgICAgfVxuXG4gICAgICAvLyBTZXQgZGVmYXVsdCBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uLmRlZmF1bHQgIT09ICd1bmRlZmluZWQnICYmICEob3B0aW9uTmFtZSBpbiB1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgdGhpc1snc2V0JyArIGNhcGl0YWxpemVkXShvcHRpb24uZGVmYXVsdCwgZmFsc2UsIHRydWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3ZlcndyaXRlIG9wdGlvbnMgd2l0aCB0aGUgb25lcyBnaXZlbiBieSB1c2VyXG4gICAgZm9yIChvcHRpb25OYW1lIGluIHVzZXJPcHRpb25zKSB7XG4gICAgICAvLyBDaGVjayBpZiBvcHRpb24gaXMgYXZhaWxhYmxlXG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbjogJyArIG9wdGlvbk5hbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGwgc2V0dGVyXG4gICAgICBjYXBpdGFsaXplZCA9IG9wdGlvbk5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHRpb25OYW1lLnNsaWNlKDEpXG4gICAgICB0aGlzWydzZXQnICsgY2FwaXRhbGl6ZWRdKHVzZXJPcHRpb25zW29wdGlvbk5hbWVdLCBmYWxzZSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgc2V0IChvcHRpb25zLCBlbWl0VXBkYXRlID0gdHJ1ZSkge1xuICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnNldE9wdGlvbihvcHRpb25OYW1lLCBvcHRpb25zW29wdGlvbk5hbWVdLCBmYWxzZSlcbiAgICB9XG4gICAgdGhpcy5fb25PcHRpb25zQ2hhbmdlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0T3B0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgZ2V0T3B0aW9uRGVmYXVsdCAob3B0aW9uTmFtZSkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIHJldHVybiBvcHRpb24uZGVmYXVsdFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0T3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGFzaCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RGVmYXVsdE9wdGlvbnMgKCkge1xuICAgIGxldCBvcHRpb25zID0ge31cbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHRoaXMuX29wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXS5kZWZhdWx0XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIGNvbnRpbnVlXG5cbiAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBkZWZhdWx0VmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBvcHRpb25zIGVxdWFsIHRoZSBnaXZlbiBvbmVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgb3B0aW9uc0VxdWFsIChvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0aW9uTmFtZV1cbiAgICAgIGlmICghdGhpcy5fb3B0aW9uRXF1YWxzKG9wdGlvbk5hbWUsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG9wdGlvbiBoYXMgdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wdGlvbkVxdWFscyAob3B0aW9uTmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcHRpb25UeXBlID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdLnR5cGVcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdXG4gICAgc3dpdGNoIChvcHRpb25UeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB2YWx1ZVxuICAgICAgY2FzZSAndmVjdG9yMic6XG4gICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5lcXVhbHMoY3VycmVudFZhbHVlKVxuICAgICAgY2FzZSAnY29uZmlndXJhYmxlJzpcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZS5vcHRpb25zRXF1YWwodmFsdWUpXG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnJheU9wdGlvbkVxdWFscyhvcHRpb25OYW1lLCB2YWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvcHRpb24gb2YgdHlwZSBgYXJyYXlgIG1hdGNoZXMgdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXJyYXlPcHRpb25FcXVhbHMgKG9wdGlvbk5hbWUsIGFycikge1xuICAgIGxldCB0aGlzQXJyID0gdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGxldCBlcXVhbCA9IHRydWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXNBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRoaXNWYWx1ZSA9IHRoaXNBcnJbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gYXJyW2ldXG4gICAgICBpZiAodGhpc1ZhbHVlIGluc3RhbmNlb2YgQ29uZmlndXJhYmxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8ICF0aGlzVmFsdWUub3B0aW9uc0VxdWFsKHZhbHVlKSkge1xuICAgICAgICAgIGVxdWFsID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB0aGlzVmFsdWUpIHtcbiAgICAgICAgZXF1YWwgPSBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXF1YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgY29uZmlndXJhYmxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHNlcmlhbGl6ZU9wdGlvbnMgKCkge1xuICAgIGxldCBvcHRpb25zID0ge31cbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHRoaXMuX29wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB0aGlzLl9zZXJpYWxpemVPcHRpb24ob3B0aW9uTmFtZSlcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHJldHVybiB7Kn0gb3B0aW9uTmFtZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2VyaWFsaXplT3B0aW9uIChvcHRpb25OYW1lKSB7XG4gICAgY29uc3Qgb3B0aW9uVHlwZSA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXS50eXBlXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdXG4gICAgc3dpdGNoIChvcHRpb25UeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJyonOlxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgIGNhc2UgJ3ZlY3RvcjInOlxuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICByZXR1cm4gdmFsdWUuY2xvbmUoKVxuICAgICAgY2FzZSAnY29uZmlndXJhYmxlJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHZhbGlkYXRlcyBpdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3VwZGF0ZSA9IHRydWVdIC0gU2hvdWxkIGFuIGB1cGRhdGVgIGV2ZW50IGJlIGVtaXR0ZWQ/XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXRpYWwgPSBmYWxzZV0gLSBJcyB0aGlzIHRoZSBmaXJzdCB0aW1lIHRoaXMgb3B0aW9uIGlzIHNldD9cbiAgICovXG4gIHNldE9wdGlvbiAob3B0aW9uTmFtZSwgdmFsdWUsIHVwZGF0ZSA9IHRydWUsIGluaXRpYWwgPSBmYWxzZSkge1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcywgeyBbb3B0aW9uTmFtZV06IHZhbHVlIH0pXG4gICAgfVxuXG4gICAgdmFyIG9wdGlvbkNvbmZpZyA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXVxuICAgIGlmICghb3B0aW9uQ29uZmlnKSB7XG4gICAgICBMb2cuZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgVW5rbm93biBvcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYC5gKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25Db25maWcuc2V0dGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSBvcHRpb25Db25maWcuc2V0dGVyLmNhbGwodGhpcywgdmFsdWUsIGluaXRpYWwpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25Db25maWcudmFsaWRhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbkNvbmZpZy52YWxpZGF0aW9uKHZhbHVlKVxuICAgIH1cblxuICAgIHN3aXRjaCAob3B0aW9uQ29uZmlnLnR5cGUpIHtcbiAgICAgIC8vIFN0cmluZyBvcHRpb25zXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhIHN0cmluZy5gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RyaW5nIHZhbHVlIHJlc3RyaWN0aW9uc1xuICAgICAgICB2YXIgYXZhaWxhYmxlID0gb3B0aW9uQ29uZmlnLmF2YWlsYWJsZVxuICAgICAgICBpZiAodHlwZW9mIGF2YWlsYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgYXZhaWxhYmxlLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIFxcYCR7b3B0aW9uTmFtZX1cXGAgKHZhbGlkIHZhbHVlcyBhcmU6ICR7b3B0aW9uQ29uZmlnLmF2YWlsYWJsZS5qb2luKCcsICcpfSlgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIE51bWJlciBvcHRpb25zXG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhIG51bWJlci5gKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEJvb2xlYW4gb3B0aW9uc1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhIGJvb2xlYW4uYClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBWZWN0b3IyIG9wdGlvbnNcbiAgICAgIGNhc2UgJ3ZlY3RvcjInOlxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFZlY3RvcjIpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgT3B0aW9uIFxcYCR7b3B0aW9uTmFtZX1cXGAgaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIFZlY3RvcjIuYClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZS5jbG9uZSgpXG5cbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gQ29sb3Igb3B0aW9uc1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSkge1xuICAgICAgICAgIHRocm93IHRoaXMuX2J1aWxkQ29uZmlnRXJyb3IoYE9wdGlvbiBcXGAke29wdGlvbk5hbWV9XFxgIGhhcyB0byBiZSBhbiBpbnN0YW5jZSBvZiBDb2xvci5gKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIE9iamVjdCBvcHRpb25zXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZVxuICAgICAgICBicmVha1xuXG4gICAgICAvLyBDb25maWd1cmFibGUgb3B0aW9uc1xuICAgICAgY2FzZSAnY29uZmlndXJhYmxlJzpcbiAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXS5zZXQodmFsdWUpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIC8vIEFycmF5IG9wdGlvbnNcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLl9idWlsZENvbmZpZ0Vycm9yKGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBoYXMgdG8gYmUgYW4gQXJyYXkuYClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWUuc2xpY2UoMClcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gVW5rbm93biBvcHRpb24gdHlwZVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5fYnVpbGRDb25maWdFcnJvcihgVW5rbm93biBvcHRpb24gdHlwZTogXFxgJHtvcHRpb25Db25maWcudHlwZX1cXGBgKVxuICAgIH1cblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMuX29uT3B0aW9uc0NoYW5nZSgpXG4gICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMsIHsgW29wdGlvbk5hbWVdOiB2YWx1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgYGNvbmZpZ3VyYWJsZWAgb3B0aW9uIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHBhcmFtICB7Kn0gLi4uYXJnc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29uZmlndXJhYmxlVXBkYXRlICguLi5hcmdzKSB7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCAuLi5hcmdzKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbmZpZ3VyYWJsZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvY29uZmlndXJhYmxlLmpzXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZmFpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXHJcbnZhciAka2V5cyAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcclxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pe1xyXG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Byb2Nlc3MvYnJvd3Nlci5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4gLyoqXG4gICogVGhlIGF2YWlsYWJsZSByZW5kZXIgdHlwZXNcbiAgKiBAZW51bSB7U3RyaW5nfVxuICAqIEBhbGlhcyBSZW5kZXJUeXBlXG4gICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gICovXG5leHBvcnQgY29uc3QgUmVuZGVyVHlwZSA9IHtcbiAgSU1BR0U6ICdpbWFnZScsXG4gIERBVEFVUkw6ICdkYXRhLXVybCcsXG4gIEJVRkZFUjogJ2J1ZmZlcicsXG4gIEJMT0I6ICdibG9iJyxcbiAgTVNCTE9COiAnbXMtYmxvYidcbn1cblxuLyoqXG4gKiBUaGUgYXZhaWxhYmxlIGltYWdlIHR5cGVzXG4gKiBAZW51bSB7U3RyaW5nfVxuICogQGFsaWFzIEltYWdlRm9ybWF0XG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqL1xuZXhwb3J0IGNvbnN0IEltYWdlRm9ybWF0ID0ge1xuICBQTkc6ICdpbWFnZS9wbmcnLFxuICBKUEVHOiAnaW1hZ2UvanBlZydcbn1cblxuZXhwb3J0IGNvbnN0IEV2ZW50cyA9IHtcbiAgT1BFUkFUSU9OX1VQREFURUQ6ICdvcGVyYXRpb246dXBkYXRlJ1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9jb25zdGFudHMuanNcbiAqKi8iLCIvKiFcbiAqIEV4dHJhY3RlZCBmcm9tIE1pbmlmeUpwZWcgKENvcHlyaWdodCAoYykgMjAxNCBIaXJvYWtpIE1hdG9iYSwgTUlUIExpY2Vuc2UpOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hNYXRvYmEvTWluaWZ5SnBlZ1xuICovXG5cbmNvbnN0IEtFWV9TVFIgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cbi8qKlxuICogUHJvdmlkZXMgQmFzZTY0IGVuY29kZSBhbmQgZGVjb2RlIG1ldGhvZHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbmNvbnN0IEJhc2U2NCA9IHtcbiAgLyoqXG4gICAqIEVuY29kZXMgdGhlIGdpdmVuIGlucHV0IGludG8gYSBCYXNlNjQgc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gaW5wdXRcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZW5jb2RlIChpbnB1dCkge1xuICAgIGxldCBvdXRwdXQgPSAnJ1xuICAgIGxldCBjaHIxLCBjaHIyLCBjaHIzXG4gICAgbGV0IGVuYzEsIGVuYzIsIGVuYzMsIGVuYzRcbiAgICBsZXQgaSA9IDBcblxuICAgIGRvIHtcbiAgICAgIGNocjEgPSBpbnB1dFtpKytdXG4gICAgICBjaHIyID0gaW5wdXRbaSsrXVxuICAgICAgY2hyMyA9IGlucHV0W2krK11cblxuICAgICAgZW5jMSA9IGNocjEgPj4gMlxuICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNClcbiAgICAgIGVuYzMgPSAoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KVxuICAgICAgZW5jNCA9IGNocjMgJiA2M1xuXG4gICAgICBpZiAoaXNOYU4oY2hyMikpIHtcbiAgICAgICAgZW5jMyA9IGVuYzQgPSA2NFxuICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICBlbmM0ID0gNjRcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ID0gb3V0cHV0ICtcbiAgICAgICAgIEtFWV9TVFIuY2hhckF0KGVuYzEpICtcbiAgICAgICAgIEtFWV9TVFIuY2hhckF0KGVuYzIpICtcbiAgICAgICAgIEtFWV9TVFIuY2hhckF0KGVuYzMpICtcbiAgICAgICAgIEtFWV9TVFIuY2hhckF0KGVuYzQpXG4gICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSAnJ1xuICAgICAgZW5jMSA9IGVuYzIgPSBlbmMzID0gZW5jNCA9ICcnXG4gICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aClcblxuICAgIHJldHVybiBvdXRwdXRcbiAgfSxcblxuICAvKipcbiAgICogRGVjb2RlcyB0aGUgZ2l2ZW4gQmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlucHV0XG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGRlY29kZSAoaW5wdXQpIHtcbiAgICBsZXQgY2hyMSwgY2hyMiwgY2hyM1xuICAgIGxldCBlbmMxLCBlbmMyLCBlbmMzLCBlbmM0XG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IGJ1ZiA9IFtdXG5cbiAgICAvLyByZW1vdmUgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IEEtWiwgYS16LCAwLTksICssIC8sIG9yID1cbiAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZ1xuICAgIGlmIChiYXNlNjR0ZXN0LmV4ZWMoaW5wdXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIHdlcmUgaW52YWxpZCBiYXNlNjQgY2hhcmFjdGVycyBpbiB0aGUgaW5wdXQgdGV4dC5cXG4nICtcbiAgICAgICAgICAgICdWYWxpZCBiYXNlNjQgY2hhcmFjdGVycyBhcmUgQS1aLCBhLXosIDAtOSwgXFwnK1xcJywgXFwnL1xcJyxhbmQgXFwnPVxcJ1xcbicgK1xuICAgICAgICAgICAgJ0V4cGVjdCBlcnJvcnMgaW4gZGVjb2RpbmcuJylcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpXG5cbiAgICBkbyB7XG4gICAgICBlbmMxID0gS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKVxuICAgICAgZW5jMiA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSlcbiAgICAgIGVuYzMgPSBLRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpXG4gICAgICBlbmM0ID0gS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKVxuXG4gICAgICBjaHIxID0gKGVuYzEgPDwgMikgfCAoZW5jMiA+PiA0KVxuICAgICAgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpXG4gICAgICBjaHIzID0gKChlbmMzICYgMykgPDwgNikgfCBlbmM0XG5cbiAgICAgIGJ1Zi5wdXNoKGNocjEpXG5cbiAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICBidWYucHVzaChjaHIyKVxuICAgICAgfVxuICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIGJ1Zi5wdXNoKGNocjMpXG4gICAgICB9XG5cbiAgICAgIGNocjEgPSBjaHIyID0gY2hyMyA9ICcnXG4gICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJydcbiAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKVxuXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2U2NFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYmFzZTY0LmpzXG4gKiovIiwiLyohXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXhpZi1qcy9leGlmLWpzIGJ5IEphY29iIFNlaWRlbGluXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQmFzZTY0IGZyb20gJy4vYmFzZTY0J1xuXG5jb25zdCBFWElGX1RBR1MgPSB7XG4gIDB4MDEwMDogJ0ltYWdlV2lkdGgnLFxuICAweDAxMDE6ICdJbWFnZUhlaWdodCcsXG4gIDB4ODc2OTogJ0V4aWZJRkRQb2ludGVyJyxcbiAgMHg4ODI1OiAnR1BTSW5mb0lGRFBvaW50ZXInLFxuICAweEEwMDU6ICdJbnRlcm9wZXJhYmlsaXR5SUZEUG9pbnRlcicsXG4gIDB4MDEwMjogJ0JpdHNQZXJTYW1wbGUnLFxuICAweDAxMDM6ICdDb21wcmVzc2lvbicsXG4gIDB4MDEwNjogJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAweDAxMTI6ICdPcmllbnRhdGlvbicsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAyMTI6ICdZQ2JDclN1YlNhbXBsaW5nJyxcbiAgMHgwMjEzOiAnWUNiQ3JQb3NpdGlvbmluZycsXG4gIDB4MDExQTogJ1hSZXNvbHV0aW9uJyxcbiAgMHgwMTFCOiAnWVJlc29sdXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExMTogJ1N0cmlwT2Zmc2V0cycsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNzogJ1N0cmlwQnl0ZUNvdW50cycsXG4gIDB4MDIwMTogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdCcsXG4gIDB4MDIwMjogJ0pQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aCcsXG4gIDB4MDEyRDogJ1RyYW5zZmVyRnVuY3Rpb24nLFxuICAweDAxM0U6ICdXaGl0ZVBvaW50JyxcbiAgMHgwMTNGOiAnUHJpbWFyeUNocm9tYXRpY2l0aWVzJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxMEU6ICdJbWFnZURlc2NyaXB0aW9uJyxcbiAgMHgwMTBGOiAnTWFrZScsXG4gIDB4MDExMDogJ01vZGVsJyxcbiAgMHgwMTMxOiAnU29mdHdhcmUnLFxuICAweDAxM0I6ICdBcnRpc3QnLFxuICAweDgyOTg6ICdDb3B5cmlnaHQnXG59XG5cbmNvbnN0IERBVEFfSlBFR19QUkVGSVggPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnXG5jb25zdCBKUEVHX1JFR0VYID0gbmV3IFJlZ0V4cChgXiR7REFUQV9KUEVHX1BSRUZJWH1gLCAnaScpXG5cbmltcG9ydCBBcnJheVN0cmVhbSBmcm9tICcuL2FycmF5LXN0cmVhbSdcblxuLyoqXG4gKiBSZWFkcyBFWElGIHRhZ3MgZnJvbSB0aGUgZ2l2ZW4gYnl0ZSBhcnJheSBhbmQgcmVzdG9yZXMgdGhlbVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgRVhJRiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEVYSUYgb2JqZWN0XG4gICAqIEBwYXJhbSAge0FycmF5fSBidWZcbiAgICovXG4gIGNvbnN0cnVjdG9yIChidWYpIHtcbiAgICB0aGlzLl9idWYgPSBidWZcbiAgICB0aGlzLl9zdHJlYW0gPSBuZXcgQXJyYXlTdHJlYW0odGhpcy5fYnVmKVxuICAgIHRoaXMuX3N0cmVhbS5zZXRIZWFkKDApXG5cbiAgICB0aGlzLl9zZWdtZW50cyA9IHRoaXMuX3NsaWNlSW50b1NlZ21lbnRzKHRoaXMuX2J1ZilcbiAgICB0aGlzLl9leGlmQnVmZmVyID0gdGhpcy5fZ2V0RXhpZkJ1ZmZlcigpXG4gICAgdGhpcy5fZXhpZlN0cmVhbSA9IG5ldyBBcnJheVN0cmVhbSh0aGlzLl9leGlmQnVmZmVyKVxuICAgIHRoaXMuX3BhcnNlRXhpZigpXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGV4aWYgdGFncyBpbnRvIHRoZSBnaXZlbiBkYXRhIHVybFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NFN0cmluZ1xuICAgKi9cbiAgcmVzdG9yZUV4aWZUYWdzIChiYXNlNjRTdHJpbmcpIHtcbiAgICAvLyBGaXJzdCwgbWFrZSB0aGUgZ2l2ZW4gc3RyaW5nIGEgZGF0YSBhcnJheVxuICAgIGNvbnN0IHJhdyA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKERBVEFfSlBFR19QUkVGSVgsICcnKVxuICAgIGNvbnN0IGRhdGEgPSBCYXNlNjQuZGVjb2RlKHJhdylcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5fc2xpY2VJbnRvU2VnbWVudHMoZGF0YSlcbiAgICBjb25zdCBzZWdtZW50U3RhcnQgPSBzZWdtZW50c1sxXVswXVxuICAgIGNvbnN0IGRhdGFCZWZvcmUgPSBkYXRhLnNsaWNlKDAsIHNlZ21lbnRTdGFydClcbiAgICBjb25zdCBkYXRhQWZ0ZXIgPSBkYXRhLnNsaWNlKHNlZ21lbnRTdGFydClcblxuICAgIGxldCBuZXdEYXRhID0gZGF0YUJlZm9yZS5jb25jYXQodGhpcy5fZXhpZkJ1ZmZlcilcbiAgICBuZXdEYXRhID0gbmV3RGF0YS5jb25jYXQoZGF0YUFmdGVyKVxuXG4gICAgLy8gTWFrZSBpdCBhIGJhc2U2NCBzdHJpbmcgYWdhaW5cbiAgICByZXR1cm4gREFUQV9KUEVHX1BSRUZJWCArIEJhc2U2NC5lbmNvZGUobmV3RGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIHRoZSBvcmllbnRhdGlvbiB3aXRoIHRoZSBnaXZlbiAxNiBiaXQgaW50ZWdlclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3JpZW50YXRpb25cbiAgICovXG4gIHNldE9yaWVudGF0aW9uIChvcmllbnRhdGlvbikge1xuICAgIGlmICh0aGlzLl90YWdEYXRhLk9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCB7IGVudHJ5T2Zmc2V0IH0gPSB0aGlzLl90YWdEYXRhLk9yaWVudGF0aW9uXG4gICAgICAvLyBSZXBsYWNlIHZhbHVlIGluIGJ1ZmZlclxuICAgICAgdGhpcy5fZXhpZlN0cmVhbS5zZXRIZWFkKGVudHJ5T2Zmc2V0ICsgOClcbiAgICAgIHRoaXMuX2V4aWZTdHJlYW0ud3JpdGVJbnQxNihvcmllbnRhdGlvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGJhc2U2NCBkYXRhIHVybCBpcyBhIGpwZWcgaW1hZ2VcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgYmFzZTY0U3RyaW5nXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNKUEVHIChiYXNlNjRTdHJpbmcpIHtcbiAgICByZXR1cm4gSlBFR19SRUdFWC50ZXN0KGJhc2U2NFN0cmluZylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEV4aWYgZnJvbSB0aGUgZ2l2ZW4gYmFzZTY0LWVuY29kZWRcbiAgICogc3RyaW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gYmFzZTY0U3RyaW5nXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkV4aWZ9XG4gICAqL1xuICBzdGF0aWMgZnJvbUJhc2U2NFN0cmluZyAoYmFzZTY0U3RyaW5nKSB7XG4gICAgY29uc3QgcmF3ID0gYmFzZTY0U3RyaW5nLnJlcGxhY2UoREFUQV9KUEVHX1BSRUZJWCwgJycpXG4gICAgY29uc3QgZGF0YSA9IEJhc2U2NC5kZWNvZGUocmF3KVxuICAgIHJldHVybiBuZXcgRVhJRihkYXRhKVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZXhpZiB0YWdzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wYXJzZUV4aWYgKCkge1xuICAgIHRoaXMuX2V4aWZTdHJlYW0uc2V0SGVhZCgwKVxuICAgIC8vIFNraXAgbWFya2VyXG4gICAgdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MTYoKVxuICAgIC8vIFNraXAgbGVuZ3RoXG4gICAgdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MTYoKVxuXG4gICAgY29uc3QgaGVhZGVyID0gdGhpcy5fZXhpZlN0cmVhbS5yZWFkU3RyaW5nKDQpXG4gICAgaWYgKGhlYWRlciAhPT0gJ0V4aWYnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTa2lwIDIgYnl0ZXNcbiAgICB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpXG5cbiAgICBjb25zdCB0aWZmT2Zmc2V0ID0gdGhpcy5fZXhpZlN0cmVhbS5nZXRIZWFkKClcblxuICAgIC8vIEZpbmQgZW5kaWFuIHR5cGVcbiAgICBsZXQgYmlnRW5kaWFuID0gZmFsc2VcbiAgICBjb25zdCBlbmRpYW4gPSB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpXG4gICAgaWYgKGVuZGlhbiA9PT0gMHg0OTQ5KSB7XG4gICAgICBiaWdFbmRpYW4gPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAweDRkNGQpIHtcbiAgICAgIGJpZ0VuZGlhbiA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFRJRkYgZGF0YTogTm8gZW5kaWFuIHR5cGUgZm91bmQnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNighYmlnRW5kaWFuKSAhPT0gMHgwMDJBKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhOiBObyAweDAwMkEnKVxuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gdGhpcy5fZXhpZlN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbilcbiAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCA4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhOiBGaXJzdCBJRkQgb2Zmc2V0IDwgOCcpXG4gICAgfVxuXG4gICAgY29uc3QgaWZkT2Zmc2V0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0XG4gICAgY29uc3QgdGFncyA9IHRoaXMuX3JlYWRUYWdzKHRoaXMuX2V4aWZTdHJlYW0sIHRpZmZPZmZzZXQsIGlmZE9mZnNldCwgYmlnRW5kaWFuKVxuICAgIHRoaXMuX3RhZ3MgPSB0YWdzLnRhZ3NcbiAgICB0aGlzLl90YWdEYXRhID0gdGFncy50YWdEYXRhXG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIFRJRkYgdGFncyBmcm9tIHRoZSBzdHJlYW1cbiAgICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9IHN0cmVhbVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpZmZTdGFydCBUaGUgcG9zaXRpb24gd2hlcmUgdGlmZiBkYXRhIHN0YXJ0c1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlmZFN0YXJ0ICBUaGUgcG9zaXRpb24gd2hlcmUgdGhlIElGRCBzdGFydHNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gYmlnRW5kaWFuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZWFkVGFncyAoc3RyZWFtLCB0aWZmU3RhcnQsIGlmZFN0YXJ0LCBiaWdFbmRpYW4pIHtcbiAgICBzdHJlYW0uc2V0SGVhZChpZmRTdGFydClcbiAgICBjb25zdCBlbnRyaWVzQ291bnQgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgbGV0IHRhZ3MgPSB7fVxuICAgIGxldCB0YWdEYXRhID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gaWZkU3RhcnQgKyBpICogMTIgKyAyXG4gICAgICBzdHJlYW0uc2V0SGVhZChlbnRyeU9mZnNldClcbiAgICAgIGxldCB0YWcgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgICBsZXQgdHlwZVxuICAgICAgbGV0IG51bVZhbHVlc1xuICAgICAgbGV0IHZhbHVlT2Zmc2V0XG4gICAgICBpZiAoRVhJRl9UQUdTW3RhZ10pIHtcbiAgICAgICAgdGFnID0gRVhJRl9UQUdTW3RhZ11cbiAgICAgICAgdHlwZSA9IHN0cmVhbS5yZWFkSW50MTYoIWJpZ0VuZGlhbilcbiAgICAgICAgbnVtVmFsdWVzID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICB2YWx1ZU9mZnNldCA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbikgKyB0aWZmU3RhcnRcbiAgICAgICAgbGV0IHZhbHVlID0gbnVsbFxuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMTogLy8gYnl0ZSwgOC1iaXQgdW5zaWduZWQgaW50XG4gICAgICAgICAgY2FzZSA3OiAvLyB1bmRlZmluZWQsIDgtYml0IGJ5dGUsIHZhbHVlIGRlcGVuZGluZyBvbiBmaWVsZFxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmVhbS5yZWFkSW50OCghYmlnRW5kaWFuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDgoIWJpZ0VuZGlhbikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAyOiAvLyA4LWJpdCBhc2NpaSBjaGFyXG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiA0ID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KSlcbiAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRTdHJpbmcobnVtVmFsdWVzKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDM6IC8vIHNob3J0XG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiAyID8gdmFsdWVPZmZzZXQgOiAoZW50cnlPZmZzZXQgKyA4KSlcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IFtdXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHN0cmVhbS5yZWFkSW50MTYoIWJpZ0VuZGlhbikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSA0OiAvLyBsb25nXG4gICAgICAgICAgY2FzZSA5OiAvLyBzbG9uZ1xuICAgICAgICAgICAgc3RyZWFtLnNldEhlYWQobnVtVmFsdWVzID4gMSA/IHZhbHVlT2Zmc2V0IDogKGVudHJ5T2Zmc2V0ICsgOCkpXG4gICAgICAgICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDMyKCFiaWdFbmRpYW4pKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgNTogLy8gcmF0aW9uYWwgKHR3byBsb25nIHZhbHVlcywgZmlyc3QgbnVtZXJhdG9yLCBzZWNvbmQgZGVub21pbmF0b3IpXG4gICAgICAgICAgY2FzZSAxMDogLy8gcmF0aW9uYWwgKHR3byBzbG9uZ3MpXG4gICAgICAgICAgICBzdHJlYW0uc2V0SGVhZCh2YWx1ZU9mZnNldClcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICBjb25zdCBkZW5vbWluYXRvciA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbilcbiAgICAgICAgICAgICAgdmFsdWUgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvclxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBbXVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yXG4gICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2YWwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICB0YWdzW3RhZ10gPSB2YWx1ZVxuICAgICAgICB0YWdEYXRhW3RhZ10gPSB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbnVtVmFsdWVzLFxuICAgICAgICAgIGVudHJ5T2Zmc2V0LFxuICAgICAgICAgIHZhbHVlT2Zmc2V0LFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRhZ3MsIHRhZ0RhdGEgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIEV4aWYgc2VnbWVudFxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRFeGlmQnVmZmVyICgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gc2VnbWVudHNbaV1bMF1cbiAgICAgIGNvbnN0IGVuZCA9IHNlZ21lbnRzW2ldWzFdXG4gICAgICB0aGlzLl9zdHJlYW0uc2V0SGVhZChvZmZzZXQpXG4gICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLl9zdHJlYW0ucGVla0ludDE2KClcbiAgICAgIGlmIChtYXJrZXIgPT09IDB4ZmZlMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLnNsaWNlKG9mZnNldCwgZW5kKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBTbGljZXMgdGhlIGFycmF5IGludG8gc2VnbWVudHNcbiAgICogQHBhcmFtICB7QXJyYXkuPE51bWJlcj59IGJ1ZlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zbGljZUludG9TZWdtZW50cyAoYnVmKSB7XG4gICAgbGV0IHN0cmVhbSA9IG5ldyBBcnJheVN0cmVhbShidWYpXG4gICAgbGV0IHNlZ21lbnRzID0gW11cbiAgICB3aGlsZSAoc3RyZWFtLmdldEhlYWQoKSA8IGJ1Zi5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1hcmtlciA9IHN0cmVhbS5yZWFkSW50MTYoKVxuICAgICAgaWYgKG1hcmtlciA9PT0gMHhmZmQ4KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IC8vIFNPSVxuICAgICAgaWYgKG1hcmtlciA9PT0gMHhmZmRhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IC8vIFNPUyBNYXJrZXJcblxuICAgICAgaWYgKG1hcmtlciA+PSAweGZmMDAgJiYgbWFya2VyIDw9IDB4ZmZmZikge1xuICAgICAgICAvLyBNYXJrZXIgKEZGLVhYLUhMLUxMKVxuICAgICAgICBjb25zdCBsZW5ndGggPSBzdHJlYW0ucmVhZEludDE2KClcbiAgICAgICAgY29uc3QgZW5kID0gc3RyZWFtLmdldEhlYWQoKSArIGxlbmd0aCAtIDJcbiAgICAgICAgc2VnbWVudHMucHVzaChbc3RyZWFtLmdldEhlYWQoKSAtIDQsIGVuZF0pXG4gICAgICAgIHN0cmVhbS5zZXRIZWFkKGVuZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXJrZXI6IDB4JyArIG1hcmtlci50b1N0cmluZygxNikpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtLnNldEhlYWQoMClcblxuICAgIHJldHVybiBzZWdtZW50c1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhZ3NcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0VGFncyAoKSB7IHJldHVybiB0aGlzLl90YWdzIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFnIGRhdGEgKGtleSwgdmFsdWUsIGJ5dGUgcG9zaXRpb24gZXRjLilcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRUYWdEYXRhICgpIHsgcmV0dXJuIHRoaXMuX3RhZ0RhdGEgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIEVYSUYgb2JqZWN0XG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9idWYgPSBbXVxuICAgIHRoaXMuX2V4aWZCdWZmZXIgPSBbXVxuICAgIHRoaXMuX3NlZ21lbnRzID0gW11cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFWElGXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9leGlmLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBNYXRyaXgsIFZlY3RvcjIsIFJlY3RhbmdsZSB9IGZyb20gJy4uL2dsb2JhbHMnXG5cbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBvYmplY3RzIHRoYXQgY2FuIGJlIGRpc3BsYXllZFxuICogb24gdGhlIHNjcmVlblxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIERpc3BsYXlPYmplY3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIERpc3BsYXlPYmplY3RcbiAgICovXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IG5ldyBWZWN0b3IyKDAsIDApXG4gICAgdGhpcy5fc2NhbGUgPSBuZXcgVmVjdG9yMigxLCAxKVxuICAgIHRoaXMuX3Bpdm90ID0gbmV3IFZlY3RvcjIoMCwgMClcbiAgICB0aGlzLl9yb3RhdGlvbiA9IDBcbiAgICB0aGlzLl9sYXN0Um90YXRpb24gPSBudWxsXG4gICAgdGhpcy5fYWxwaGEgPSAxXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWVcbiAgICB0aGlzLl93b3JsZFRyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKVxuICAgIHRoaXMuX3BhcmVudCA9IG51bGxcbiAgICB0aGlzLl9zaGFkZXJzID0gW11cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSlcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpXG4gICAgdGhpcy5fdGludCA9IDB4ZmZmZmZmXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIERpc3BsYXlPYmplY3QgdXNpbmcgdGhlIGdpdmVuIFdlYkdMUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYHJlbmRlcldlYkdMYCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcycpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIERpc3BsYXlPYmplY3QgdXNpbmcgdGhlIGdpdmVuIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICByZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYHJlbmRlckNhbnZhc2AgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHdvcmxkIHRyYW5zZm9ybSBmb3IgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqL1xuICB1cGRhdGVUcmFuc2Zvcm0gKCkge1xuICAgIGNvbnN0IHBhcmVudFRyYW5zZm9ybSA9IHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5nZXRXb3JsZFRyYW5zZm9ybSgpIDogTWF0cml4LklERU5USVRZXG4gICAgY29uc3Qgd29ybGRUcmFuc2Zvcm0gPSB0aGlzLl93b3JsZFRyYW5zZm9ybVxuXG4gICAgLy8gT25seSBidWlsZCByb3RhdGlvbiBtYXRyaXggaWYgcm90YXRpb24gaGFzIGNoYW5nZWQgc2luY2UgbGFzdCB1cGRhdGVcbiAgICBjb25zdCByb3RhdGlvbkNoYW5nZWQgPSB0aGlzLl9yb3RhdGlvbiAhPT0gdGhpcy5fbGFzdFJvdGF0aW9uXG4gICAgaWYgKHJvdGF0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fc2luUm90YXRpb24gPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbilcbiAgICAgIHRoaXMuX2Nvc1JvdGF0aW9uID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24pXG4gICAgICB0aGlzLl9sYXN0Um90YXRpb24gPSB0aGlzLl9yb3RhdGlvblxuICAgIH1cblxuICAgIHdvcmxkVHJhbnNmb3JtLmEgPSB0aGlzLl9jb3NSb3RhdGlvbiAqIHRoaXMuX3NjYWxlLnhcbiAgICB3b3JsZFRyYW5zZm9ybS5iID0gdGhpcy5fc2luUm90YXRpb24gKiB0aGlzLl9zY2FsZS54XG4gICAgd29ybGRUcmFuc2Zvcm0uYyA9IC10aGlzLl9zaW5Sb3RhdGlvbiAqIHRoaXMuX3NjYWxlLnlcbiAgICB3b3JsZFRyYW5zZm9ybS5kID0gdGhpcy5fY29zUm90YXRpb24gKiB0aGlzLl9zY2FsZS55XG4gICAgd29ybGRUcmFuc2Zvcm0udHggPSB0aGlzLl9wb3NpdGlvbi54XG4gICAgd29ybGRUcmFuc2Zvcm0udHkgPSB0aGlzLl9wb3NpdGlvbi55XG5cbiAgICBpZiAodGhpcy5fcGl2b3QueCB8fCB0aGlzLl9waXZvdC55KSB7XG4gICAgICB3b3JsZFRyYW5zZm9ybS50eCAtPSB0aGlzLl9waXZvdC54ICogd29ybGRUcmFuc2Zvcm0uYSArIHRoaXMuX3Bpdm90LnkgKiB3b3JsZFRyYW5zZm9ybS5jXG4gICAgICB3b3JsZFRyYW5zZm9ybS50eSAtPSB0aGlzLl9waXZvdC54ICogd29ybGRUcmFuc2Zvcm0uYiArIHRoaXMuX3Bpdm90LnkgKiB3b3JsZFRyYW5zZm9ybS5kXG4gICAgfVxuXG4gICAgd29ybGRUcmFuc2Zvcm0ubXVsdGlwbHkocGFyZW50VHJhbnNmb3JtKVxuXG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTSEFERVJTXG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0aGUgZ2l2ZW4gc2hhZGVyIHRvIHRoZSBsaXN0IG9mIHNoYWRlcnNcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyfSBzaGFkZXJcbiAgICovXG4gIGFkZFNoYWRlciAoc2hhZGVyKSB7XG4gICAgdGhpcy5fc2hhZGVycy5wdXNoKHNoYWRlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzaGFkZXIgZnJvbSB0aGUgbGlzdCBvZiBzaGFkZXJzXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TaGFkZXJ9IHNoYWRlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgcmVtb3ZlU2hhZGVyIChzaGFkZXIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX3NoYWRlcnMuaW5kZXhPZihzaGFkZXIpXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fc2hhZGVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzaGFkZXIgYXQgdGhlIGdpdmVuIGluZGV4IGZyb20gdGhlIGxpc3Qgb2Ygc2hhZGVyc1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICByZW1vdmVTaGFkZXJBdCAoaW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuX3NoYWRlcnNbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5fc2hhZGVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEJvdW5kcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5jbG9uZSgpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBHRVRURVJTIC8gU0VUVEVSU1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldFBvc2l0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcG9zaXRpb24gdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMnxOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKi9cbiAgc2V0UG9zaXRpb24gKHBvc2l0aW9uLCB5KSB7XG4gICAgaWYgKHBvc2l0aW9uIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy5fcG9zaXRpb24uY29weShwb3NpdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9zaXRpb24uc2V0KHBvc2l0aW9uLCB5KVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNjYWxlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldFNjYWxlICgpIHsgcmV0dXJuIHRoaXMuX3NjYWxlIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2NhbGUgdG8gdGhlIGdpdmVuIG9uZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMnxOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5XVxuICAgKi9cbiAgc2V0U2NhbGUgKHNjYWxlLCB5KSB7XG4gICAgaWYgKHNjYWxlIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy5fc2NhbGUuY29weShzY2FsZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NhbGUuc2V0KHNjYWxlLCB5KVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBpdm90IChUaGUgcG9pbnQgdGhhdCB0aGlzIERpc3BsYXlvYmplY3Qgcm90YXRlcyBhcm91bmQpXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldFBpdm90ICgpIHsgcmV0dXJuIHRoaXMuX3Bpdm90IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGl2b3QgKFRoZSBwb2ludCB0aGF0IHRoaXMgRGlzcGxheU9iamVjdCByb3RhdGVzIGFyb3VuZClcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ8TnVtYmVyfSBwaXZvdFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ldXG4gICAqL1xuICBzZXRQaXZvdCAocGl2b3QsIHkpIHtcbiAgICBpZiAocGl2b3QgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLl9waXZvdC5jb3B5KHBpdm90KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9waXZvdC5zZXQocGl2b3QsIHkpXG4gICAgfVxuICAgIHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcm90YXRpb24gaW4gcmFkaWFuc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRSb3RhdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb3RhdGlvbiB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBvYmplY3QncyByb3RhdGlvbiAoaW4gcmFkaWFucylcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdGF0aW9uXG4gICAqL1xuICBzZXRSb3RhdGlvbiAocm90YXRpb24pIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHJvdGF0aW9uXG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBhbHBoYSAoMC4uLjEpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldEFscGhhICgpIHsgcmV0dXJuIHRoaXMuX2FscGhhIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYWxwaGEgKDAuLi4xKVxuICAgKiBAcGFyYW0ge051bWJlcn0gYWxwaGFcbiAgICovXG4gIHNldEFscGhhIChhbHBoYSkgeyB0aGlzLl9hbHBoYSA9IGFscGhhIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgYWxwaGEgb2YgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFdvcmxkQWxwaGEgKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQuZ2V0QWxwaGEoKSAqIHRoaXMuX2FscGhhXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbHBoYVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHdvcmxkIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLk1hdHJpeH1cbiAgICovXG4gIGdldFdvcmxkVHJhbnNmb3JtICgpIHsgcmV0dXJuIHRoaXMuX3dvcmxkVHJhbnNmb3JtIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IG9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH1cbiAgICovXG4gIGdldFBhcmVudCAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgb2JqZWN0J3MgcGFyZW50IG9iamVjdFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBwYXJlbnRcbiAgICovXG4gIHNldFBhcmVudCAocGFyZW50KSB7IHRoaXMuX3BhcmVudCA9IHBhcmVudCB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGludCBjb2xvclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRUaW50ICgpIHsgcmV0dXJuIHRoaXMuX3RpbnQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aW50IGNvbG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW50XG4gICAqL1xuICBzZXRUaW50ICh0aW50KSB7IHRoaXMuX3RpbnQgPSB0aW50IH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBvYmplY3QgaXMgY3VycmVudGx5IHZpc2libGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgaXNWaXNpYmxlICgpIHsgcmV0dXJuIHRoaXMuX3Zpc2libGUgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgb2JqZWN0J3MgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICovXG4gIHNldFZpc2libGUgKHZpc2libGUpIHsgdGhpcy5fdmlzaWJsZSA9IHZpc2libGUgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEaXNwbGF5T2JqZWN0XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS9kaXNwbGF5L2Rpc3BsYXktb2JqZWN0LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUmVjdGFuZ2xlIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBDYW52YXNSZW5kZXJUYXJnZXQgZnJvbSAnLi4vdXRpbHMvY2FudmFzLXJlbmRlci10YXJnZXQnXG5cbi8qKlxuICogTWFuYWdlcyB0aGUgZmlsdGVycyBmb3IgYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyfVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIENhbnZhc0ZpbHRlck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyXG4gICAgdGhpcy5fZmlsdGVyU3RhY2sgPSBbe1xuICAgICAgcmVuZGVyVGFyZ2V0OiByZW5kZXJlci5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCksXG4gICAgICBmaWx0ZXJzOiBbXVxuICAgIH1dXG5cbiAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXVxuICAgIHRoaXMuX3RleHR1cmVGcmFtZSA9IG5ldyBSZWN0YW5nbGUoXG4gICAgICAwLCAwLFxuICAgICAgcmVuZGVyZXIuZ2V0V2lkdGgoKSwgcmVuZGVyZXIuZ2V0SGVpZ2h0KClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGlzIEZpbHRlck1hbmFnZXIgYW5kIGl0cyB0ZXh0dXJlcyB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lLndpZHRoID0gZGltZW5zaW9ucy54XG4gICAgdGhpcy5fdGV4dHVyZUZyYW1lLmhlaWdodCA9IGRpbWVuc2lvbnMueVxuXG4gICAgdGhpcy5fdGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4gdGV4dHVyZS5yZXNpemVUbyhkaW1lbnNpb25zKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIGdpdmVuIGZpbHRlcnMgdG8gdGhlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge0FycmF5LjxGaWx0ZXI+fSBmaWx0ZXJzXG4gICAqL1xuICBwdXNoRmlsdGVycyAoZGlzcGxheU9iamVjdCwgZmlsdGVycykge1xuICAgIGNvbnN0IGJvdW5kcyA9IGRpc3BsYXlPYmplY3QuZ2V0Qm91bmRzKClcbiAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBib3VuZHNcblxuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHRoaXMuX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0KClcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX2ZpbHRlclN0YWNrLnB1c2goeyByZW5kZXJUYXJnZXQsIGZpbHRlcnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzLCBhcHBsaWVzIGFuZCByZXR1cm5zIHRoZSBsYXN0IGZpbHRlcnMgZnJvbSB0aGUgc3RhY2tcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcG9wRmlsdGVycyAoKSB7XG4gICAgY29uc3QgeyBmaWx0ZXJzLCByZW5kZXJUYXJnZXQgfSA9IHRoaXMuX2ZpbHRlclN0YWNrLnBvcCgpXG4gICAgY29uc3QgbGFzdEZpbHRlciA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICBjb25zdCBpbnB1dFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldFxuICAgIGNvbnN0IG91dHB1dFJlbmRlclRhcmdldCA9IGxhc3RGaWx0ZXIucmVuZGVyVGFyZ2V0XG5cbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcy5fcmVuZGVyZXIsIGlucHV0UmVuZGVyVGFyZ2V0LCBvdXRwdXRSZW5kZXJUYXJnZXQpXG4gICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKGlucHV0UmVuZGVyVGFyZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hcHBseUZpbHRlcnMoZmlsdGVycywgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcnNcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiBmaWx0ZXJzIHRvIHRoZSBnaXZlbiBpbnB1dFJlbmRlclRhcmdldCBhbmQgb3V0cHV0c1xuICAgKiB0aGUgZmlsdGVyZWQgY29udGVudCB0byB0aGUgb3V0cHV0UmVuZGVyVGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJbXX0gZmlsdGVyc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0fSBpbnB1dFJlbmRlclRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0fSBvdXRwdXRSZW5kZXJUYXJnZXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUZpbHRlcnMgKGZpbHRlcnMsIGlucHV0UmVuZGVyVGFyZ2V0LCBvdXRwdXRSZW5kZXJUYXJnZXQpIHtcbiAgICBsZXQgZmxpcFJlbmRlclRhcmdldCA9IGlucHV0UmVuZGVyVGFyZ2V0XG4gICAgbGV0IGZsb3BSZW5kZXJUYXJnZXQgPSB0aGlzLl9nZXRPckNyZWF0ZVJlbmRlclRhcmdldCh0cnVlKVxuXG4gICAgY29uc3QgbGFzdEZpbHRlciA9IGZpbHRlcnNbZmlsdGVycy5sZW5ndGggLSAxXVxuICAgIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyLCBpKSA9PiB7XG4gICAgICBjb25zdCBpc0xhc3RGaWx0ZXIgPSBmaWx0ZXIgPT09IGxhc3RGaWx0ZXJcblxuICAgICAgaWYgKCFpc0xhc3RGaWx0ZXIpIHtcbiAgICAgICAgLy8gUmVuZGVyIGZyb20gZmxpcCB0byBmbG9wIHdpdGggZmlsdGVyXG4gICAgICAgIGZpbHRlci5hcHBseSh0aGlzLl9yZW5kZXJlciwgZmxpcFJlbmRlclRhcmdldCwgZmxvcFJlbmRlclRhcmdldClcblxuICAgICAgICAvLyBGbGlwIHRoZSByZW5kZXIgYnVmZmVyc1xuICAgICAgICBsZXQgdGVtcCA9IGZsaXBSZW5kZXJUYXJnZXRcbiAgICAgICAgZmxpcFJlbmRlclRhcmdldCA9IGZsb3BSZW5kZXJUYXJnZXRcbiAgICAgICAgZmxvcFJlbmRlclRhcmdldCA9IHRlbXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbmRlciB0byBvdXRwdXRcbiAgICAgICAgZmlsdGVyLmFwcGx5KHRoaXMuX3JlbmRlcmVyLCBmbGlwUmVuZGVyVGFyZ2V0LCBvdXRwdXRSZW5kZXJUYXJnZXQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFB1c2ggdGhlIHRleHR1cmVzIGJhY2sgaW50byB0aGUgdGV4dHVyZSBwb29sIHRvIHVzZSB0aGVtIGFnYWluIGxhdGVyXG4gICAgdGhpcy5fdGV4dHVyZXMucHVzaChmbGlwUmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX3RleHR1cmVzLnB1c2goZmxvcFJlbmRlclRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVuZGVyIGJ1ZmZlciBmcm9tIHRoZSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUZXh0dXJlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0IChjbGVhcikge1xuICAgIGxldCByZW5kZXJUYXJnZXQgPSB0aGlzLl90ZXh0dXJlcy5wb3AoKVxuICAgIGlmICghcmVuZGVyVGFyZ2V0KSB7XG4gICAgICByZW5kZXJUYXJnZXQgPSBuZXcgQ2FudmFzUmVuZGVyVGFyZ2V0KHRoaXMuX3RleHR1cmVGcmFtZS53aWR0aCxcbiAgICAgICAgdGhpcy5fdGV4dHVyZUZyYW1lLmhlaWdodCxcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpKVxuICAgIH1cblxuICAgIGlmIChjbGVhcikge1xuICAgICAgcmVuZGVyVGFyZ2V0LmNsZWFyKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyIHN0YWNrIHRvIHRoZSBnaXZlbiBzdGFja1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBmaWx0ZXJTdGFja1xuICAgKi9cbiAgc2V0RmlsdGVyU3RhY2sgKGZpbHRlclN0YWNrKSB7XG4gICAgdGhpcy5fZmlsdGVyU3RhY2sgPSBmaWx0ZXJTdGFja1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgQ2FudmFzRmlsdGVyTWFuYWdlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYW52YXNGaWx0ZXJNYW5hZ2VyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS9tYW5hZ2Vycy9jYW52YXMtZmlsdGVyLW1hbmFnZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBSZWN0YW5nbGUgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFdlYkdMUmVuZGVyVGFyZ2V0IGZyb20gJy4uL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQnXG5pbXBvcnQgUXVhZCBmcm9tICcuLi91dGlscy9xdWFkJ1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGZpbHRlcnMgZm9yIGEge0BsaW5rIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBXZWJHTEZpbHRlck1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyXG4gICAgdGhpcy5fZmlsdGVyU3RhY2sgPSBbe1xuICAgICAgcmVuZGVyVGFyZ2V0OiByZW5kZXJlci5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCksXG4gICAgICBmaWx0ZXJzOiBbXVxuICAgIH1dXG5cbiAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBudWxsXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXVxuICAgIHRoaXMuX3RleHR1cmVGcmFtZSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgcmVuZGVyZXIuZ2V0V2lkdGgoKSwgcmVuZGVyZXIuZ2V0SGVpZ2h0KCkpXG5cbiAgICB0aGlzLl9vbkNvbnRleHRDaGFuZ2UgPSB0aGlzLl9vbkNvbnRleHRDaGFuZ2UuYmluZCh0aGlzKVxuICAgIHRoaXMuX3JlbmRlcmVyLm9uKCdjb250ZXh0JywgdGhpcy5fb25Db250ZXh0Q2hhbmdlKVxuXG4gICAgLy8gSW5pdGlhbCBjb250ZXh0XG4gICAgdGhpcy5fb25Db250ZXh0Q2hhbmdlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoaXMgRmlsdGVyTWFuYWdlciBhbmQgaXRzIHRleHR1cmVzIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl90ZXh0dXJlRnJhbWUud2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICB0aGlzLl90ZXh0dXJlRnJhbWUuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG5cbiAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLnJlc2l6ZVRvKGRpbWVuc2lvbnMpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbHRlciBzdGFjayB0byB0aGUgZ2l2ZW4gc3RhY2tcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gZmlsdGVyU3RhY2tcbiAgICovXG4gIHNldEZpbHRlclN0YWNrIChmaWx0ZXJTdGFjaykge1xuICAgIHRoaXMuX2ZpbHRlclN0YWNrID0gZmlsdGVyU3RhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVuZGVyIHRhcmdldCBmcm9tIHRoZSBwb29sIG9yIGNyZWF0ZXMgYSBuZXcgb25lXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlclRhcmdldH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRPckNyZWF0ZVJlbmRlclRhcmdldCAoY2xlYXIpIHtcbiAgICBsZXQgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fdGV4dHVyZXMucG9wKClcbiAgICBpZiAoIXJlbmRlclRhcmdldCkge1xuICAgICAgcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMuX3JlbmRlcmVyLFxuICAgICAgICB0aGlzLl90ZXh0dXJlRnJhbWUud2lkdGgsXG4gICAgICAgIHRoaXMuX3RleHR1cmVGcmFtZS5oZWlnaHQsXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmdldFBpeGVsUmF0aW8oKSlcbiAgICB9XG4gICAgcmVuZGVyVGFyZ2V0LnNldEZyYW1lKHRoaXMuX2N1cnJlbnRGcmFtZSlcblxuICAgIGlmIChjbGVhcikge1xuICAgICAgcmVuZGVyVGFyZ2V0LmNsZWFyKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyVGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIHRoZSBnaXZlbiBmaWx0ZXJzIHRvIHRoZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyW119IGZpbHRlcnNcbiAgICovXG4gIHB1c2hGaWx0ZXJzIChkaXNwbGF5T2JqZWN0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgYm91bmRzID0gZGlzcGxheU9iamVjdC5nZXRCb3VuZHMoKVxuICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IGJvdW5kc1xuXG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gdGhpcy5fZ2V0T3JDcmVhdGVSZW5kZXJUYXJnZXQoKVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgcmVuZGVyVGFyZ2V0LmNsZWFyKClcblxuICAgIHRoaXMuX2ZpbHRlclN0YWNrLnB1c2goeyByZW5kZXJUYXJnZXQsIGZpbHRlcnMgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzLCBhcHBsaWVzIGFuZCByZXR1cm5zIHRoZSBsYXN0IGZpbHRlcnMgZnJvbSB0aGUgc3RhY2tcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgcG9wRmlsdGVycyAoKSB7XG4gICAgY29uc3QgeyBmaWx0ZXJzLCByZW5kZXJUYXJnZXQgfSA9IHRoaXMuX2ZpbHRlclN0YWNrLnBvcCgpXG4gICAgY29uc3QgbGFzdEZpbHRlciA9IHRoaXMuX2ZpbHRlclN0YWNrW3RoaXMuX2ZpbHRlclN0YWNrLmxlbmd0aCAtIDFdXG5cbiAgICBjb25zdCBpbnB1dFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldFxuICAgIGNvbnN0IG91dHB1dFJlbmRlclRhcmdldCA9IGxhc3RGaWx0ZXIucmVuZGVyVGFyZ2V0XG5cbiAgICAvLyBVcGRhdGUgdGhlIFF1YWQncyBidWZmZXJzXG4gICAgdGhpcy5fcXVhZC5tYXAodGhpcy5fdGV4dHVyZUZyYW1lLCBpbnB1dFJlbmRlclRhcmdldC5nZXRGcmFtZSgpKVxuXG4gICAgY29uc3Qgc2hhZGVyID0gZmlsdGVyc1swXS5nZXRTaGFkZXJGb3JSZW5kZXJlcih0aGlzLl9yZW5kZXJlcilcbiAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl9xdWFkLmdldFZlcnRleEJ1ZmZlcigpXG4gICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLl9xdWFkLmdldEluZGV4QnVmZmVyKClcblxuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcilcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlcilcblxuICAgIGNvbnN0IGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHNoYWRlci5nZXRBdHRyaWJ1dGVMb2NhdGlvbnMoKVxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0cmlidXRlTG9jYXRpb25zLmFfcG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMClcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9ucy5hX3RleENvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDIgKiA0ICogNClcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvY2F0aW9ucy5hX2NvbG9yLCA0LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDQgKiA0ICogNClcblxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLl9yZW5kZXJlciwgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2goaW5wdXRSZW5kZXJUYXJnZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FwcGx5RmlsdGVycyhmaWx0ZXJzLCBpbnB1dFJlbmRlclRhcmdldCwgb3V0cHV0UmVuZGVyVGFyZ2V0KVxuICAgIH1cblxuICAgIHJldHVybiBmaWx0ZXJzXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gZmlsdGVycyB0byB0aGUgZ2l2ZW4gaW5wdXRSZW5kZXJUYXJnZXQgYW5kIG91dHB1dHNcbiAgICogdGhlIGZpbHRlcmVkIGNvbnRlbnQgdG8gdGhlIG91dHB1dFJlbmRlclRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyW119IGZpbHRlcnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dFJlbmRlclRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dFJlbmRlclRhcmdldFxuICAgKi9cbiAgX2FwcGx5RmlsdGVycyAoZmlsdGVycywgaW5wdXRSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldCkge1xuICAgIGxldCBmbGlwUmVuZGVyVGFyZ2V0ID0gaW5wdXRSZW5kZXJUYXJnZXRcbiAgICBsZXQgZmxvcFJlbmRlclRhcmdldCA9IHRoaXMuX2dldE9yQ3JlYXRlUmVuZGVyVGFyZ2V0KHRydWUpXG5cbiAgICBjb25zdCBsYXN0RmlsdGVyID0gZmlsdGVyc1tmaWx0ZXJzLmxlbmd0aCAtIDFdXG4gICAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIsIGkpID0+IHtcbiAgICAgIGNvbnN0IGlzTGFzdEZpbHRlciA9IGZpbHRlciA9PT0gbGFzdEZpbHRlclxuXG4gICAgICBpZiAoIWlzTGFzdEZpbHRlcikge1xuICAgICAgICAvLyBSZW5kZXIgZnJvbSBmbGlwIHRvIGZsb3Agd2l0aCBmaWx0ZXJcbiAgICAgICAgZmlsdGVyLmFwcGx5KHRoaXMuX3JlbmRlcmVyLCBmbGlwUmVuZGVyVGFyZ2V0LCBmbG9wUmVuZGVyVGFyZ2V0KVxuXG4gICAgICAgIC8vIEZsaXAgdGhlIHJlbmRlciB0YXJnZXRzXG4gICAgICAgIGxldCB0ZW1wID0gZmxpcFJlbmRlclRhcmdldFxuICAgICAgICBmbGlwUmVuZGVyVGFyZ2V0ID0gZmxvcFJlbmRlclRhcmdldFxuICAgICAgICBmbG9wUmVuZGVyVGFyZ2V0ID0gdGVtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVuZGVyIHRvIG91dHB1dFxuICAgICAgICBmaWx0ZXIuYXBwbHkodGhpcy5fcmVuZGVyZXIsIGZsaXBSZW5kZXJUYXJnZXQsIG91dHB1dFJlbmRlclRhcmdldClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUHVzaCB0aGUgdGV4dHVyZXMgYmFjayBpbnRvIHRoZSB0ZXh0dXJlIHBvb2wgdG8gdXNlIHRoZW0gYWdhaW4gbGF0ZXJcbiAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKGZsaXBSZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fdGV4dHVyZXMucHVzaChmbG9wUmVuZGVyVGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgaGFzIGJlZW4gY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29udGV4dENoYW5nZSAoKSB7XG4gICAgdGhpcy5fdGV4dHVyZXMubGVuZ3RoID0gMFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLmlzT2ZUeXBlKCd3ZWJnbCcpKSB7XG4gICAgICB0aGlzLl9xdWFkID0gbmV3IFF1YWQodGhpcy5fcmVuZGVyZXIpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgV2ViR0xGaWx0ZXJNYW5hZ2VyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9yZW5kZXJlci5vZmYoJ2NvbnRleHQnLCB0aGlzLl9vbkNvbnRleHRDaGFuZ2UpXG4gICAgaWYgKHRoaXMuX3F1YWQpIHtcbiAgICAgIHRoaXMuX3F1YWQuZGlzcG9zZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMRmlsdGVyTWFuYWdlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvbWFuYWdlcnMvd2ViZ2wtZmlsdGVyLW1hbmFnZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgR2xvYmFscyBmcm9tICcuLi9nbG9iYWxzJ1xuY29uc3QgeyBMb2cgfSA9IEdsb2JhbHNcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgV2ViR0wgc2hhZGVyIHdpdGggYSB2ZXJ0ZXggc2hhZGVyLCBhIGZyYWdtZW50IHNoYWRlciwgdW5pZm9ybXMgYW5kIGF0dHJpYnV0ZXNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgU2hhZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTaGFkZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSB2ZXJ0ZXhTb3VyY2VcbiAgICogQHBhcmFtICB7U3RyaW5nfSBmcmFnbWVudFNvdXJjZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHVuaWZvcm1zXG4gICAqIEBwYXJhbSAge1N0cmluZ1tdfSBhdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocmVuZGVyZXIsIHZlcnRleFNvdXJjZSwgZnJhZ21lbnRTb3VyY2UsIHVuaWZvcm1zLCBhdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlclxuICAgIHRoaXMuX3ZlcnRleFNvdXJjZSA9IHZlcnRleFNvdXJjZVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gZnJhZ21lbnRTb3VyY2VcbiAgICB0aGlzLl91bmlmb3JtcyA9IHVuaWZvcm1zIHx8IHt9XG4gICAgdGhpcy5fdW5pZm9ybUxvY2F0aW9ucyA9IHt9XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgW11cbiAgICB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMgPSB7fVxuXG4gICAgdGhpcy5fb25Db250ZXh0Q2hhbmdlID0gdGhpcy5fb25Db250ZXh0Q2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLl9yZW5kZXJlci5vbignY29udGV4dCcsIHRoaXMuX29uQ29udGV4dENoYW5nZSlcblxuICAgIHRoaXMuX2luaXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIHRoaXMgc2hhZGVyIGFuZCBjYWNoZXMgdGhlIHVuaWZvcm0gbG9jYXRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdCAoKSB7XG4gICAgdGhpcy5fY29tcGlsZSgpXG5cbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5fcHJvZ3JhbSlcblxuICAgIHRoaXMuX2NhY2hlVW5pZm9ybUxvY2F0aW9ucygpXG4gICAgdGhpcy5fY2FjaGVBdHRyaWJ1dGVMb2NhdGlvbnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGF0dGFjaGVkIFJlbmRlcmVyIGNoYW5nZXMgaXRzIGNvbnRleHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbnRleHRDaGFuZ2UgKCkge1xuICAgIHRoaXMuX2luaXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIHRoZSBnaXZlbiBidWZmZXJzIGZvciB0aGlzIHNoYWRlclxuICAgKiBAcGFyYW0ge1dlYkdMQnVmZmVyfSB2ZXJ0ZXhCdWZmZXJcbiAgICogQHBhcmFtIHtXZWJHTEJ1ZmZlcn0gaW5kZXhCdWZmZXJcbiAgICovXG4gIHNldHVwQnVmZmVycyAodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcilcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEJ1ZmZlcilcblxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmlidXRlTG9jYXRpb25zLmFfcG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgR2xvYmFscy5WRVJURVhfQllURV9TSVpFLCAwKVxuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmlidXRlTG9jYXRpb25zLmFfdGV4Q29vcmQsIDIsIGdsLkZMT0FULCBmYWxzZSwgR2xvYmFscy5WRVJURVhfQllURV9TSVpFLCAyICogNClcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucy5hX2NvbG9yLCA0LCBnbC5VTlNJR05FRF9CWVRFLCB0cnVlLCBHbG9iYWxzLlZFUlRFWF9CWVRFX1NJWkUsIDQgKiA0KVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyBhbGwgdW5pZm9ybXMgd2l0aCBXZWJHTFxuICAgKi9cbiAgc3luY1VuaWZvcm1zICgpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl91bmlmb3JtcylcbiAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybShrZXkpXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgdW5pZm9ybSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgc3luY1VuaWZvcm0gKG5hbWUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGNvbnN0IHVuaWZvcm0gPSB0aGlzLl91bmlmb3Jtc1tuYW1lXVxuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fdW5pZm9ybUxvY2F0aW9uc1tuYW1lXVxuXG4gICAgc3dpdGNoICh1bmlmb3JtLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3NhbXBsZXIyZCc6XG4gICAgICBjYXNlICdpJzpcbiAgICAgIGNhc2UgJzFpJzpcbiAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZic6XG4gICAgICBjYXNlICcxZic6XG4gICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJzJmJzpcbiAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlWzBdLCB1bmlmb3JtLnZhbHVlWzFdKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnM2YnOlxuICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0sIHVuaWZvcm0udmFsdWVbMl0pXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICc0Zic6XG4gICAgICAgIGdsLnVuaWZvcm00Zihsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZVswXSwgdW5pZm9ybS52YWx1ZVsxXSwgdW5pZm9ybS52YWx1ZVsyXSwgdW5pZm9ybS52YWx1ZVszXSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJzJmdic6XG4gICAgICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtYXQzJzpcbiAgICAgIGNhc2UgJ21hdDNmdic6XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLnZhbHVlKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgVW5rbm93biB1bmlmb3JtIHR5cGU6ICR7dW5pZm9ybS50eXBlfWApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlcyB0aGUgbG9jYXRpb25zIGZvciBhbGwgYXR0cmlidXRlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NhY2hlQXR0cmlidXRlTG9jYXRpb25zICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIHRoaXMuX2F0dHJpYnV0ZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zW25hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgbmFtZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlcyB0aGUgbG9jYXRpb25zIGZvciBhbGwgdW5pZm9ybXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZVVuaWZvcm1Mb2NhdGlvbnMgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX3VuaWZvcm1zKVxuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLl91bmlmb3JtTG9jYXRpb25zW2tleV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwga2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZXMgdGhlIHZlcnRleCBhbmQgZnJhZ21lbnQgc291cmNlcyBvZiB0aGlzIHNoYWRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXBpbGUgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9jb21waWxlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIsIHRoaXMuX3ZlcnRleFNvdXJjZSlcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IHRoaXMuX2NvbXBpbGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLl9mcmFnbWVudFNvdXJjZSlcblxuICAgIC8vIENyZWF0ZSB0aGUgV2ViR0wgcHJvZ3JhbSBhbmQgYXR0YWNoIHRoZSBzaGFkZXJzXG4gICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuXG4gICAgLy8gTGluayB0aGUgcHJvZ3JhbVxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pXG5cbiAgICAvLyBDaGVjayBsaW5raW5nIHN0YXR1c1xuICAgIC8vIENoZWNrIGxpbmtpbmcgc3RhdHVzXG4gICAgY29uc3QgbGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUylcbiAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSBlcnJvck1lc3NhZ2UgPSAnV2ViR0wgY29udGV4dCBsb3N0J1xuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKVxuICAgICAgTG9nLmVycm9yKHRoaXMuY29uc3RydWN0b3IubmFtZSwgYFdlYkdMIHByb2dyYW0gbGlua2luZyBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9ncmFtID0gcHJvZ3JhbVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGNvbXBpbGVzIGEgc2hhZGVyIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIHNvdXJjZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHNoYWRlclR5cGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzaGFkZXJTb3VyY2VcbiAgICogQHJldHVybiB7V2ViR0xTaGFkZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcGlsZVNoYWRlciAoc2hhZGVyVHlwZSwgc2hhZGVyU291cmNlKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcblxuICAgIC8vIENyZWF0ZSB0aGUgc2hhZGVyIGFuZCBjb21waWxlIGl0XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc2hhZGVyU291cmNlKVxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKVxuXG4gICAgLy8gQ2hlY2sgY29tcGlsYXRpb24gc3RhdHVzXG4gICAgY29uc3QgY29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUylcbiAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSBlcnJvck1lc3NhZ2UgPSAnV2ViR0wgY29udGV4dCBsb3N0J1xuICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcilcbiAgICAgIExvZy5lcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBXZWJHTCBzaGFkZXIgY29tcGlsYXRpb24gZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWApXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIHVuaWZvcm0gdG8gdGhlIGdpdmVuIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIHNldFVuaWZvcm0gKG5hbWUsIHZhbHVlLCBzeW5jID0gZmFsc2UpIHtcbiAgICB0aGlzLl91bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZhbHVlXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIHRoaXMuc3luY1VuaWZvcm0obmFtZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gdW5pZm9ybXMgdG8gdGhlaXIgdmFsdWVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgdW5pZm9ybXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBzeW5jID0gZmFsc2VcbiAgICovXG4gIHNldFVuaWZvcm1zICh1bmlmb3Jtcywgc3luYyA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgdGhpcy5fdW5pZm9ybXNbbmFtZV0udmFsdWUgPSB1bmlmb3Jtc1tuYW1lXVxuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmlmb3Jtc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRVbmlmb3JtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VuaWZvcm1zXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXR0cmlidXRlc1xuICAgKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkgeyByZXR1cm4gdGhpcy5fYXR0cmlidXRlcyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTG9jYXRpb25zICgpIHsgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBzaGFkZXIncyBXZWJHTCBwcm9ncmFtXG4gICAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX1cbiAgICovXG4gIGdldFByb2dyYW0gKCkgeyByZXR1cm4gdGhpcy5fcHJvZ3JhbSB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIHNoYWRlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMuX3Byb2dyYW0pXG5cbiAgICB0aGlzLl91bmlmb3JtcyA9IG51bGxcbiAgICB0aGlzLl91bmlmb3JtTG9jYXRpb25zID0gbnVsbFxuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBudWxsXG4gICAgdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zID0gbnVsbFxuXG4gICAgdGhpcy5fcmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5fb25Db250ZXh0Q2hhbmdlKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNoYWRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvc2hhZGVycy9zaGFkZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFNoYWRlciBmcm9tICcuL3NoYWRlcidcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB0ZXh0dXJlIHNoYWRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FbmdpbmUuU2hhZGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBUZXh0dXJlU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBUZXh0dXJlU2hhZGVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdmVydGV4U291cmNlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZnJhZ21lbnRTb3VyY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlciwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSkge1xuICAgIHZlcnRleFNvdXJjZSA9IHZlcnRleFNvdXJjZSB8fCBUZXh0dXJlU2hhZGVyLmRlZmF1bHRWZXJ0ZXhTb3VyY2VcbiAgICBmcmFnbWVudFNvdXJjZSA9IGZyYWdtZW50U291cmNlIHx8IFRleHR1cmVTaGFkZXIuZGVmYXVsdEZyYWdtZW50U291cmNlXG5cbiAgICBzdXBlcihyZW5kZXJlciwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSxcbiAgICAgIFRleHR1cmVTaGFkZXIuZGVmYXVsdFVuaWZvcm1zLFxuICAgICAgVGV4dHVyZVNoYWRlci5kZWZhdWx0QXR0cmlidXRlcylcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlIGNvZGVcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuL3NvdXJjZS90ZXh0dXJlLnZlcnQnKVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2UgY29kZVxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuVGV4dHVyZVNoYWRlci5kZWZhdWx0RnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi9zb3VyY2UvdGV4dHVyZS5mcmFnJylcblxuY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cbi8qKlxuICogVGhlIGRlZmF1bHQgdW5pZm9ybXNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdFVuaWZvcm1zID0ge1xuICB1X2ltYWdlOiB7XG4gICAgdHlwZTogJ3NhbXBsZXIyZCcsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgdV9wcm9qTWF0cml4OiB7XG4gICAgdHlwZTogJ21hdDMnLFxuICAgIHZhbHVlOiBtYXRyaXgudG9BcnJheSgpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBXZWJHTCBhdHRyaWJ1dGVzXG4gKiBAdHlwZSB7U3RyaW5nW119XG4gKi9cblRleHR1cmVTaGFkZXIuZGVmYXVsdEF0dHJpYnV0ZXMgPSBbXG4gICdhX3Bvc2l0aW9uJyxcbiAgJ2FfdGV4Q29vcmQnLFxuICAnYV9jb2xvcidcbl1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZVNoYWRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvc2hhZGVycy90ZXh0dXJlLXNoYWRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZywgVmVjdG9yMiwgVXRpbHMsIFJlY3RhbmdsZSwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vZ2xvYmFscydcblxuLyoqXG4gKiBBIEJhc2VUZXh0dXJlIGhvbGRzIGFuZCBoYW5kbGVzIHRoZSByYXcgc291cmNlIG9mIGEgdGV4dHVyZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgQmFzZVRleHR1cmUgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIEJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSAgeyp9IHNvdXJjZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHNvdXJjZSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX29uU291cmNlTG9hZGVkID0gdGhpcy5fb25Tb3VyY2VMb2FkZWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fZ2xUZXh0dXJlcyA9IHt9XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlXG5cbiAgICB0aGlzLl9nbFVuaXQgPSAwXG4gICAgdGhpcy5fbWlwTWFwcGluZyA9IGZhbHNlXG4gICAgdGhpcy5fbWFnRmlsdGVyID0gQmFzZVRleHR1cmUuTmVhcmVzdEZpbHRlclxuICAgIHRoaXMuX21pbkZpbHRlciA9IEJhc2VUZXh0dXJlLkxpbmVhckZpbHRlclxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSAxXG4gICAgdGhpcy5fbG9hZGVkID0gZmFsc2VcbiAgICB0aGlzLl9mcmFtZSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgMTAwLCAxMDApXG5cbiAgICBpZiAoc291cmNlKSB7XG4gICAgICB0aGlzLl9sb2FkU291cmNlKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGlzIEJhc2VUZXh0dXJlIHRvIHRoZSBnaXZlbiBkaW1lbnNpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl9mcmFtZS53aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGRpbWVuc2lvbnMueVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBzb3VyY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkU291cmNlICgpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLl9zb3VyY2VcblxuICAgIGNvbnN0IHNvdXJjZUxvYWRlZCA9IHNvdXJjZS5jb21wbGV0ZVxuICAgIGNvbnN0IHNvdXJjZUlzQ2FudmFzID0gc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdDYW52YXMnIHx8XG4gICAgICAoc291cmNlLnRhZ05hbWUgJiYgc291cmNlLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUycpXG4gICAgaWYgKHNvdXJjZUxvYWRlZCB8fCBzb3VyY2VJc0NhbnZhcykge1xuICAgICAgcmV0dXJuIHRoaXMuX29uU291cmNlTG9hZGVkKClcbiAgICB9XG5cbiAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX29uU291cmNlTG9hZGVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHNvdXJjZSBvZiB0aGlzIEJhc2VUZXh0dXJlIGhhcyBiZWVuIGxvYWRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uU291cmNlTG9hZGVkICgpIHtcbiAgICB0aGlzLl9sb2FkZWQgPSB0cnVlXG4gICAgdGhpcy5fdXBkYXRlR0xGaWx0ZXJzKClcbiAgICB0aGlzLmVtaXQoJ2xvYWRlZCcpXG4gICAgdGhpcy51cGRhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG1pcC1tYXBwaW5nIGlzIGF2YWlsYWJsZSwgdXBkYXRlIEdMIGZpbHRlcnMgYWNjb3JkaW5nbHlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVHTEZpbHRlcnMgKCkge1xuICAgIGNvbnN0IHNvdXJjZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihcbiAgICAgIHRoaXMuX3NvdXJjZS53aWR0aCwgdGhpcy5fc291cmNlLmhlaWdodFxuICAgIClcbiAgICBpZiAoVXRpbHMuaXNQb3dlck9mVHdvKHNvdXJjZURpbWVuc2lvbnMpKSB7XG4gICAgICBMb2cuaW5mbyh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdNaXAtbWFwcGluZyBlbmFibGVkJylcbiAgICAgIHRoaXMuX21pbkZpbHRlciA9IEJhc2VUZXh0dXJlLkJpbGluZWFyRmlsdGVyXG4gICAgICB0aGlzLl9taXBNYXBwaW5nID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjYWNoZWQgZGltZW5zaW9ucyBvZiB0aGlzIEJhc2VUZXh0dXJlJ3Mgc291cmNlXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIHRoaXMuX2ZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLl9zb3VyY2Uud2lkdGgsIHRoaXMuX3NvdXJjZS5oZWlnaHQpXG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpbHRlciBmb3IgdGhlIGdpdmVuIGRpcmVjdGlvbiBmcm9tIHRoZSBnaXZlbiBXZWJHTCBjb250ZXh0XG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICogQHBhcmFtICB7U3RyaW5nfSBtaW5Pck1hZ1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRHTEZpbHRlciAoZ2wsIG1pbk9yTWFnKSB7XG4gICAgY29uc3QgZmlsdGVyID0gKHZhbHVlKSA9PiB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgQmFzZVRleHR1cmUuTGluZWFyRmlsdGVyOlxuICAgICAgICAgIHJldHVybiBnbC5MSU5FQVJcbiAgICAgICAgY2FzZSBCYXNlVGV4dHVyZS5OZWFyZXN0RmlsdGVyOlxuICAgICAgICAgIHJldHVybiBnbC5ORUFSRVNUXG4gICAgICAgIGNhc2UgQmFzZVRleHR1cmUuQmlsaW5lYXJGaWx0ZXI6XG4gICAgICAgICAgcmV0dXJuIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVFxuICAgICAgICBjYXNlIEJhc2VUZXh0dXJlLlRyaWxpbmVhckZpbHRlcjpcbiAgICAgICAgICByZXR1cm4gZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG1pbk9yTWFnKSB7XG4gICAgICBjYXNlICdtaW4nOlxuICAgICAgICByZXR1cm4gZmlsdGVyKHRoaXMuX21pbkZpbHRlcilcbiAgICAgIGNhc2UgJ21hZyc6XG4gICAgICAgIHJldHVybiBmaWx0ZXIodGhpcy5fbWFnRmlsdGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBCYXNlVGV4dHVyZSBoYXMgYmVlbiBsb2FkZWRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTG9hZGVkICgpIHsgcmV0dXJuIHRoaXMuX2xvYWRlZCB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxvYWRlZCBzdGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxvYWRlZFxuICAgKi9cbiAgc2V0TG9hZGVkIChsb2FkZWQpIHsgdGhpcy5fbG9hZGVkID0gbG9hZGVkIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc291cmNlXG4gICAqIEByZXR1cm4geyp9IHNcbiAgICovXG4gIGdldFNvdXJjZSAoKSB7IHJldHVybiB0aGlzLl9zb3VyY2UgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzb3VyY2VcbiAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICovXG4gIHNldFNvdXJjZSAoc291cmNlKSB7IHRoaXMuX3NvdXJjZSA9IHNvdXJjZSB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFdlYkdMIHRleHR1cmUgZm9yIHRoZSBnaXZlbiByZW5kZXJlciBJRFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlkXG4gICAqIEByZXR1cm4ge1dlYkdMVGV4dHVyZX1cbiAgICovXG4gIGdldEdMVGV4dHVyZUZvcklkIChpZCkgeyByZXR1cm4gdGhpcy5fZ2xUZXh0dXJlc1tpZF0gfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBXZWJHTFRleHR1cmUgZm9yIHRoZSBnaXZlbiByZW5kZXJlciBJRFxuICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICovXG4gIHNldEdMVGV4dHVyZUZvcklkICh0ZXh0dXJlLCBpZCkgeyB0aGlzLl9nbFRleHR1cmVzW2lkXSA9IHRleHR1cmUgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEZyYW1lICgpIHsgcmV0dXJuIHRoaXMuX2ZyYW1lIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhbWVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gZnJhbWVcbiAgICovXG4gIHNldEZyYW1lIChmcmFtZSkgeyB0aGlzLl9mcmFtZSA9IGZyYW1lIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyAoKSB7IHJldHVybiB0aGlzLl9waXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBpeGVsUmF0aW9cbiAgICovXG4gIHNldFBpeGVsUmF0aW8gKHBpeGVsUmF0aW8pIHsgdGhpcy5fcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW8gfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBXZWJHTCB0ZXh0dXJlIHVuaXRcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0R0xVbml0ICgpIHsgcmV0dXJuIHRoaXMuX2dsVW5pdCB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIFdlYkdMIHRleHR1cmUgdW5pdFxuICAgKiBAcGFyYW0ge051bWJlcn0gZ2xVbml0XG4gICAqL1xuICBzZXRHTFVuaXQgKGdsVW5pdCkgeyB0aGlzLl9nbFVuaXQgPSBnbFVuaXQgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtaW4gZmlsdGVyIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZpbHRlclxuICAgKi9cbiAgc2V0TWluRmlsdGVyIChtaW5GaWx0ZXIpIHsgdGhpcy5fbWluRmlsdGVyID0gbWluRmlsdGVyIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHRleHR1cmUncyBtaW4gZmlsdGVyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldE1pbkZpbHRlciAoKSB7IHJldHVybiB0aGlzLl9taW5GaWx0ZXIgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWcgZmlsdGVyIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1hZ0ZpbHRlclxuICAgKi9cbiAgc2V0TWFnRmlsdGVyIChtYWdGaWx0ZXIpIHsgdGhpcy5fbWFnRmlsdGVyID0gbWFnRmlsdGVyIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIHRleHR1cmUncyBtYWcgZmlsdGVyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldE1hZ0ZpbHRlciAoKSB7IHJldHVybiB0aGlzLl9tYWdGaWx0ZXIgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGUgV2ViR0wgdGV4dHVyZXMgZm9yIHRoZSBnaXZlbiByZW5kZXJlciBJRFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGRpc3Bvc2VHTFRleHR1cmVzIChyZW5kZXJlcikge1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGhpcy5fZ2xUZXh0dXJlc1tnbC5pZF0pXG4gICAgICBkZWxldGUgdGhpcy5fZ2xUZXh0dXJlc1tnbC5pZF1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG1pcC1tYXBwaW5nIGlzIGVuYWJsZWQgZm9yIHRoaXMgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNNaXBNYXBwaW5nRW5hYmxlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pcE1hcHBpbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhpcyBvYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICBkaXNwb3NlIChyZW5kZXJlcikge1xuICAgIHRoaXMuZGlzcG9zZUdMVGV4dHVyZXMocmVuZGVyZXIpXG4gIH1cbn1cblxuQmFzZVRleHR1cmUuTmVhcmVzdEZpbHRlciA9IDBcbkJhc2VUZXh0dXJlLkxpbmVhckZpbHRlciA9IDFcbkJhc2VUZXh0dXJlLkJpbGluZWFyRmlsdGVyID0gMlxuQmFzZVRleHR1cmUuVHJpbGluZWFyRmlsdGVyID0gM1xuXG5leHBvcnQgZGVmYXVsdCBCYXNlVGV4dHVyZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdGV4dHVyZXMvYmFzZS10ZXh0dXJlLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSwgVmVjdG9yMiwgRW5naW5lLCBVdGlscywgQ29uZmlndXJhYmxlIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcblxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29uZmlndXJhYmxlIHtcbiAgY29uc3RydWN0b3IgKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy5fb3BlcmF0aW9uID0gb3BlcmF0aW9uXG4gICAgdGhpcy5fZGlydGluZXNzID0ge31cbiAgICB0aGlzLmlkID0gVXRpbHMuZ2V0VVVJRCgpXG5cbiAgICB0aGlzLl9pZGVudGl0eVNwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9zcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5hZGp1c3RtZW50cykge1xuICAgICAgdGhpcy5fb25PcHRpb25zQ2hhbmdlID0gdGhpcy5fb25PcHRpb25zQ2hhbmdlLmJpbmQodGhpcylcbiAgICAgIHRoaXMuX29wdGlvbnMuYWRqdXN0bWVudHMub24oJ3VwZGF0ZWQnLCB0aGlzLl9vbk9wdGlvbnNDaGFuZ2UpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gb3B0aW9ucyBoYXZlIGJlZW4gY2hhbmdlZC4gU2V0cyB0aGlzIG9wZXJhdGlvbiB0byBkaXJ0eS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wdGlvbnNDaGFuZ2UgKCkge1xuICAgIGNvbnN0IGRpcnRpbmVzcyA9IHRoaXMuX2RpcnRpbmVzc1xuICAgIGZvciAobGV0IGlkIGluIGRpcnRpbmVzcykge1xuICAgICAgZGlydGluZXNzW2lkXSA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGlzcGxheU9iamVjdCBvZiB0aGlzIFNwcml0ZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfVxuICAgKi9cbiAgZ2V0RGlzcGxheU9iamVjdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nwcml0ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBzcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdXBkYXRlIChzZGspIHtcbiAgICB0aGlzLl9zcHJpdGUuc2V0QW5jaG9yKHRoaXMuX29wdGlvbnMuYW5jaG9yKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRQb3NpdGlvbih0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCkpXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zY2FsZSkge1xuICAgICAgdGhpcy5fc3ByaXRlLnNldFNjYWxlKHRoaXMuX29wdGlvbnMuc2NhbGUuY2xvbmUoKSlcbiAgICB9XG4gICAgdGhpcy5fc3ByaXRlLnVwZGF0ZVRyYW5zZm9ybSgpXG5cbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuX3Nwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RnJhbWUoKVxuICAgIGNvbnN0IHNwcml0ZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFBpdm90KHRoaXMuX29wdGlvbnMucGl2b3QuY2xvbmUoKS5tdWx0aXBseShzcHJpdGVEaW1lbnNpb25zKSlcbiAgICB0aGlzLl9zcHJpdGUuc2V0Um90YXRpb24odGhpcy5fb3B0aW9ucy5yb3RhdGlvbilcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmbGlwIGluIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgYXBwbHlGbGlwIChzZGssIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IGZpbmFsRGltZW5zaW9ucyA9IHNkay5nZXRGaW5hbERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgcG9zaXRpb24ueCA9IGZpbmFsRGltZW5zaW9ucy54IC0gcG9zaXRpb24ueFxuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgZmxpcEhvcml6b250YWxseTogIXRoaXMuX29wdGlvbnMuZmxpcEhvcml6b250YWxseSxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICB9KVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBwb3NpdGlvbi55ID0gZmluYWxEaW1lbnNpb25zLnkgLSBwb3NpdGlvbi55XG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICBmbGlwVmVydGljYWxseTogIXRoaXMuX29wdGlvbnMuZmxpcFZlcnRpY2FsbHksXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgfSlcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgb3BlcmF0aW9uIGlzIGRpcnR5IGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gIHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0RpcnR5Rm9yUmVuZGVyZXIgKHJlbmRlcmVyKSB7XG4gICAgaWYgKCEocmVuZGVyZXIuaWQgaW4gdGhpcy5fZGlydGluZXNzKSkge1xuICAgICAgdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXSA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlcikge1xuICAgIHRoaXMuX2RpcnRpbmVzc1tyZW5kZXJlci5pZF0gPSBkaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgYWxsIHJlbmRlcmVyc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqL1xuICBzZXREaXJ0eSAoZGlydHkpIHtcbiAgICBmb3IgKGxldCByZW5kZXJlcklkIGluIHRoaXMuX2RpcnRpbmVzcykge1xuICAgICAgdGhpcy5fZGlydGluZXNzW3JlbmRlcmVySWRdID0gZGlydHlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoaXMgU3ByaXRlXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5hZGp1c3RtZW50cykge1xuICAgICAgdGhpcy5fb3B0aW9ucy5hZGp1c3RtZW50cy5vZmYoJ3VwZGF0ZWQnLCB0aGlzLl9vbk9wdGlvbnNDaGFuZ2UpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcml0ZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3ByaXRlLmpzXG4gKiovIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xyXG5tb2R1bGUuZXhwb3J0cyA9IChcclxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xyXG4pLnNwbGl0KCcsJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qc1xuICoqIG1vZHVsZSBpZCA9IDUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcclxudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXHJcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxyXG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcclxuXHJcbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcclxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xyXG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXHJcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcclxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXHJcbiAgICAsIGd0ICAgICA9ICc+J1xyXG4gICAgLCBpZnJhbWVEb2N1bWVudDtcclxuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcclxuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXHJcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcclxuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzxzY3JpcHQ+ZG9jdW1lbnQuRj1PYmplY3Q8L3NjcmlwdCcgKyBndCk7XHJcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcclxuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcclxuICB3aGlsZShpLS0pZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XHJcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XHJcbiAgdmFyIHJlc3VsdDtcclxuICBpZihPICE9PSBudWxsKXtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcclxuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcclxuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xyXG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxyXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XHJcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcclxuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4gKiogbW9kdWxlIGlkID0gNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaGFzID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgdGFnLCBzdGF0KXtcbiAgaWYoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSlkZWYoaXQsIFRBRywge2NvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZ30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1xuICoqIG1vZHVsZSBpZCA9IDU0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxyXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcclxuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXydcbiAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0ge30pO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXHJcbiAgLCBjb3JlICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxyXG4gICwgTElCUkFSWSAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcclxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXHJcbiAgLCBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcclxuICBpZihuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKWRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHt2YWx1ZTogd2tzRXh0LmYobmFtZSl9KTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi92ZWN0b3IyJ1xuaW1wb3J0IFJlY3RhbmdsZSBmcm9tICcuL3JlY3RhbmdsZSdcbmltcG9ydCBNYXRyaXggZnJvbSAnLi9tYXRyaXgnXG5cbi8qKlxuICogU29tZSBjbGFzc2VzIHRoYXQgaGVscCB1cyBkbyB0aGUgbWF0aFxuICogQG5hbWVzcGFjZSBQaG90b0VkaXRvclNESy5NYXRoXG4gKi9cbmV4cG9ydCB7XG4gIFZlY3RvcjIsIFJlY3RhbmdsZSwgTWF0cml4XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9tYXRoL2luZGV4LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBDb25zdGFudHMgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4vZXZlbnQtZW1pdHRlcidcblxuLyoqXG4gKiBIb2xkcyBhbiBhcnJheSBvZiB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBpbnN0YW5jZXMgYW5kIGhhbmRsZXMgdGhlaXIgZGlydGluZXNzXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICovXG5jbGFzcyBPcGVyYXRpb25zU3RhY2sgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPcGVyYXRpb25zU3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uW119IFtvcGVyYXRpb25zID0gW11dXG4gICAqL1xuICBjb25zdHJ1Y3RvciAob3BlcmF0aW9ucyA9IFtdKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUgPSB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9zdGFjayA9IG9wZXJhdGlvbnNcbiAgICB0aGlzLl9zdGFjay5mb3JFYWNoKChvcGVyYXRpb24pID0+IHtcbiAgICAgIG9wZXJhdGlvbi5vbigndXBkYXRlJywgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhpcyBvcGVyYXRpb25zIHN0YWNrXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgdGhpcy5mb3JFYWNoKChvcGVyYXRpb24pID0+XG4gICAgICB0aGlzLnJlbW92ZShvcGVyYXRpb24pKVxuICAgIHRoaXMuX3N0YWNrID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhYm91dCB0byBiZSB1cGRhdGVkXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlIChvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoQ29uc3RhbnRzLkV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgb3BlcmF0aW9uLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBhc3NlcyBBcnJheSNmb3JFYWNoXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGZvckVhY2ggKGl0ZXJhdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YWNrXG4gICAgICAuZmlsdGVyKChvcCkgPT4gISFvcClcbiAgICAgIC5mb3JFYWNoKGl0ZXJhdG9yKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYWxsIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChzZGspIHtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gdGhpcy5fc3RhY2tcbiAgICAgIC5maWx0ZXIoKG9wKSA9PiAhIW9wKVxuXG4gICAgLy8gRmluZCBmaXJzdCBvcGVyYXRpb24gZnJvbSBlbmQgb2YgYXJyYXkgdGhhdCBpcyBub3QgZGlydHlcbiAgICBvcGVyYXRpb25zLnJldmVyc2UoKVxuICAgIGxldCBmaXJzdFVuZGlydHlPcGVyYXRpb24gPSBvcGVyYXRpb25zLmZpbHRlcigobykgPT5cbiAgICAgICFvLmlzRGlydHlGb3JSZW5kZXJlcihzZGsuZ2V0UmVuZGVyZXIoKSlcbiAgICApWzBdXG4gICAgbGV0IGZpcnN0VW5kaXJ0eUluZGV4ID0gb3BlcmF0aW9ucy5pbmRleE9mKGZpcnN0VW5kaXJ0eU9wZXJhdGlvbilcblxuICAgIG9wZXJhdGlvbnMucmV2ZXJzZSgpXG5cbiAgICAvLyBTa2lwIG9wZXJhdGlvbnMgdGhhdCB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBzdWNjZWVkaW5nIG9wZXJhdGlvbnNcbiAgICBsZXQgc3RhcnRJbmRleCA9IDBcbiAgICBpZiAoZmlyc3RVbmRpcnR5SW5kZXggIT09IC0xKSB7XG4gICAgICBzdGFydEluZGV4ID0gb3BlcmF0aW9ucy5sZW5ndGggLSBmaXJzdFVuZGlydHlJbmRleCAtIDFcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBgU2tpcHBpbmcgJHtvcGVyYXRpb25zW2luZGV4XS5jb25zdHJ1Y3Rvci5uYW1lfWApXG4gICAgfVxuXG4gICAgbGV0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKVxuICAgIGZvciAobGV0IGluZGV4ID0gc3RhcnRJbmRleDsgaW5kZXggPCBvcGVyYXRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0gb3BlcmF0aW9uc1tpbmRleF1cbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLnJlbmRlcihzZGspXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBzZXR0aW5ncyBvZiBhbGwgb3BlcmF0aW9uc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgdmFsaWRhdGVTZXR0aW5ncyAoKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5fc3RhY2tcbiAgICAgICAgLmZpbHRlcigob3ApID0+ICEhb3ApXG4gICAgICAgIC5tYXAoKG9wKSA9PiBvcC52YWxpZGF0ZVNldHRpbmdzKCkpXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYWxsIG9wZXJhdGlvbnMgdG8gZGlydHlcbiAgICovXG4gIHNldEFsbFRvRGlydHkgKCkge1xuICAgIHRoaXMuZm9yRWFjaCgob3ApID0+IG9wLnNldERpcnR5KHRydWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBkaXJ0eSBvcGVyYXRpb24gYW5kIHNldHMgYWxsIGZvbGxvd2luZyBvcGVyYXRpb25zIHRvIGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIHVwZGF0ZURpcnRpbmVzc0ZvclJlbmRlcmVyIChyZW5kZXJlcikge1xuICAgIGxldCBkaXJ0eUZvdW5kID0gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3BlcmF0aW9uID0gdGhpcy5fc3RhY2tbaV1cbiAgICAgIGlmICghb3BlcmF0aW9uKSBjb250aW51ZVxuICAgICAgaWYgKG9wZXJhdGlvbi5pc0RpcnR5Rm9yUmVuZGVyZXIocmVuZGVyZXIpKSB7XG4gICAgICAgIGRpcnR5Rm91bmQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eUZvdW5kKSB7XG4gICAgICAgIG9wZXJhdGlvbi5zZXREaXJ0eUZvclJlbmRlcmVyKHRydWUsIHJlbmRlcmVyKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBvcGVyYXRpb24gdG8gdGhpcyBzdGFja1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259XG4gICAqL1xuICBwdXNoIChvcGVyYXRpb24pIHtcbiAgICB0aGlzLl9zdGFjay5wdXNoKG9wZXJhdGlvbilcbiAgICBvcGVyYXRpb24ub24oJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhpcyBzdGFja1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zU3RhY2t9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRpb25zU3RhY2sodGhpcy5fc3RhY2suc2xpY2UoMCkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3BlcmF0aW9uIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tbaW5kZXhdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BlcmF0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICovXG4gIHNldCAoaW5kZXgsIG9wZXJhdGlvbikge1xuICAgIGlmICh0aGlzLl9zdGFja1tpbmRleF0pIHtcbiAgICAgIHRoaXMuX3N0YWNrW2luZGV4XS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICAgICAgdGhpcy5fc3RhY2tbaW5kZXhdLmRpc3Bvc2UoKVxuICAgIH1cbiAgICB0aGlzLl9zdGFja1tpbmRleF0gPSBvcGVyYXRpb25cbiAgICBvcGVyYXRpb24ub24oJ3VwZGF0ZScsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKi9cbiAgcmVtb3ZlIChvcGVyYXRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N0YWNrLmluZGV4T2Yob3BlcmF0aW9uKVxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhY2tbaW5kZXhdKSB7XG4gICAgICB0aGlzLl9zdGFja1tpbmRleF0ub2ZmKCd1cGRhdGUnLCB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSlcbiAgICAgIHRoaXMuX3N0YWNrW2luZGV4XS5kaXNwb3NlKClcbiAgICB9XG4gICAgdGhpcy5fc3RhY2suc3BsaWNlKGluZGV4LCAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIG9wZXJhdGlvbiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleFxuICAgKi9cbiAgcmVtb3ZlQXQgKGluZGV4KSB7XG4gICAgaWYgKHRoaXMuX3N0YWNrW2luZGV4XSkge1xuICAgICAgdGhpcy5fc3RhY2tbaW5kZXhdLm9mZigndXBkYXRlJywgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gICAgICB0aGlzLl9zdGFja1tpbmRleF0uZGlzcG9zZSgpXG4gICAgfVxuICAgIHRoaXMuX3N0YWNrW2luZGV4XSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YWNrXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbltdfVxuICAgKi9cbiAgZ2V0U3RhY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFja1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9wZXJhdGlvbnNTdGFja1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvb3BlcmF0aW9ucy1zdGFjay5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogQG5hbWVzcGFjZSBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmV4cG9ydCB7IGRlZmF1bHQgYXMgRmlsdGVyT3BlcmF0aW9uIH0gZnJvbSAnLi9maWx0ZXItb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDcm9wT3BlcmF0aW9uIH0gZnJvbSAnLi9jcm9wLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgT3JpZW50YXRpb25PcGVyYXRpb24gfSBmcm9tICcuL29yaWVudGF0aW9uLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQWRqdXN0bWVudHNPcGVyYXRpb24gfSBmcm9tICcuL2FkanVzdG1lbnRzLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGluZWFyRm9jdXNPcGVyYXRpb24gfSBmcm9tICcuL2xpbmVhci1mb2N1cy1vcGVyYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFJhZGlhbEZvY3VzT3BlcmF0aW9uIH0gZnJvbSAnLi9yYWRpYWwtZm9jdXMtb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb3JkZXJPcGVyYXRpb24gfSBmcm9tICcuL2JvcmRlci1vcGVyYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNwcml0ZU9wZXJhdGlvbiB9IGZyb20gJy4vc3ByaXRlLW9wZXJhdGlvbidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgV2F0ZXJtYXJrT3BlcmF0aW9uIH0gZnJvbSAnLi93YXRlcm1hcmstb3BlcmF0aW9uJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCcnVzaE9wZXJhdGlvbiB9IGZyb20gJy4vYnJ1c2gtb3BlcmF0aW9uJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2luZGV4LmpzXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibmFtZVwiOiBcInBob3RvZWRpdG9yc2RrXCIsXG5cdFwidmVyc2lvblwiOiBcIjMuMi4wXCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbW9zdCBjb21wcmVoZW5zaXZlIHBob3RvIGVkaXRvciBTREsgZm9yIEhUTUw1XCIsXG5cdFwicmVwb3NpdG9yeVwiOiBcImh0dHA6Ly9naXRodWIuY29tL2ltZ2x5L2ltZ2x5LXNkay1odG1sNVwiLFxuXHRcImF1dGhvclwiOiBcIlBob3RvIEVkaXRvciBTREsgPGNvbnRhY3RAcGhvdG9lZGl0b3JzZGsuY29tPlwiLFxuXHRcImxpY2Vuc2VcIjogXCJTRUUgTElDRU5TRSBJTiBMSUNFTlNFLm1kXCIsXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJyZWxlYXNlXCI6IFwibm9kZSBzY3JpcHRzL3JlbGVhc2VcIixcblx0XHRcInJlbmRlci1maWx0ZXItcHJldmlld3NcIjogXCJiYWJlbC1ub2RlIHNjcmlwdHMvcmVuZGVyLWZpbHRlci1wcmV2aWV3c1wiLFxuXHRcdFwicmVsZWFzZTpkcnlcIjogXCJFTlY9cHJvZHVjdGlvbiBVUExPQUQ9ZmFsc2Ugbm9kZV9tb2R1bGVzLy5iaW4vZ3VscCByZWxlYXNlXCIsXG5cdFx0XCJ0ZXN0XCI6IFwibm9kZV9tb2R1bGVzLy5iaW4vbW9jaGFcIixcblx0XHRcInRlc3Qtd2ViZ2xcIjogXCJub2RlX21vZHVsZXMvLmJpbi9tb2NoYSB0ZXN0LXdlYmdsXCIsXG5cdFx0XCJjb3ZlcmFsbHNcIjogXCJucG0gcnVuIGNvdmVyYWdlICYmIGNhdCAuL2NvdmVyYWdlL2xjb3YuaW5mbyB8IG5vZGVfbW9kdWxlcy8uYmluL2NvdmVyYWxscyAmJiBybSAtcmYgLi9jb3ZlcmFnZVwiLFxuXHRcdFwiY292ZXJhZ2VcIjogXCJOT0RFX0VOVj10ZXN0IG5vZGVfbW9kdWxlcy8uYmluL2lzdGFuYnVsIGNvdmVyIG5vZGVfbW9kdWxlcy8uYmluL19tb2NoYSAteCAqKi91aS8qKlwiXG5cdH0sXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImNhbnZhc1wiOiBcIl4xLjMuMTJcIixcblx0XHRcImdsXCI6IFwiXjMuMC4zXCIsXG5cdFx0XCJiYWJlbC1jb3JlXCI6IFwiXjYuNi40XCIsXG5cdFx0XCJiYWJlbC1sb2FkZXJcIjogXCJeNi4yLjRcIixcblx0XHRcImJhYmVsLXBsdWdpbi1leHRlcm5hbC1oZWxwZXJzLTJcIjogXCJeNi4zLjEzXCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWVzMjAxNS1jbGFzc2VzXCI6IFwiXjYuNi40XCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLXJ1bnRpbWVcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXByZXNldC1yZWFjdFwiOiBcIl42LjUuMFwiLFxuXHRcdFwiYmFiZWwtcmVnaXN0ZXJcIjogXCJeNi42LjBcIixcblx0XHRcImJhYmVsLXJ1bnRpbWVcIjogXCJeNi42LjFcIixcblx0XHRcImNoYWlcIjogXCJeMy40LjBcIixcblx0XHRcImNoYWktYXMtcHJvbWlzZWRcIjogXCJeNS4xLjBcIixcblx0XHRcImNsYXNzbmFtZXNcIjogXCJeMi4xLjNcIixcblx0XHRcImNvbXBhc3MtbWl4aW5zXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS94enlmZXIvY29tcGFzcy1taXhpbnMuZ2l0I3BhdGNoLTFcIixcblx0XHRcImNvdmVyYWxsc1wiOiBcIl4yLjExLjJcIixcblx0XHRcImRlbFwiOiBcIl4yLjAuMFwiLFxuXHRcdFwiZ3VscFwiOiBcIl4zLjguMTBcIixcblx0XHRcImd1bHAtOWUtc2Fzcy1saW50XCI6IFwiMC4wLjhcIixcblx0XHRcImd1bHAtY2hhbmdlZFwiOiBcIl4xLjMuMFwiLFxuXHRcdFwiZ3VscC1naXRodWItcmVsZWFzZVwiOiBcIl4xLjEuMlwiLFxuXHRcdFwiZ3VscC1qc2RvYzNcIjogXCJeMC4yLjBcIixcblx0XHRcImd1bHAtbm90aWZ5XCI6IFwiXjEuMy4xXCIsXG5cdFx0XCJndWxwLXJlbmFtZVwiOiBcIn4xLjIuMFwiLFxuXHRcdFwiZ3VscC1zYXNzXCI6IFwiXjIuMC40XCIsXG5cdFx0XCJndWxwLXNlcXVlbmNlXCI6IFwiXjAuNC4xXCIsXG5cdFx0XCJndWxwLXNvdXJjZW1hcHNcIjogXCJeMS41LjJcIixcblx0XHRcImd1bHAtc3RhbmRhcmRcIjogXCJeNi4wLjVcIixcblx0XHRcImd1bHAtdWdsaWZ5XCI6IFwiXjEuNC4yXCIsXG5cdFx0XCJndWxwLXV0aWxcIjogXCJ+Mi4yLjE2XCIsXG5cdFx0XCJndWxwLXdhdGNoXCI6IFwiXjQuMy41XCIsXG5cdFx0XCJndWxwLXdlYnNlcnZlclwiOiBcIl4wLjkuMVwiLFxuXHRcdFwiZ3VscC15dWljb21wcmVzc29yXCI6IFwiMC4wLjNcIixcblx0XHRcImd1bHAtemlwXCI6IFwiXjMuMi4wXCIsXG5cdFx0XCJpc3RhbmJ1bFwiOiBcIl4xLjAuMC1hbHBoYS4yXCIsXG5cdFx0XCJqYWd1YXJqcy1qc2RvY1wiOiBcImdpdDovL2dpdGh1Yi5jb20vaW1nbHkvamFndWFyanMtanNkb2MuZ2l0I21hc3RlclwiLFxuXHRcdFwianNkb2NcIjogXCJnaXQ6Ly9naXRodWIuY29tL2pzZG9jMy9qc2RvYy5naXQjbWFzdGVyXCIsXG5cdFx0XCJqc29uLWxvYWRlclwiOiBcIl4wLjUuMlwiLFxuXHRcdFwibW9jaGFcIjogXCJeMi4zLjNcIixcblx0XHRcIm1vY2hhLWxjb3YtcmVwb3J0ZXJcIjogXCIwLjAuMVwiLFxuXHRcdFwicGVyZm9ybWFuY2Utbm93XCI6IFwiXjAuMi4wXCIsXG5cdFx0XCJwcm9tcHRcIjogXCJeMS4wLjBcIixcblx0XHRcInJhdy1sb2FkZXJcIjogXCJeMC41LjFcIixcblx0XHRcInJlYWN0XCI6IFwiXjAuMTQuN1wiLFxuXHRcdFwicmVhY3QtZG9tXCI6IFwiXjAuMTQuN1wiLFxuXHRcdFwicmVxdWlyZS1kaXJcIjogXCJeMC4zLjBcIixcblx0XHRcInJ1bi1zZXF1ZW5jZVwiOiBcIn4wLjMuNlwiLFxuXHRcdFwic2hvdWxkXCI6IFwiXjQuMy4wXCIsXG5cdFx0XCJzaW5vblwiOiBcIl4xLjE3LjNcIixcblx0XHRcInNpbm9uLWNoYWlcIjogXCJeMi44LjBcIixcblx0XHRcInRyYW5zZm9ybS1sb2FkZXJcIjogXCJeMC4yLjJcIixcblx0XHRcInZpbnlsLXNvdXJjZS1zdHJlYW1cIjogXCIwLjEuMVwiLFxuXHRcdFwid2VicGFja1wiOiBcIl4yLjEuMC1iZXRhLjZcIixcblx0XHRcIndlYnBhY2stbm90aWZpZXJcIjogXCJeMS4yLjFcIixcblx0XHRcIndlYnBhY2stc3RyZWFtXCI6IFwiXjMuMi4wXCJcblx0fSxcblx0XCJzdGFuZGFyZFwiOiB7XG5cdFx0XCJnbG9iYWxzXCI6IFtcblx0XHRcdFwiZGVzY3JpYmVcIixcblx0XHRcdFwiY29udGV4dFwiLFxuXHRcdFx0XCJiZWZvcmVcIixcblx0XHRcdFwiYmVmb3JlRWFjaFwiLFxuXHRcdFx0XCJhZnRlclwiLFxuXHRcdFx0XCJhZnRlckVhY2hcIixcblx0XHRcdFwiaXRcIixcblx0XHRcdFwiZXhwZWN0XCJcblx0XHRdXG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9wYWNrYWdlLmpzb25cbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBEaXNwbGF5T2JqZWN0IGZyb20gJy4vZGlzcGxheS1vYmplY3QnXG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIERpc3BsYXlPYmplY3QgaW5zdGFuY2VzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0XG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIERpc3BsYXlPYmplY3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIENvbnRhaW5lclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2NoaWxkcmVuID0gW11cbiAgICB0aGlzLl9maWx0ZXJzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBmaWx0ZXIgdG8gdGhlIGZpbHRlciBzdGFja1xuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5GaWx0ZXJ9IGZpbHRlclxuICAgKi9cbiAgYWRkRmlsdGVyIChmaWx0ZXIpIHtcbiAgICB0aGlzLl9maWx0ZXJzLnB1c2goZmlsdGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlcn0gZmlsdGVyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IC0gV2hldGhlciB0aGUgZmlsdGVyIGhhcyBiZWVuIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZUZpbHRlciAoZmlsdGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9maWx0ZXJzLmluZGV4T2YoZmlsdGVyKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsdGVyc1xuICAgKiBAcGFyYW0ge0FycmF5LjxQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyPn0gZmlsdGVyc1xuICAgKi9cbiAgc2V0RmlsdGVycyAoZmlsdGVycykge1xuICAgIHRoaXMuX2ZpbHRlcnMgPSBmaWx0ZXJzXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB0byB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBjaGlsZFxuICAgKi9cbiAgYWRkQ2hpbGQgKGNoaWxkKSB7XG4gICAgLy8gUmVtb3ZlIGZyb20gcHJldmlvdXMgcGFyZW50XG4gICAgY29uc3Qgb3JpZ2luYWxQYXJlbnQgPSBjaGlsZC5nZXRQYXJlbnQoKVxuICAgIGlmIChvcmlnaW5hbFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgb3JpZ2luYWxQYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpXG4gICAgfVxuICAgIGNoaWxkLnNldFBhcmVudCh0aGlzKVxuXG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB0byB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gY2hpbGRcbiAgICovXG4gIHByZXBlbmRDaGlsZCAoY2hpbGQpIHtcbiAgICAvLyBSZW1vdmUgZnJvbSBwcmV2aW91cyBwYXJlbnRcbiAgICBjb25zdCBvcmlnaW5hbFBhcmVudCA9IGNoaWxkLmdldFBhcmVudCgpXG4gICAgaWYgKG9yaWdpbmFsUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBvcmlnaW5hbFBhcmVudC5yZW1vdmVDaGlsZChjaGlsZClcbiAgICB9XG4gICAgY2hpbGQuc2V0UGFyZW50KHRoaXMpXG5cbiAgICB0aGlzLl9jaGlsZHJlbi51bnNoaWZ0KGNoaWxkKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgY29udGFpbmVyIGhhcyB0aGUgZ2l2ZW4gY2hpbGRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9ICBjaGlsZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaGFzQ2hpbGQgKGNoaWxkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKVxuICAgIHJldHVybiBpbmRleCAhPT0gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBvYmplY3QgZnJvbSB0aGUgbGlzdCBvZiBjaGlsZHJlblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gY2hpbGRcbiAgICovXG4gIHJlbW92ZUNoaWxkIChjaGlsZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZClcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICBjaGlsZC5zZXRQYXJlbnQobnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmluZm8odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnVHJpZWQgdG8gcmVtb3ZlIGEgY2hpbGQgdGhhdCBkb2VzIG5vdCBleGlzdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuXG4gICAqL1xuICBjbGVhckNoaWxkcmVuICgpIHtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIERpc3BsYXlPYmplY3QgdXNpbmcgdGhlIGdpdmVuIFdlYkdMUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG4gICAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJNYW5hZ2VyID0gcmVuZGVyZXIuZ2V0RmlsdGVyTWFuYWdlcigpXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIucHVzaEZpbHRlcnModGhpcywgdGhpcy5fZmlsdGVycylcbiAgICB9XG5cbiAgICByZW5kZXJlci5nZXRDdXJyZW50T2JqZWN0UmVuZGVyZXIoKS5zdGFydCgpXG5cbiAgICB0aGlzLl9yZW5kZXJXZWJHTChyZW5kZXJlcilcblxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC5yZW5kZXJXZWJHTChyZW5kZXJlcilcbiAgICB9KVxuXG4gICAgcmVuZGVyZXIuZ2V0Q3VycmVudE9iamVjdFJlbmRlcmVyKCkuZmx1c2goKVxuXG4gICAgaWYgKHRoaXMuX2ZpbHRlcnMgJiYgdGhpcy5fZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlck1hbmFnZXIucG9wRmlsdGVycygpXG4gICAgfVxuICAgIHJlbmRlcmVyLmdldEN1cnJlbnRPYmplY3RSZW5kZXJlcigpLnN0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50cyBvZiB0aGlzIGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5XZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyV2ViR0wgKHJlbmRlcmVyKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgRGlzcGxheU9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlckNhbnZhcyAocmVuZGVyZXIpIHtcbiAgICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlck1hbmFnZXIgPSByZW5kZXJlci5nZXRGaWx0ZXJNYW5hZ2VyKClcbiAgICBpZiAodGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZmlsdGVyTWFuYWdlci5wdXNoRmlsdGVycyh0aGlzLCB0aGlzLl9maWx0ZXJzKVxuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlckNhbnZhcyhyZW5kZXJlcilcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQucmVuZGVyQ2FudmFzKHJlbmRlcmVyKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5fZmlsdGVycyAmJiB0aGlzLl9maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZmlsdGVyTWFuYWdlci5wb3BGaWx0ZXJzKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudHMgb2YgdGhpcyBjb250YWluZXJcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB3b3JsZCB0cmFuc2Zvcm0gZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKi9cbiAgdXBkYXRlVHJhbnNmb3JtICgpIHtcbiAgICBzdXBlci51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9uLWdsb2JhbCBib3VuZHMgb2YgdGhpcyBEaXNwbGF5T2JqZWN0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgZ2V0TG9jYWxCb3VuZHMgKCkge1xuICAgIGlmICh0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIC8vIEBUT0RPIENhbGN1bGF0ZSBib3VuZHMgYnkgbG9va2luZyBhdCBjaGlsZHJlblxuICAgICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsQm91bmRzLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEJvdW5kcyAoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIC8vIEBUT0RPIENhbGN1bGF0ZSBib3VuZHMgYnkgbG9va2luZyBhdCBjaGlsZHJlblxuICAgICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHMuY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBDb250YWluZXIncyBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdFtdfVxuICAgKi9cbiAgZ2V0Q2hpbGRyZW4gKCkgeyByZXR1cm4gdGhpcy5fY2hpbGRyZW4gfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgQ29udGFpbmVyJ3MgZmlsdGVyc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyW119XG4gICAqL1xuICBnZXRGaWx0ZXJzICgpIHsgcmV0dXJuIHRoaXMuX2ZpbHRlcnMgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIENvbnRhaW5lclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG5cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250YWluZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL2Rpc3BsYXkvY29udGFpbmVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBWZWN0b3IyLCBFdmVudEVtaXR0ZXIsIENvbG9yIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscydcblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIHJlbmRlcmVyc1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIEJhc2VSZW5kZXJlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNlUmVuZGVyZXIgaW5zdGFuY2VcbiAgICogQHBhcmFtICB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgPSB7fVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnBpeGVsUmF0aW8gPSAxXVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5Db2xvcn0gW29wdGlvbnMuY2xlYXJDb2xvciA9IFBob3RvRWRpdG9yU0RLLkNvbG9yLlRSQU5TUEFSRU5UXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbb3B0aW9ucy5kZWJ1ZyA9IGZhbHNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX29wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBwaXhlbFJhdGlvOiAxLFxuICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgY2xlYXJDb2xvcjogQ29sb3IuQkxBQ0ssXG4gICAgICBkZWJ1ZzogZmFsc2VcbiAgICB9KVxuXG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMjUpXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aCB8fCA4MDBcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgNjAwXG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpXG4gICAgdGhpcy5fbWF4VGV4dHVyZVNpemUgPSBudWxsXG4gICAgdGhpcy5fcGl4ZWxSYXRpbyA9IHRoaXMuX29wdGlvbnMucGl4ZWxSYXRpb1xuICAgIHRoaXMuX2NsZWFyQ29sb3IgPSB0aGlzLl9vcHRpb25zLnRyYW5zcGFyZW50XG4gICAgICA/IENvbG9yLlRSQU5TUEFSRU5UXG4gICAgICA6ICh0aGlzLl9vcHRpb25zLmNsZWFyQ29sb3IgfHwgQ29sb3IuQkxBQ0spXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FudmFzIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqL1xuICBzZXRDYW52YXMgKGNhbnZhcykge1xuICAgIHRoaXMuX2NhbnZhcyA9IGNhbnZhc1xuXG4gICAgdGhpcy5fY3JlYXRlQ29udGV4dCgpXG4gICAgdGhpcy5fb25CZWZvcmVDb250ZXh0KClcbiAgICB0aGlzLl9zZXR1cENvbnRleHQoKVxuXG4gICAgdGhpcy5yZXNpemVUbyhuZXcgVmVjdG9yMih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICovXG4gIGdldENhbnZhcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGJlZm9yZSB0aGUgY29udGV4dCBoYXMgYmVlbiBzZXQgdXBcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQmVmb3JlQ29udGV4dCAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBjb250ZXh0IGFuZCB2aWV3IHRvIHRoZSBnaXZlbiBzaXplXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICBjb25zdCB7IHBpeGVsUmF0aW8gfSA9IHRoaXMuX29wdGlvbnNcbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMueCAqIHBpeGVsUmF0aW9cbiAgICB0aGlzLl9oZWlnaHQgPSBkaW1lbnNpb25zLnkgKiBwaXhlbFJhdGlvXG5cbiAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLl93aWR0aFxuICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHRcblxuICAgIGlmICh0aGlzLl9jYW52YXMuc3R5bGUpIHtcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS53aWR0aCA9IGAke3RoaXMuX3dpZHRoIC8gcGl4ZWxSYXRpb31weGBcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9oZWlnaHQgLyBwaXhlbFJhdGlvfXB4YFxuICAgIH1cblxuICAgIHRoaXMuX2RpbWVuc2lvbnMgPSBkaW1lbnNpb25zLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyByZW5kZXJlclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgX2NyZWF0ZUNvbnRleHQgKCkge1xuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2BfY3JlYXRlQ29udGV4dGAgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdgX3NldHVwQ29udGV4dGAgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MnKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdgcmVuZGVyYCBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcycpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4aW11bSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldE1heERpbWVuc2lvbnMgKCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcmV0dXJuIHtSZW5kZXJpbmdDb250ZXh0fVxuICAgKi9cbiAgZ2V0Q29udGV4dCAoKSB7IHJldHVybiB0aGlzLl9jb250ZXh0IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB3aWR0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCAoKSB7IHJldHVybiB0aGlzLl9kaW1lbnNpb25zLnggfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGhlaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQgKCkgeyByZXR1cm4gdGhpcy5fZGltZW5zaW9ucy55IH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldERpbWVuc2lvbnMgKCkgeyByZXR1cm4gdGhpcy5fZGltZW5zaW9ucyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyAoKSB7IHJldHVybiB0aGlzLl9waXhlbFJhdGlvIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc2V0UGl4ZWxSYXRpbyAocGl4ZWxSYXRpbykgeyB0aGlzLl9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbyB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1heGltdW0gdGV4dHVyZSBzaXplXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldE1heFRleHR1cmVTaXplICgpIHsgcmV0dXJuIHRoaXMuX21heFRleHR1cmVTaXplIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBmaWx0ZXIgbWFuYWdlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRmlsdGVyTWFuYWdlcn1cbiAgICovXG4gIGdldEZpbHRlck1hbmFnZXIgKCkgeyByZXR1cm4gdGhpcy5fZmlsdGVyTWFuYWdlciB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbHRlciBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkZpbHRlck1hbmFnZXJ9IGZpbHRlck1hbmFnZXJcbiAgICovXG4gIHNldEZpbHRlck1hbmFnZXIgKGZpbHRlck1hbmFnZXIpIHsgdGhpcy5fZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXIgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyByZW5kZXJlciBpcyBzdXBwb3J0ZWQgb24gdGhlIGN1cnJlbnQgZGV2aWNlIGFuZCBicm93c2VyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQgKCkgeyByZXR1cm4gdHJ1ZSB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHJlbmRlcmVyJ3MgdHlwZSBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gIHR5cGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT2ZUeXBlICh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFJlbmRlcmVyXG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnYGRpc3Bvc2VgIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUmVuZGVyZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL3JlbmRlcmVycy9iYXNlLXJlbmRlcmVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIE9iamVjdFJlbmRlcmVyIGNsYXNzZXNcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgT2JqZWN0UmVuZGVyZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPYmplY3RSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlclxuXG4gICAgdGhpcy5fb25Db250ZXh0Q2hhbmdlID0gdGhpcy5fb25Db250ZXh0Q2hhbmdlLmJpbmQodGhpcylcbiAgICB0aGlzLl9yZW5kZXJlci5vbignY29udGV4dCcsIHRoaXMuX29uQ29udGV4dENoYW5nZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJpbmcgY29udGV4dCBjaGFuZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q2hhbmdlICgpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgcmVuZGVyZXIgaXMgYWN0aXZhdGVkXG4gICAqL1xuICBzdGFydCAoKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IHJlbmRlcmVyIGlzIGRlYWN0aXZhdGVkXG4gICAqL1xuICBzdG9wICgpIHtcbiAgICB0aGlzLmZsdXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHdoYXRldmVyIGhhcyBiZWVuIHF1ZXVlZFxuICAgKi9cbiAgZmx1c2ggKCkge1xuXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBPYmplY3RSZW5kZXJlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIub2ZmKCdjb250ZXh0JywgdGhpcy5fb25Db250ZXh0Q2hhbmdlKVxuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9iamVjdFJlbmRlcmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS9yZW5kZXJlcnMvd2ViZ2wvb2JqZWN0LXJlbmRlcmVycy9vYmplY3QtcmVuZGVyZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBSZWN0YW5nbGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgQmFzZVRleHR1cmUgZnJvbSAnLi9iYXNlLXRleHR1cmUnXG5pbXBvcnQgVGV4dHVyZVVWcyBmcm9tICcuLi91dGlscy90ZXh0dXJlLXV2cydcblxuLyoqXG4gKiBBIHRleHR1cmUgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIHtAbGluayBQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChiYXNlVGV4dHVyZSwgZnJhbWUpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoIShiYXNlVGV4dHVyZSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXGBiYXNlVGV4dHVyZVxcYCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgQmFzZVRleHR1cmUnKVxuICAgIH1cbiAgICB0aGlzLl9iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlXG4gICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVVnMoKVxuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWUgPyBmcmFtZS5jbG9uZSgpIDogbnVsbFxuICAgIHRoaXMuX2ZyYW1lTG9ja2VkID0gISFmcmFtZVxuXG4gICAgLy8gQmluZCBldmVudCBoYW5kbGVyc1xuICAgIHRoaXMuX29uQmFzZVRleHR1cmVMb2FkZWQgPSB0aGlzLl9vbkJhc2VUZXh0dXJlTG9hZGVkLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkJhc2VUZXh0dXJlVXBkYXRlZCA9IHRoaXMuX29uQmFzZVRleHR1cmVVcGRhdGVkLmJpbmQodGhpcylcblxuICAgIGlmICghdGhpcy5fYmFzZVRleHR1cmUuaXNMb2FkZWQoKSkge1xuICAgICAgdGhpcy5fYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgdGhpcy5fb25CYXNlVGV4dHVyZUxvYWRlZClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBiYXNlVGV4dHVyZS5nZXRGcmFtZSgpXG4gICAgICBpZiAoIXRoaXMuX2ZyYW1lTG9ja2VkKSB7XG4gICAgICAgIHRoaXMuX2ZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgfVxuICAgICAgdGhpcy5fb25CYXNlVGV4dHVyZUxvYWRlZCgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB0ZXh0dXJlIGZyb20gdGhlIGdpdmVuIGltYWdlXG4gICAqIEBwYXJhbSAge0ltYWdlfSBpbWFnZVxuICAgKi9cbiAgc3RhdGljIGZyb21JbWFnZSAoaW1hZ2UpIHtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShpbWFnZSlcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoYmFzZVRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSB0aGUgZ2l2ZW4gY2FudmFzXG4gICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICovXG4gIHN0YXRpYyBmcm9tQ2FudmFzIChjYW52YXMpIHtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShjYW52YXMpXG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBoYXMgYmVlbiBsb2FkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhc2VUZXh0dXJlTG9hZGVkICgpIHtcbiAgICBpZiAoIXRoaXMuX2ZyYW1lTG9ja2VkKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IHRoaXMuX2Jhc2VUZXh0dXJlLmdldEZyYW1lKCkuY2xvbmUoKVxuICAgICAgdGhpcy5zZXRGcmFtZShmcmFtZSlcbiAgICB9XG5cbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5vbigndXBkYXRlJywgdGhpcy5fb25CYXNlVGV4dHVyZVVwZGF0ZWQpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJhc2VUZXh0dXJlVXBkYXRlZCAoKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9iYXNlVGV4dHVyZS5nZXRGcmFtZSgpXG4gICAgdGhpcy5fZnJhbWUud2lkdGggPSB3aWR0aFxuICAgIHRoaXMuX2ZyYW1lLmhlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuZW1pdCgndXBkYXRlJylcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBVViBjb29yZGluYXRlcyBvZiB0aGlzIHRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVVVnMgKCkge1xuICAgIHRoaXMuX3V2cy51cGRhdGUoXG4gICAgICB0aGlzLl9mcmFtZSxcbiAgICAgIHRoaXMuX2Jhc2VUZXh0dXJlLmdldEZyYW1lKClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlVGV4dHVyZX1cbiAgICovXG4gIGdldEJhc2VUZXh0dXJlICgpIHsgcmV0dXJuIHRoaXMuX2Jhc2VUZXh0dXJlIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYmFzZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZVxuICAgKi9cbiAgc2V0QmFzZVRleHR1cmUgKGJhc2VUZXh0dXJlKSB7IHRoaXMuX2Jhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmcmFtZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEZyYW1lICgpIHsgcmV0dXJuIHRoaXMuX2ZyYW1lIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZnJhbWVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gZnJhbWVcbiAgICovXG4gIHNldEZyYW1lIChmcmFtZSkge1xuICAgIHRoaXMuX2ZyYW1lID0gZnJhbWVcbiAgICB0aGlzLl91cGRhdGVVVnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFdpZHRoICgpIHsgcmV0dXJuIHRoaXMuX2ZyYW1lLndpZHRoIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0XG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCAoKSB7IHJldHVybiB0aGlzLl9mcmFtZS5oZWlnaHQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0dXJlIFVWc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZVVWc31cbiAgICovXG4gIGdldFVWcyAoKSB7IHJldHVybiB0aGlzLl91dnMgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoaXMgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXREaW1lbnNpb25zICgpIHsgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuX2ZyYW1lLndpZHRoLCB0aGlzLl9mcmFtZS5oZWlnaHQpIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdGV4dHVyZXMvdGV4dHVyZS5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZyB9IGZyb20gJy4uL2dsb2JhbHMnXG5jb25zdCBub3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlXG4gID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSlcbiAgOiByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKSlcblxuLyoqXG4gKiBIb29rcyBpbnRvIGEgcmVuZGVyaW5nIGNvbnRleHQgKFdlYkdMUmVuZGVyaW5nQ29udGV4dCBvciBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpLFxuICogbW9ja3MgaXRzIG1ldGhvZHMgYW5kIG1lYXN1cmVzIHRoZSB0aW1lIGNvbnN1bWVkIGJ5IHRoZSBtZXRob2QgY2FsbHMuIFdoZW4gYGVuZEZyYW1lYFxuICogaXMgY2FsbGVkLCBpdCBwcmludHMgYSBwZXJmb3JtYW5jZSByZXBvcnRcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICogQGlnbm9yZVxuICovXG5jbGFzcyBDb250ZXh0UGVyZm9ybWFuY2VIb29rIHtcbiAgY29uc3RydWN0b3IgKGNvbnRleHQpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dFxuICAgIHRoaXMuX3RyYWNraW5nID0gZmFsc2VcblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IGNvbnRleHRba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgY29uc3QgZm4gPSBjb250ZXh0W2tleV1cbiAgICAgICAgICBpZiAoIXNlbGYuX3RyYWNraW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFydCA9IG5vdygpXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4uYXBwbHkoY29udGV4dCwgYXJncylcbiAgICAgICAgICBjb25zdCB0aW1lID0gbm93KCkgLSBzdGFydFxuXG4gICAgICAgICAgY29uc3QgY2FsbCA9IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZToga2V5LFxuICAgICAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICAgICAgZHVyYXRpb246IHRpbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5fdHJhY2tlZENhbGxzLnB1c2goY2FsbClcblxuICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpc1trZXldID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIHRyYWNraW5nIGEgZnJhbWVcbiAgICovXG4gIHN0YXJ0RnJhbWUgKCkge1xuICAgIHRoaXMuX3RyYWNraW5nID0gdHJ1ZVxuICAgIHRoaXMuX3RyYWNrZWRDYWxscyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgdHJhY2tpbmcgYSBmcmFtZSBhbmQgcHJpbnRzIGEgcGVyZm9ybWFuY2UgcmVwb3J0XG4gICAqL1xuICBlbmRGcmFtZSAoKSB7XG4gICAgY29uc3QgdGFnID0gJ1JlbmRlcmluZydcbiAgICBMb2cubG9nKHRhZywgJ0ZyYW1lIHJlbmRlcmluZyByZXN1bHRzOicpXG4gICAgTG9nLmxvZyh0YWcsIGBDb250ZXh0IGNhbGxzOiAke3RoaXMuX3RyYWNrZWRDYWxscy5sZW5ndGh9YClcblxuICAgIGNvbnN0IGdyb3VwZWRDYWxscyA9IHt9XG4gICAgdGhpcy5fdHJhY2tlZENhbGxzLmZvckVhY2goKHsgZnVuY3Rpb25OYW1lLCBkdXJhdGlvbiB9KSA9PiB7XG4gICAgICBncm91cGVkQ2FsbHNbZnVuY3Rpb25OYW1lXSA9IGdyb3VwZWRDYWxsc1tmdW5jdGlvbk5hbWVdIHx8IHtcbiAgICAgICAgdG90YWxEdXJhdGlvbjogMCxcbiAgICAgICAgY2FsbHM6IDBcbiAgICAgIH1cblxuICAgICAgZ3JvdXBlZENhbGxzW2Z1bmN0aW9uTmFtZV0udG90YWxEdXJhdGlvbiArPSBkdXJhdGlvblxuICAgICAgZ3JvdXBlZENhbGxzW2Z1bmN0aW9uTmFtZV0uY2FsbHMrK1xuICAgIH0pXG5cbiAgICBsZXQgY2FsbHNBcnJheSA9IFtdXG4gICAgZm9yIChsZXQga2V5IGluIGdyb3VwZWRDYWxscykge1xuICAgICAgY29uc3QgZGF0YSA9IGdyb3VwZWRDYWxsc1trZXldXG4gICAgICBkYXRhLmF2ZXJhZ2VEdXJhdGlvbiA9IGRhdGEudG90YWxEdXJhdGlvbiAvIGRhdGEuY2FsbHNcblxuICAgICAgY2FsbHNBcnJheS5wdXNoKHsgZnVuY3Rpb25OYW1lOiBrZXksIGRhdGEgfSlcbiAgICB9XG5cbiAgICBjYWxsc0FycmF5LnNvcnQoKGEsIGIpID0+IGIuZGF0YS50b3RhbER1cmF0aW9uIC0gYS5kYXRhLnRvdGFsRHVyYXRpb24pXG4gICAgY2FsbHNBcnJheSA9IGNhbGxzQXJyYXkuc2xpY2UoMCwgMylcblxuICAgIGNhbGxzQXJyYXkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgTG9nLmxvZyh0YWcsIGAke2l0ZW0uZnVuY3Rpb25OYW1lfTogJHtpdGVtLmRhdGEuY2FsbHN9IGNhbGxzLCAke2l0ZW0uZGF0YS50b3RhbER1cmF0aW9uLnRvRml4ZWQoMil9bXNgKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29udGV4dFBlcmZvcm1hbmNlSG9va1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdXRpbHMvY29udGV4dC1wZXJmb3JtYW5jZS1ob29rLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IENhbnZhcyBmcm9tICdjYW52YXMnXG5cbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGFuIGltYWdlIGluIHBpeGVsIGFycmF5IGZvcm0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpeGVsQXJyYXlJbWFnZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSAge051bWJlcn0gaGVpZ2h0XG4gICAqIEBwYXJhbSAge1VJbnQ4QXJyYXl9IGRhdGFcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvciAod2lkdGgsIGhlaWdodCwgZGF0YSkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aFxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy5kYXRhID0gZGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQaXhlbEFycmF5SW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gYG5vZGUtY2FudmFzYCBJbWFnZSBvYmplY3QgYnkgcmVuZGVyaW5nIHRoZSBpbWFnZVxuICAgKiB0byBhIGNhbnZhcyBhbmQgcmVhZGluZyB0aGUgcGl4ZWwgZGF0YVxuICAgKiBAcGFyYW0gIHtDYW52YXMuSW1hZ2V9IGltYWdlXG4gICAqIEByZXR1cm4ge1BpeGVsQXJyYXlJbWFnZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tTm9kZUNhbnZhc0ltYWdlIChpbWFnZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBDYW52YXMoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodClcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpXG4gICAgcmV0dXJuIG5ldyBQaXhlbEFycmF5SW1hZ2UoaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgaW1hZ2VEYXRhLmRhdGEpXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL3V0aWxzL3BpeGVsLWFycmF5LWltYWdlLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29ycmVjdGx5IHNldCB1cCB0aGUgcHJvdG90eXBlIGNoYWluXG4gKiBCYXNlZCBvbiB0aGUgYmFja2JvbmUuanMgZXh0ZW5kIGZ1bmN0aW9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy9iYWNrYm9uZS9ibG9iL21hc3Rlci9iYWNrYm9uZS5qc1xuICogQHBhcmFtICB7T2JqZWN0fSBwcm90b3R5cGVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0gIHtPYmplY3R9IGNsYXNzUHJvcGVydGllc1xuICogQHJldHVybiB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwcm90b3R5cGVQcm9wZXJ0aWVzLCBjbGFzc1Byb3BlcnRpZXMpIHtcbiAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBwYXJlbnQgPSB0aGlzXG4gIHZhciBjaGlsZFxuXG4gIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcbiAgLy8gKHRoZSAnY29uc3RydWN0b3InIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxuICAvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXG4gIGlmIChwcm90b3R5cGVQcm9wZXJ0aWVzICYmIHByb3RvdHlwZVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcbiAgICBjaGlsZCA9IHByb3RvdHlwZVByb3BlcnRpZXMuY29uc3RydWN0b3JcbiAgfSBlbHNlIHtcbiAgICBjaGlsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfVxuXG4gIC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxuICB2YXIga2V5XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XVxuICB9XG4gIGlmICh0eXBlb2YgY2xhc3NQcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZvciAoa2V5IGluIGNsYXNzUHJvcGVydGllcykge1xuICAgICAgY2hpbGRba2V5XSA9IGNsYXNzUHJvcGVydGllc1trZXldXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkIH1cbiAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGVcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpXG5cbiAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gIC8vIGlmIHN1cHBsaWVkLlxuICBpZiAocHJvdG90eXBlUHJvcGVydGllcykge1xuICAgIGZvciAoa2V5IGluIHByb3RvdHlwZVByb3BlcnRpZXMpIHtcbiAgICAgIGNoaWxkLnByb3RvdHlwZVtrZXldID0gcHJvdG90eXBlUHJvcGVydGllc1trZXldXG4gICAgfVxuICB9XG5cbiAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxuICAvLyBsYXRlci5cbiAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZVxuXG4gIHJldHVybiBjaGlsZFxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvZXh0ZW5kLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFZlY3RvcjIgZnJvbSAnLi92ZWN0b3IyJ1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSAzLWRpbWVuc2lvbmFsIG1hdHJpeFxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuTWF0aFxuICovXG5jbGFzcyBNYXRyaXgge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIE1hdHJpeFxuICAgKi9cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGxpZXMgdGhpcyBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguTWF0cml4fSBtYXRyaXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5NYXRyaXh9XG4gICAqL1xuICBtdWx0aXBseSAobWF0cml4KSB7XG4gICAgbGV0IGEsIGIsIGMsIGQsIHR4LCB0eVxuICAgIGEgPSB0aGlzLmEgKiBtYXRyaXguYSArIHRoaXMuYiAqIG1hdHJpeC5jXG4gICAgYiA9IHRoaXMuYSAqIG1hdHJpeC5iICsgdGhpcy5iICogbWF0cml4LmRcbiAgICBjID0gdGhpcy5jICogbWF0cml4LmEgKyB0aGlzLmQgKiBtYXRyaXguY1xuICAgIGQgPSB0aGlzLmMgKiBtYXRyaXguYiArIHRoaXMuZCAqIG1hdHJpeC5kXG4gICAgdHggPSB0aGlzLnR4ICogbWF0cml4LmEgKyB0aGlzLnR5ICogbWF0cml4LmMgKyBtYXRyaXgudHhcbiAgICB0eSA9IHRoaXMudHggKiBtYXRyaXguYiArIHRoaXMudHkgKiBtYXRyaXguZCArIG1hdHJpeC50eVxuXG4gICAgdGhpcy5hID0gYVxuICAgIHRoaXMuYiA9IGJcbiAgICB0aGlzLmMgPSBjXG4gICAgdGhpcy5kID0gZFxuICAgIHRoaXMudHggPSB0eFxuICAgIHRoaXMudHkgPSB0eVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gcG9zaXRpb25cbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgYXBwbHlUb1ZlY3RvciAocG9zaXRpb24pIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvc2l0aW9uXG4gICAgcG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpXG4gICAgcG9zaXRpb24ueCA9IHRoaXMuYSAqIHggKyB0aGlzLmMgKiB5ICsgdGhpcy50eFxuICAgIHBvc2l0aW9uLnkgPSB0aGlzLmIgKiB4ICsgdGhpcy5kICogeSArIHRoaXMudHhcbiAgICByZXR1cm4gcG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IHRvIHRoZSBnaXZlbiB2ZWN0b3JcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBhcHBseUludmVyc2VUb1ZlY3RvciAocG9zaXRpb24pIHtcbiAgICBjb25zdCBkZXRlcm1pbmFudCA9IDEgLyAodGhpcy5hICogdGhpcy5kICsgdGhpcy5jICogLXRoaXMuYilcblxuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9zaXRpb25cbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKClcbiAgICBwb3NpdGlvbi54ID0gdGhpcy5kICogZGV0ZXJtaW5hbnQgKiB4ICtcbiAgICAgIC10aGlzLmMgKiBkZXRlcm1pbmFudCAqIHkgK1xuICAgICAgKHRoaXMudHkgKiB0aGlzLmMgLSB0aGlzLnR4ICogdGhpcy5kKSAqIGRldGVybWluYW50XG4gICAgcG9zaXRpb24ueSA9IHRoaXMuYSAqIGRldGVybWluYW50ICogeSArXG4gICAgICAtdGhpcy5iICogZGV0ZXJtaW5hbnQgKiB4ICtcbiAgICAgICgtdGhpcy50eSAqIHRoaXMuYSArIHRoaXMudHggKiB0aGlzLmIpICogZGV0ZXJtaW5hbnRcblxuICAgIHJldHVybiBwb3NpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFR1cm5zIHRoZSBnaXZlbiByZWN0YW5nbGUgaW50byB2ZWN0b3IgY29vcmRpbmF0ZXMgYnkgYXBwbHlpbmcgdGhpcyBNYXRyaXhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9IHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGFuY2hvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJbXX1cbiAgICovXG4gIHJlY3RhbmdsZVRvQ29vcmRpbmF0ZXMgKHJlY3RhbmdsZSwgYW5jaG9yID0gbmV3IFZlY3RvcjIoMCwgMCkpIHtcbiAgICAvLyBBbmNob3Igb2Zmc2V0cyAodzAgPSByaWdodCwgdzEgPSBsZWZ0LCBoMCA9IHVwLCBoMSA9IGRvd24pXG4gICAgY29uc3QgdzAgPSByZWN0YW5nbGUud2lkdGggKiAoMSAtIGFuY2hvci54KVxuICAgIGNvbnN0IHcxID0gcmVjdGFuZ2xlLndpZHRoICogLWFuY2hvci54XG4gICAgY29uc3QgaDAgPSByZWN0YW5nbGUuaGVpZ2h0ICogKDEgLSBhbmNob3IueSlcbiAgICBjb25zdCBoMSA9IHJlY3RhbmdsZS5oZWlnaHQgKiAtYW5jaG9yLnlcblxuICAgIGxldCBwb3NpdGlvbnMgPSBbXVxuXG4gICAgLy8gQm90dG9tIExlZnRcbiAgICBwb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMihcbiAgICAgIHRoaXMuYSAqIHcxICsgdGhpcy5jICogaDEgKyB0aGlzLnR4LFxuICAgICAgdGhpcy5kICogaDEgKyB0aGlzLmIgKiB3MSArIHRoaXMudHlcbiAgICApKVxuXG4gICAgLy8gQm90dG9tIFJpZ2h0XG4gICAgcG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjIoXG4gICAgICB0aGlzLmEgKiB3MCArIHRoaXMuYyAqIGgxICsgdGhpcy50eCxcbiAgICAgIHRoaXMuZCAqIGgxICsgdGhpcy5iICogdzAgKyB0aGlzLnR5XG4gICAgKSlcblxuICAgIC8vIFRvcCBSaWdodFxuICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKFxuICAgICAgdGhpcy5hICogdzAgKyB0aGlzLmMgKiBoMCArIHRoaXMudHgsXG4gICAgICB0aGlzLmQgKiBoMCArIHRoaXMuYiAqIHcwICsgdGhpcy50eVxuICAgICkpXG5cbiAgICAvLyBUb3AgTGVmdFxuICAgIHBvc2l0aW9ucy5wdXNoKG5ldyBWZWN0b3IyKFxuICAgICAgdGhpcy5hICogdzEgKyB0aGlzLmMgKiBoMCArIHRoaXMudHgsXG4gICAgICB0aGlzLmQgKiBoMCArIHRoaXMuYiAqIHcxICsgdGhpcy50eVxuICAgICkpXG5cbiAgICByZXR1cm4gcG9zaXRpb25zXG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgbWF0cml4IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAgICovXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLmEgPSAxXG4gICAgdGhpcy5iID0gMFxuICAgIHRoaXMuYyA9IDBcbiAgICB0aGlzLmQgPSAxXG4gICAgdGhpcy50eCA9IDBcbiAgICB0aGlzLnR5ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBtYXRyaXhcbiAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgY29uc3QgYXJyID0gW1xuICAgICAgdGhpcy5hLCB0aGlzLmIsIDAsXG4gICAgICB0aGlzLmMsIHRoaXMuZCwgMCxcbiAgICAgIHRoaXMudHgsIHRoaXMudHksIDFcbiAgICBdXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaWRlbnRpdHkgbWF0cml4XG4gICAqIEBzdGF0aWNcbiAgICogQHR5cGUge1Bob3RvRWRpdG9yU0RLLk1hdGguTWF0cml4fVxuICAgKi9cbiAgc3RhdGljIGdldCBJREVOVElUWSAoKSB7IHJldHVybiBuZXcgTWF0cml4KCkgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNYXRyaXhcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL21hdGgvbWF0cml4LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgUmVjdGFuZ2xlXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5NYXRoXG4gKi9cbmNsYXNzIFJlY3RhbmdsZSB7XG4gIC8qKlxuICAgKiBDcmVhcnRlcyBhIFJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3ggPSAwXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kgPSAwXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoICA9IDBdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaGVpZ2h0ID0gMF1cbiAgICovXG4gIGNvbnN0cnVjdG9yICh4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgIHRoaXMueCA9IHhcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBzZXQgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnggPSB4XG4gICAgdGhpcy55ID0geVxuICAgIHRoaXMud2lkdGggPSB3aWR0aFxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyByZWN0YW5nbGVcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5SZWN0YW5nbGV9IG90aGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgY29weSAob3RoZXIpIHtcbiAgICB0aGlzLnggPSBvdGhlci54XG4gICAgdGhpcy55ID0gb3RoZXIueVxuICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aFxuICAgIHRoaXMuaGVpZ2h0ID0gb3RoZXIuaGVpZ2h0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJlY3RhbmdsZSdzIHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIGdpdmVuIG9uZXNcbiAgICogQHBhcmFtICB7KE51bWJlcnxQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZSl9IHJlY3RcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEBwYXJhbSAge051bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGVxdWFscyAocmVjdCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChyZWN0IGluc3RhbmNlb2YgUmVjdGFuZ2xlKSB7XG4gICAgICByZXR1cm4gcmVjdC54ID09PSB0aGlzLnggJiZcbiAgICAgICAgcmVjdC55ID09PSB0aGlzLnkgJiZcbiAgICAgICAgcmVjdC53aWR0aCA9PT0gdGhpcy53aWR0aCAmJlxuICAgICAgICByZWN0LmhlaWdodCA9PT0gdGhpcy5oZWlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeCA9IHJlY3RcbiAgICAgIHJldHVybiB4ID09PSB0aGlzLnggJiZcbiAgICAgICAgeSA9PT0gdGhpcy55ICYmXG4gICAgICAgIHdpZHRoID09PSB0aGlzLndpZHRoICYmXG4gICAgICAgIGhlaWdodCA9PT0gdGhpcy5oZWlnaHRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUm91bmRzIHRoaXMgcmVjdGFuZ2xlJ3MgdmFsdWVzXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguUmVjdGFuZ2xlfVxuICAgKi9cbiAgcm91bmQgKCkge1xuICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KVxuICAgIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KVxuICAgIHRoaXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGgpXG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHJlY3RhbmdsZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIGBSZWN0YW5nbGUoeyB4OiAke3RoaXMueH0sIHk6ICR7dGhpcy55fSwgd2lkdGg6ICR7dGhpcy53aWR0aH0sIGhlaWdodDogJHt0aGlzLmhlaWdodH0gfSlgXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdGFuZ2xlXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2xpYi9tYXRoL3JlY3RhbmdsZS5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZyB9IGZyb20gJy4uL2dsb2JhbHMnXG5jb25zdCBub3cgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlXG4gID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSlcbiAgOiByZXF1aXJlKCdwZXJmb3JtYW5jZS1ub3cnKSlcblxuLyoqXG4gKiBBIHNpbXBsZSBjbGFzcyB0aGF0IHRyYWNrcyB0aGUgdGltZSBiZXR3ZWVuIHN0YXJ0IGFuZCBlbmQgYW5kIHJlbmRlcnMgaXQgYXMgRlBTXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNES1xuICogQGlnbm9yZVxuICovXG5jbGFzcyBQZXJmb3JtYW5jZVRlc3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlcmZvcm1hbmNlVGVzdFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRhZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YWcsIG5hbWUpIHtcbiAgICB0aGlzLl90YWcgPSB0YWdcbiAgICB0aGlzLl9uYW1lID0gbmFtZVxuICAgIHRoaXMuX3N0YXJ0ID0gbm93KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgcGVyZm9ybWFuY2UgdGVzdCBhbmQgcHJpbnRzIHRoZSByZXN1bHRcbiAgICovXG4gIHN0b3AgKCkge1xuICAgIGNvbnN0IGVuZCA9IG5vdygpXG4gICAgY29uc3QgbXMgPSBlbmQgLSB0aGlzLl9zdGFydFxuICAgIGNvbnN0IGZwcyA9IE1hdGgucm91bmQoMTAwMCAvIG1zKVxuICAgIExvZy5pbmZvKHRoaXMuX3RhZywgYCR7dGhpcy5fbmFtZX0gdG9vayAke21zLnRvRml4ZWQoMil9bXMgKCR7ZnBzfSBGUFMpYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQZXJmb3JtYW5jZVRlc3RcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3BlcmZvcm1hbmNlLXRlc3QuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBFbmdpbmUgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuXG5jbGFzcyBBZGp1c3RtZW50c0ZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZ2VuZXJpYy9hZGp1c3RtZW50cy5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBsZXQgeyBicmlnaHRuZXNzLCBzYXR1cmF0aW9uLCBjb250cmFzdCB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgY29uc3QgYXBwbHlCcmlnaHRuZXNzID0gYnJpZ2h0bmVzcyAhPT0gMFxuICAgIGNvbnN0IGFwcGx5U2F0dXJhdGlvbiA9IHNhdHVyYXRpb24gIT09IDFcbiAgICBjb25zdCBhcHBseUNvbnRyYXN0ID0gY29udHJhc3QgIT09IDFcblxuICAgIGJyaWdodG5lc3MgPSBicmlnaHRuZXNzICogMjU1XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQ7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogNFxuICAgICAgbGV0IHIgPSBpbWFnZURhdGEuZGF0YVtpbmRleF1cbiAgICAgIGxldCBnID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXVxuICAgICAgbGV0IGIgPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdXG5cbiAgICAgIC8vIEJyaWdodG5lc3NcbiAgICAgIGlmIChhcHBseUJyaWdodG5lc3MpIHtcbiAgICAgICAgciA9IHIgKyBicmlnaHRuZXNzXG4gICAgICAgIGcgPSBnICsgYnJpZ2h0bmVzc1xuICAgICAgICBiID0gYiArIGJyaWdodG5lc3NcbiAgICAgIH1cblxuICAgICAgLy8gU2F0dXJhdGlvblxuICAgICAgaWYgKGFwcGx5U2F0dXJhdGlvbikge1xuICAgICAgICBjb25zdCBsdW1pbmFuY2UgPSByICogMC4yMTI1ICsgZyAqIDAuNzE1NCArIGIgKiAwLjA3MjFcbiAgICAgICAgciA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAociAqIHNhdHVyYXRpb24pXG4gICAgICAgIGcgPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGcgKiBzYXR1cmF0aW9uKVxuICAgICAgICBiID0gbHVtaW5hbmNlICogKDEgLSBzYXR1cmF0aW9uKSArIChiICogc2F0dXJhdGlvbilcbiAgICAgIH1cblxuICAgICAgLy8gQ29udHJhc3RcbiAgICAgIGlmIChhcHBseUNvbnRyYXN0KSB7XG4gICAgICAgIHIgPSAociAtIDEyNykgKiBjb250cmFzdCArIDEyN1xuICAgICAgICBnID0gKGcgLSAxMjcpICogY29udHJhc3QgKyAxMjdcbiAgICAgICAgYiA9IChiIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3XG4gICAgICB9XG5cbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IHJcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBnXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gYlxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG5BZGp1c3RtZW50c0ZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgYnJpZ2h0bmVzczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICBzYXR1cmF0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxLCB1bmlmb3JtVHlwZTogJ2YnIH0sXG4gIGNvbnRyYXN0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxLCB1bmlmb3JtVHlwZTogJ2YnIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQWRqdXN0bWVudHNGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9hZGp1c3RtZW50cy9hZGp1c3RtZW50cy1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEEgQ29udHJvbFBvaW50IGlzIGEgcGFydCBvZiBhIHtAbGluayBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLlBhdGh9LCBzbyBhIFBhdGhcbiAqIGNvbnNpc3RzIG9mIG11bHRpcGxlIENvbnRyb2xQb2ludHMuIFNob3VsZCBvbmx5IGJlIGNyZWF0ZWQgdXNpbmcge0BsaW5rIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb24uUGF0aCNhZGRDb250cm9sUG9pbnR9XG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uXG4gKi9cbmNsYXNzIENvbnRyb2xQb2ludCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29udHJvbFBvaW50XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb24uUGF0aH0gcGF0aFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IHBvc2l0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocGF0aCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLl9wYXRoID0gcGF0aFxuICAgIHRoaXMuX2RyYXduQ2FudmFzZXMgPSBbXVxuICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoaXMgQ29udHJvbFBvaW50IHRvIHRoZSBnaXZlbiBjYW52YXNcbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLkNvbnRyb2xQb2ludH0gbGFzdENvbnRyb2xQb2ludFxuICAgKi9cbiAgcmVuZGVyVG9DYW52YXMgKGNhbnZhcywgbGFzdENvbnRyb2xQb2ludCkge1xuICAgIGlmICh0aGlzLl9kcmF3bkNhbnZhc2VzLmluZGV4T2YoY2FudmFzKSAhPT0gLTEpIHtcbiAgICAgIC8vIFRoaXMgY29udHJvbCBwb2ludCBoYXMgYWxyZWFkeSBiZWVuIGRyYXduIG9uIHRoaXMgY2FudmFzLiBJZ25vcmUuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uXG4gICAgY29uc3QgbGFzdFBvc2l0aW9uID0gbGFzdENvbnRyb2xQb2ludC5nZXRQb3NpdGlvbigpXG5cbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCdcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5fcGF0aC5nZXRDb2xvcigpLnRvUkdCQSgpXG4gICAgY29udGV4dC5saW5lV2lkdGggPSB0aGlzLl9wYXRoLmdldFRoaWNrbmVzcygpXG4gICAgY29udGV4dC5tb3ZlVG8obGFzdFBvc2l0aW9uLngsIGxhc3RQb3NpdGlvbi55KVxuICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKVxuICAgIGNvbnRleHQuc3Ryb2tlKClcbiAgICB0aGlzLl9kcmF3bkNhbnZhc2VzLnB1c2goY2FudmFzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKi9cbiAgc2V0UG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldFBvc2l0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24uY2xvbmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBDb250cm9sUG9pbnQgdG8gZGlydHlcbiAgICovXG4gIHNldERpcnR5ICgpIHtcbiAgICB0aGlzLl9kcmF3bkNhbnZhc2VzID0gW11cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250cm9sUG9pbnRcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9icnVzaC9jb250cm9sLXBvaW50LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuXG4vKipcbiAqIElkZW50aXR5IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIElkZW50aXR5RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge0VuZ2luZS5SZW5kZXJUZXh0dXJlfVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgcmVuZGVyIChzZGssIHJlbmRlclRleHR1cmUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxufVxuXG5JZGVudGl0eUZpbHRlci5pc0lkZW50aXR5ID0gdHJ1ZVxuSWRlbnRpdHlGaWx0ZXIuZGlzcGxheU5hbWUgPSAnT3JpZ2luYWwnXG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuSWRlbnRpdHlGaWx0ZXIuaWRlbnRpZmllciA9ICdpZGVudGl0eSdcblxuZXhwb3J0IGRlZmF1bHQgSWRlbnRpdHlGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2lkZW50aXR5LWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmNvbnN0IFRFWFRVUkVfR0xfVU5JVCA9IDNcblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUvJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcblxuY2xhc3MgTG9va3VwVGFibGVGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi8uLi9zaGFkZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fb3B0aW9ucy5sb29rdXBUYWJsZURhdGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbnZhcy53aWR0aCAqIGNhbnZhcy5oZWlnaHQ7IGkrKykge1xuICAgICAgY29uc3QgaW5kZXggPSBpICogNFxuXG4gICAgICB2YXIgciA9IGltYWdlRGF0YS5kYXRhW2luZGV4XVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gdGFibGVbciAqIDRdXG4gICAgICB2YXIgZyA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV1cbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSB0YWJsZVsxICsgZyAqIDRdXG4gICAgICB2YXIgYiA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl1cbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSB0YWJsZVsyICsgYiAqIDRdXG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkxvb2t1cFRhYmxlRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBsb29rdXBUYWJsZTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogVEVYVFVSRV9HTF9VTklULCB1bmlmb3JtVHlwZTogJ2knIH0sXG4gIGxvb2t1cFRhYmxlRGF0YTogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9XG59XG5cbi8qKlxuICogU3RvcmVzIGEgMjU2IGJ5dGUgbG9uZyBsb29rdXAgdGFibGUgaW4gYSAyZCB0ZXh0dXJlIHdoaWNoIHdpbGwgYmVcbiAqIHVzZWQgdG8gbG9vayB1cCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgZWFjaCBjaGFubmVsLlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgTG9va3VwVGFibGUgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgTG9va3VwVGFibGVGaWx0ZXIoKVxuICAgIHRoaXMuX3RleHR1cmVzID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBiZWZvcmUgdGhpcyBwcmltaXRpdmUncyBmaWx0ZXIgaXMgYmVpbmcgYXBwbGllZFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICovXG4gIHVwZGF0ZSAoc2RrKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2ViR0xUZXh0dXJlKHNkaylcbiAgICB9IGVsc2UgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKCdjYW52YXMnKSkge1xuICAgICAgdGhpcy5fZmlsdGVyLnNldExvb2t1cFRhYmxlRGF0YSh0aGlzLl9vcHRpb25zLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxvb2t1cCB0YWJsZSB0ZXh0dXJlIChXZWJHTCBvbmx5KVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF91cGRhdGVXZWJHTFRleHR1cmUgKHNkaykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5kYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb29rdXBUYWJsZTogTm8gZGF0YSBzcGVjaWZpZWQuJylcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fb3B0aW9ucy5kYXRhKVxuXG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIGNvbnN0IHsgaWQgfSA9IHJlbmRlcmVyXG4gICAgaWYgKCF0aGlzLl90ZXh0dXJlc1tpZF0pIHtcbiAgICAgIHRoaXMuX3RleHR1cmVzW2lkXSA9IG5ldyBFbmdpbmUuQmFzZVRleHR1cmUoKVxuICAgIH1cblxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1tpZF1cbiAgICBjb25zdCBwaXhlbEFycmF5SW1hZ2UgPSBuZXcgRW5naW5lLlBpeGVsQXJyYXlJbWFnZSgyNTYsIDEsIGRhdGEpXG4gICAgdGV4dHVyZS5zZXRTb3VyY2UocGl4ZWxBcnJheUltYWdlKVxuICAgIHRleHR1cmUuc2V0R0xVbml0KFRFWFRVUkVfR0xfVU5JVClcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHJlbmRlcmVyLmlzT2ZUeXBlKCd3ZWJnbCcpKSB7XG4gICAgICByZW5kZXJlci51cGRhdGVUZXh0dXJlKHRleHR1cmUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIHByaW1pdGl2ZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gICAgZm9yIChsZXQgaWQgaW4gdGhpcy5fdGV4dHVyZXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl90ZXh0dXJlc1tpZF1cbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX29wdGlvbnMuZGF0YVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvb2t1cFRhYmxlXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2xvb2t1cC10YWJsZS5qc1xuICoqLyIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cInVzZSBzdHJpY3RcIjtcbi8qIVxuXG5TdGFja0JsdXIgLSBhIGZhc3QgYWxtb3N0IEdhdXNzaWFuIEJsdXIgRm9yIENhbnZhc1xuXG5WZXJzaW9uOiAgMC41XG5BdXRob3I6ICAgTWFyaW8gS2xpbmdlbWFublxuQ29udGFjdDogIG1hcmlvQHF1YXNpbW9uZG8uY29tXG5XZWJzaXRlOiAgaHR0cDovL3d3dy5xdWFzaW1vbmRvLmNvbS9TdGFja0JsdXJGb3JDYW52YXNcblR3aXR0ZXI6ICBAcXVhc2ltb25kb1xuXG5JbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbkkgYW0gbm90IHRvdGFsbHkgdW5oYXBweSBmb3IgYSBzbWFsbCBkb25hdGlvbiB0byBteSBQYXlQYWwgYWNjb3VudFxubWFyaW9AcXVhc2ltb25kby5kZVxuXG5PciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbmh0dHBzOi8vZmxhdHRyLmNvbS90aGluZy83Mjc5MS9TdGFja0JsdXItYS1mYXN0LWFsbW9zdC1HYXVzc2lhbi1CbHVyLUVmZmVjdC1mb3ItQ2FudmFzSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKGMpIDIwMTAgTWFyaW8gS2xpbmdlbWFublxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxub2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbmZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxucmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG5jb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG5Tb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG5PRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbkhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG5GUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG5PVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG52YXIgbXVsX3RhYmxlID0gW1xuICAgICAgICA1MTIsNTEyLDQ1Niw1MTIsMzI4LDQ1NiwzMzUsNTEyLDQwNSwzMjgsMjcxLDQ1NiwzODgsMzM1LDI5Miw1MTIsXG4gICAgICAgIDQ1NCw0MDUsMzY0LDMyOCwyOTgsMjcxLDQ5Niw0NTYsNDIwLDM4OCwzNjAsMzM1LDMxMiwyOTIsMjczLDUxMixcbiAgICAgICAgNDgyLDQ1NCw0MjgsNDA1LDM4MywzNjQsMzQ1LDMyOCwzMTIsMjk4LDI4NCwyNzEsMjU5LDQ5Niw0NzUsNDU2LFxuICAgICAgICA0MzcsNDIwLDQwNCwzODgsMzc0LDM2MCwzNDcsMzM1LDMyMywzMTIsMzAyLDI5MiwyODIsMjczLDI2NSw1MTIsXG4gICAgICAgIDQ5Nyw0ODIsNDY4LDQ1NCw0NDEsNDI4LDQxNyw0MDUsMzk0LDM4MywzNzMsMzY0LDM1NCwzNDUsMzM3LDMyOCxcbiAgICAgICAgMzIwLDMxMiwzMDUsMjk4LDI5MSwyODQsMjc4LDI3MSwyNjUsMjU5LDUwNyw0OTYsNDg1LDQ3NSw0NjUsNDU2LFxuICAgICAgICA0NDYsNDM3LDQyOCw0MjAsNDEyLDQwNCwzOTYsMzg4LDM4MSwzNzQsMzY3LDM2MCwzNTQsMzQ3LDM0MSwzMzUsXG4gICAgICAgIDMyOSwzMjMsMzE4LDMxMiwzMDcsMzAyLDI5NywyOTIsMjg3LDI4MiwyNzgsMjczLDI2OSwyNjUsMjYxLDUxMixcbiAgICAgICAgNTA1LDQ5Nyw0ODksNDgyLDQ3NSw0NjgsNDYxLDQ1NCw0NDcsNDQxLDQzNSw0MjgsNDIyLDQxNyw0MTEsNDA1LFxuICAgICAgICAzOTksMzk0LDM4OSwzODMsMzc4LDM3MywzNjgsMzY0LDM1OSwzNTQsMzUwLDM0NSwzNDEsMzM3LDMzMiwzMjgsXG4gICAgICAgIDMyNCwzMjAsMzE2LDMxMiwzMDksMzA1LDMwMSwyOTgsMjk0LDI5MSwyODcsMjg0LDI4MSwyNzgsMjc0LDI3MSxcbiAgICAgICAgMjY4LDI2NSwyNjIsMjU5LDI1Nyw1MDcsNTAxLDQ5Niw0OTEsNDg1LDQ4MCw0NzUsNDcwLDQ2NSw0NjAsNDU2LFxuICAgICAgICA0NTEsNDQ2LDQ0Miw0MzcsNDMzLDQyOCw0MjQsNDIwLDQxNiw0MTIsNDA4LDQwNCw0MDAsMzk2LDM5MiwzODgsXG4gICAgICAgIDM4NSwzODEsMzc3LDM3NCwzNzAsMzY3LDM2MywzNjAsMzU3LDM1NCwzNTAsMzQ3LDM0NCwzNDEsMzM4LDMzNSxcbiAgICAgICAgMzMyLDMyOSwzMjYsMzIzLDMyMCwzMTgsMzE1LDMxMiwzMTAsMzA3LDMwNCwzMDIsMjk5LDI5NywyOTQsMjkyLFxuICAgICAgICAyODksMjg3LDI4NSwyODIsMjgwLDI3OCwyNzUsMjczLDI3MSwyNjksMjY3LDI2NSwyNjMsMjYxLDI1OV07XG5cblxudmFyIHNoZ190YWJsZSA9IFtcbiAgICAgICA5LCAxMSwgMTIsIDEzLCAxMywgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTYsIDE2LCAxNiwgMTYsIDE3LFxuICAgIDE3LCAxNywgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE5LFxuICAgIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxuICAgIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIxLFxuICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuICAgIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLFxuICAgIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLFxuICAgIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LFxuICAgIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQgXTtcblxuZnVuY3Rpb24gc3RhY2tCbHVyQ2FudmFzUkdCQSggaW1hZ2VEYXRhLCB0b3BfeCwgdG9wX3ksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyApXG57XG4gIGlmICggaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPCAxICkge1xuICAgIHJldHVybjtcbiAgfVxuICByYWRpdXMgfD0gMDtcblxuICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgdmFyIHgsIHksIGksIHAsIHlwLCB5aSwgeXcsIHJfc3VtLCBnX3N1bSwgYl9zdW0sIGFfc3VtLFxuICByX291dF9zdW0sIGdfb3V0X3N1bSwgYl9vdXRfc3VtLCBhX291dF9zdW0sXG4gIHJfaW5fc3VtLCBnX2luX3N1bSwgYl9pbl9zdW0sIGFfaW5fc3VtLFxuICBwciwgcGcsIHBiLCBwYSwgcmJzO1xuXG4gIHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxO1xuICB2YXIgd2lkdGhNaW51czEgID0gd2lkdGggLSAxO1xuICB2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcbiAgdmFyIHJhZGl1c1BsdXMxICA9IHJhZGl1cyArIDE7XG4gIHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyO1xuXG4gIHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xuICB2YXIgc3RhY2tFbmQ7XG4gIHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG4gIGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKVxuICB7XG4gICAgc3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuICAgIGlmICggaSA9PSByYWRpdXNQbHVzMSApIHN0YWNrRW5kID0gc3RhY2s7XG4gIH1cbiAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG4gIHZhciBzdGFja0luID0gbnVsbDtcbiAgdmFyIHN0YWNrT3V0ID0gbnVsbDtcblxuICB5dyA9IHlpID0gMDtcblxuICB2YXIgbXVsX3N1bSA9IG11bF90YWJsZVtyYWRpdXNdO1xuICB2YXIgc2hnX3N1bSA9IHNoZ190YWJsZVtyYWRpdXNdO1xuXG4gIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICB7XG4gICAgcl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XG5cbiAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldICk7XG4gICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpKzFdICk7XG4gICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBiID0gcGl4ZWxzW3lpKzJdICk7XG4gICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpKzNdICk7XG5cbiAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcbiAgICB7XG4gICAgICBzdGFjay5yID0gcHI7XG4gICAgICBzdGFjay5nID0gcGc7XG4gICAgICBzdGFjay5iID0gcGI7XG4gICAgICBzdGFjay5hID0gcGE7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgZm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgIHtcbiAgICAgIHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcbiAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbcF0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG4gICAgICBnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3ArMV0pKSAqIHJicztcbiAgICAgIGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbcCsyXSkpICogcmJzO1xuICAgICAgYV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1twKzNdKSkgKiByYnM7XG5cbiAgICAgIHJfaW5fc3VtICs9IHByO1xuICAgICAgZ19pbl9zdW0gKz0gcGc7XG4gICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgIGFfaW5fc3VtICs9IHBhO1xuXG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG5cbiAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGg7IHgrKyApXG4gICAge1xuICAgICAgcGl4ZWxzW3lpKzNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgaWYgKCBwYSAhPT0gMCApXG4gICAgICB7XG4gICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgIHBpeGVsc1t5aV0gICA9ICgocl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICBwaXhlbHNbeWkrMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3lpKzJdID0gKChiX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpKzFdID0gcGl4ZWxzW3lpKzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICBwID0gICggeXcgKyAoICggcCA9IHggKyByYWRpdXMgKyAxICkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSApICkgPDwgMjtcblxuICAgICAgcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pO1xuICAgICAgZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSk7XG4gICAgICBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKTtcbiAgICAgIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pO1xuXG4gICAgICByX3N1bSArPSByX2luX3N1bTtcbiAgICAgIGdfc3VtICs9IGdfaW5fc3VtO1xuICAgICAgYl9zdW0gKz0gYl9pbl9zdW07XG4gICAgICBhX3N1bSArPSBhX2luX3N1bTtcblxuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgcl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG4gICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgYV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cbiAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgIHlpICs9IDQ7XG4gICAgfVxuICAgIHl3ICs9IHdpZHRoO1xuICB9XG5cblxuICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuICB7XG4gICAgZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cbiAgICB5aSA9IHggPDwgMjtcbiAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcHIgPSBwaXhlbHNbeWldKTtcbiAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0pO1xuICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYiA9IHBpeGVsc1t5aSsyXSk7XG4gICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBhID0gcGl4ZWxzW3lpKzNdKTtcblxuICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgIGJfc3VtICs9IHN1bUZhY3RvciAqIHBiO1xuICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgZm9yKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuICAgIHtcbiAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgIHN0YWNrLmIgPSBwYjtcbiAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICB9XG5cbiAgICB5cCA9IHdpZHRoO1xuXG4gICAgZm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG4gICAge1xuICAgICAgeWkgPSAoIHlwICsgeCApIDw8IDI7XG5cbiAgICAgIHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuICAgICAgZ19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1t5aSsxXSkpICogcmJzO1xuICAgICAgYl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1t5aSsyXSkpICogcmJzO1xuICAgICAgYV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1t5aSszXSkpICogcmJzO1xuXG4gICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICBpZiggaSA8IGhlaWdodE1pbnVzMSApXG4gICAgICB7XG4gICAgICAgIHlwICs9IHdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpID0geDtcbiAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgIGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuICAgIHtcbiAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgcGl4ZWxzW3ArM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG4gICAgICBpZiAoIHBhID4gMCApXG4gICAgICB7XG4gICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgIHBpeGVsc1twXSAgID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuICAgICAgICBwaXhlbHNbcCsxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3ArMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbcF0gPSBwaXhlbHNbcCsxXSA9IHBpeGVsc1twKzJdID0gMDtcbiAgICAgIH1cblxuICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICBwID0gKCB4ICsgKCggKCBwID0geSArIHJhZGl1c1BsdXMxKSA8IGhlaWdodE1pbnVzMSA/IHAgOiBoZWlnaHRNaW51czEgKSAqIHdpZHRoICkpIDw8IDI7XG5cbiAgICAgIHJfc3VtICs9ICggcl9pbl9zdW0gKz0gKCBzdGFja0luLnIgPSBwaXhlbHNbcF0pKTtcbiAgICAgIGdfc3VtICs9ICggZ19pbl9zdW0gKz0gKCBzdGFja0luLmcgPSBwaXhlbHNbcCsxXSkpO1xuICAgICAgYl9zdW0gKz0gKCBiX2luX3N1bSArPSAoIHN0YWNrSW4uYiA9IHBpeGVsc1twKzJdKSk7XG4gICAgICBhX3N1bSArPSAoIGFfaW5fc3VtICs9ICggc3RhY2tJbi5hID0gcGl4ZWxzW3ArM10pKTtcblxuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgcl9vdXRfc3VtICs9ICggcHIgPSBzdGFja091dC5yICk7XG4gICAgICBnX291dF9zdW0gKz0gKCBwZyA9IHN0YWNrT3V0LmcgKTtcbiAgICAgIGJfb3V0X3N1bSArPSAoIHBiID0gc3RhY2tPdXQuYiApO1xuICAgICAgYV9vdXRfc3VtICs9ICggcGEgPSBzdGFja091dC5hICk7XG5cbiAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgIHlpICs9IHdpZHRoO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBCbHVyU3RhY2soKVxue1xuICB0aGlzLnIgPSAwO1xuICB0aGlzLmcgPSAwO1xuICB0aGlzLmIgPSAwO1xuICB0aGlzLmEgPSAwO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RhY2tCbHVyQ2FudmFzUkdCQTogc3RhY2tCbHVyQ2FudmFzUkdCQVxufTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vdmVuZG9yL3N0YWNrLWJsdXIuanNcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYodGhhdCA9PT0gdW5kZWZpbmVkKXJldHVybiBmbjtcbiAgc3dpdGNoKGxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24oYSl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbihhLCBiLCBjKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKC8qIC4uLmFyZ3MgKi8pe1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xyXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcclxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gODdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxyXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcclxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXHJcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXHJcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcclxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuXHJcbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApe1xyXG4gIE8gPSB0b0lPYmplY3QoTyk7XHJcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xyXG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XHJcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcclxuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XHJcbiAgaWYoaGFzKE8sIFApKXJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXHJcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxyXG4gICwgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcclxuXHJcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XHJcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzXG4gKiogbW9kdWxlIGlkID0gODlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanNcbiAqKiBtb2R1bGUgaWQgPSA5MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXHJcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcclxuICAsIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpXHJcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZXMpe1xyXG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxyXG4gICAgLCBpICAgICAgPSAwXHJcbiAgICAsIHJlc3VsdCA9IFtdXHJcbiAgICAsIGtleTtcclxuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xyXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcclxuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbiAqKiBtb2R1bGUgaWQgPSA5MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA5MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9wZXJmb3JtYW5jZS1ub3cvbGliL3BlcmZvcm1hbmNlLW5vdy5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5leHBvcnQgeyBkZWZhdWx0IGFzIElkZW50aXR5RmlsdGVyIH0gZnJvbSAnLi9pZGVudGl0eS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEExNUZpbHRlciB9IGZyb20gJy4vYTE1LWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQnJlZXplRmlsdGVyIH0gZnJvbSAnLi9icmVlemUtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCV0ZpbHRlciB9IGZyb20gJy4vYnctZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCV0hhcmRGaWx0ZXIgfSBmcm9tICcuL2J3aGFyZC1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIENlbHNpdXNGaWx0ZXIgfSBmcm9tICcuL2NlbHNpdXMtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBDaGVzdEZpbHRlciB9IGZyb20gJy4vY2hlc3QtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGaXhpZUZpbHRlciB9IGZyb20gJy4vZml4aWUtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGb29kRmlsdGVyIH0gZnJvbSAnLi9mb29kLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRnJpZGdlRmlsdGVyIH0gZnJvbSAnLi9mcmlkZ2UtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBGcm9udEZpbHRlciB9IGZyb20gJy4vZnJvbnQtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHbGFtRmlsdGVyIH0gZnJvbSAnLi9nbGFtLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR29iYmxpbkZpbHRlciB9IGZyb20gJy4vZ29iYmxpbi1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEsxRmlsdGVyIH0gZnJvbSAnLi9rMS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEsyRmlsdGVyIH0gZnJvbSAnLi9rMi1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEs2RmlsdGVyIH0gZnJvbSAnLi9rNi1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIEtEeW5hbWljRmlsdGVyIH0gZnJvbSAnLi9rZHluYW1pYy1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIExlbmluRmlsdGVyIH0gZnJvbSAnLi9sZW5pbi1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIExvbW9GaWx0ZXIgfSBmcm9tICcuL2xvbW8tZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZWxsb3dGaWx0ZXIgfSBmcm9tICcuL21lbGxvdy1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1vcm5pbmdGaWx0ZXIgfSBmcm9tICcuL21vcm5pbmctZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBPcmNoaWRGaWx0ZXIgfSBmcm9tICcuL29yY2hpZC1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBvbGFGaWx0ZXIgfSBmcm9tICcuL3BvbGEtZmlsdGVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQb2xhNjY5RmlsdGVyIH0gZnJvbSAnLi9wb2xhNjY5LWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUXVvemlGaWx0ZXIgfSBmcm9tICcuL3F1b3ppLWZpbHRlcidcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VtaXJlZEZpbHRlciB9IGZyb20gJy4vc2VtaXJlZC1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN1bm55RmlsdGVyIH0gZnJvbSAnLi9zdW5ueS1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRleGFzRmlsdGVyIH0gZnJvbSAnLi90ZXhhcy1maWx0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFg0MDBGaWx0ZXIgfSBmcm9tICcuL3g0MDAtZmlsdGVyJ1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvaW5kZXguanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnRcbiAgeyBSZWN0YW5nbGUsIENvbnN0YW50cywgRW5naW5lLCBVdGlscywgRXZlbnRFbWl0dGVyLCBWZWN0b3IyLCBMb2csIHJlcXVlc3RBbmltYXRpb25GcmFtZSB9XG5mcm9tICcuL2dsb2JhbHMnXG5pbXBvcnQgKiBhcyBPcGVyYXRpb25zIGZyb20gJy4vb3BlcmF0aW9ucy8nXG5pbXBvcnQgT3BlcmF0aW9uc1N0YWNrIGZyb20gJy4vbGliL29wZXJhdGlvbnMtc3RhY2snXG5pbXBvcnQgVmVyc2lvbkNoZWNrZXIgZnJvbSAnLi9saWIvdmVyc2lvbi1jaGVja2VyJ1xuaW1wb3J0IEV4aWYgZnJvbSAnLi9saWIvZXhpZidcbmltcG9ydCBJbWFnZUV4cG9ydGVyIGZyb20gJy4vbGliL2ltYWdlLWV4cG9ydGVyJ1xuaW1wb3J0IFBlcmZvcm1hbmNlVGVzdCBmcm9tICcuL2xpYi9wZXJmb3JtYW5jZS10ZXN0J1xuXG5jb25zdCB7IFJlbmRlclR5cGUsIEltYWdlRm9ybWF0LCBFdmVudHMgfSA9IENvbnN0YW50c1xuXG4vKipcbiAqIFRoZSBtYWluIFNESyBjbGFzcyB3aGljaCBoYW5kbGVzIHJlbmRlcmluZyBhbmQgbWFuYWdlc1xuICogb3BlcmF0aW9ucy5cbiAqIEBjbGFzc1xuICogQGFsaWFzIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIFBob3RvRWRpdG9yU0RLIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQaG90b0VkaXRvclNESyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IFtwcmVmZXJyZWRSZW5kZXJlciA9IHdlYmdsXSAtIGB3ZWJnbGAgb3IgYGNhbnZhc2BcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9ucyA9IHt9XVxuICAgKiBAcGFyYW0gIHtJbWFnZX0gW29wdGlvbnMuaW1hZ2VdIC0gVGhlIGltYWdlIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkXG4gICAqIEBwYXJhbSAge1N0cmluZ30gW29wdGlvbnMucmVuZGVyTW9kZSA9IGR5bmFtaWNdIC0gYGR5bmFtaWNgIG9yIGBleHBvcnRgXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLnZlcnNpb25DaGVjayA9IHRydWVdIC0gU2hvdWxkIGEgdmVyc2lvbiBjaGVjayBiZSBwZXJmb3JtZWQ/XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtvcHRpb25zLmRpc3BsYXlXZWxjb21lTWVzc2FnZSA9IHRydWVdIC0gU2hvdWxkIGEgd2VsY29tZSBtZXNzYWdlIGJlIHByaW50ZWRcbiAgICogICBpbiB0aGUgY29uc29sZT9cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNwYXJlbnQgPSBmYWxzZV0gLSBTaG91bGQgdGhlIGNhbnZhcyBiYWNrZ3JvdW5kIGJlIHRyYW5zcGFyZW50P1xuICAgKiBAcGFyYW0gIHtIVE1MQ2FudmFzRWxlbWVudH0gW29wdGlvbnMuY2FudmFzXSAtIFRoZSBjYW52YXMgZWxlbWVudCB0aGUgU0RLIHNob3VsZCByZW5kZXIgdG9cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy56b29tID0gMV0gLSBUaGUgem9vbSBsZXZlbC4gT25seSBhdmFpbGFibGUgaW4gYGR5bmFtaWNgIG1vZGVcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5zcHJpdGVTY2FsZSA9IDFdIC0gVGhlIG91dHB1dCBzcHJpdGUncyBzY2FsZS4gT25seSBhdmFpbGFibGUgaW4gYGR5bmFtaWNgIG1vZGVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBbb3B0aW9ucy5sb2dMZXZlbCA9IHdhcm5dIC0gYHRyYWNlYCwgYGluZm9gLCBgd2FybmAsIGBlcnJvcmAgb3IgYGxvZ2BcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbb3B0aW9ucy5waXhlbFJhdGlvID0gMV0gLSBJZiBub25lIGlzIGdpdmVuLCBQaG90b0VkaXRvclNESyBhdXRvbWF0aWNhbGx5XG4gICAqICAgZGV0ZWN0cyB0aGUgY3VycmVudCBkZXZpY2UncyBwaXhlbCByYXRpb1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHByZWZlcnJlZFJlbmRlcmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSA9IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZCA9IHRoaXMuX29uQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcylcblxuICAgIGNvbnN0IHsgdmVyc2lvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJylcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uXG5cbiAgICB0aGlzLl9wcmVmZXJyZWRSZW5kZXJlciA9IHByZWZlcnJlZFJlbmRlcmVyXG4gICAgdGhpcy5fb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGV4dGVuc2lvbnM6IHt9LFxuICAgICAgcmVuZGVyTW9kZTogJ2R5bmFtaWMnLFxuICAgICAgdmVyc2lvbkNoZWNrOiB0cnVlLFxuICAgICAgZGlzcGxheVdlbGNvbWVNZXNzYWdlOiB0cnVlLFxuICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICBjYW52YXM6IG51bGwsXG4gICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICB6b29tOiAxLFxuICAgICAgc3ByaXRlU2NhbGU6IDEsXG4gICAgICBsb2dMZXZlbDogJ3dhcm4nLFxuICAgICAgcGl4ZWxSYXRpbzogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB8fCAxXG4gICAgfSlcblxuICAgIHRoaXMuX29wdGlvbnMuZXh0ZW5zaW9ucyA9IFV0aWxzLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMuZXh0ZW5zaW9ucywge1xuICAgICAgb3BlcmF0aW9uczogW10sXG4gICAgICBjb250cm9sczogW10sXG4gICAgICBsYW5ndWFnZXM6IFtdXG4gICAgfSlcblxuICAgIExvZy5zZXRMZXZlbCh0aGlzLl9vcHRpb25zLmxvZ0xldmVsKVxuXG4gICAgdGhpcy5fZGVmYXVsdFJlbmRlck1vZGUgPSB0aGlzLl9vcHRpb25zLnJlbmRlck1vZGVcbiAgICB0aGlzLl9vZmZzZXQgPSBuZXcgVmVjdG9yMigpXG4gICAgdGhpcy5fem9vbSA9IHRoaXMuX29wdGlvbnMuem9vbVxuICAgIHRoaXMuX3Nwcml0ZVNjYWxlID0gdGhpcy5fb3B0aW9ucy5zcHJpdGVTY2FsZVxuICAgIHRoaXMuX29wZXJhdGlvbnMgPSB7fVxuICAgIHRoaXMuX3JlbmRlck1vZGUgPSB0aGlzLl9vcHRpb25zLnJlbmRlck1vZGVcbiAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2sgPSBudWxsXG4gICAgdGhpcy5zZXRPcGVyYXRpb25zU3RhY2sobmV3IE9wZXJhdGlvbnNTdGFjaygpKVxuXG4gICAgLy8gRW5naW5lIHN0dWZmXG4gICAgdGhpcy5fY29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxuICAgIHRoaXMuX3Nwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fc3ByaXRlKVxuXG4gICAgdGhpcy5faW5wdXRCYXNlVGV4dHVyZSA9IG51bGxcbiAgICB0aGlzLl9pbnB1dFRleHR1cmUgPSBudWxsXG5cbiAgICB0aGlzLl9jaGVja0ZvclVwZGF0ZXMoKVxuICAgIHRoaXMuX3JlZ2lzdGVyT3BlcmF0aW9ucygpXG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgdGhpcy5zZXRJbWFnZSh0aGlzLl9vcHRpb25zLmltYWdlKVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRSZW5kZXJlcigpXG5cbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyLmNvbnN0cnVjdG9yLnR5cGVcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kaXNwbGF5V2VsY29tZU1lc3NhZ2UpIHtcbiAgICAgIExvZy5sb2coJ1lvIScsIGBWZXJzaW9uOiAke3RoaXMudmVyc2lvbn0gKCR7cmVuZGVyZXJ9KSAtIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbWApXG4gICAgfVxuXG4gICAgLy8gQXN5bmMgaW1hZ2UgaGFuZGxpbmdcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5faW5pdC5iaW5kKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBTREtcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0ICgpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgdGhpcy5zZXRJbWFnZSh0aGlzLl9vcHRpb25zLmltYWdlKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBpcyB1cGRhdGVkLiBEZWxlZ2F0ZXMgdGhlIGV2ZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlICguLi5hcmdzKSB7XG4gICAgdGhpcy5lbWl0KEV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBXZWJHTCBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkLiBSZS10cmlnZ2VycyBhIHJlbmRlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIF9vbkNvbnRleHRSZXN0b3JlZCAoKSB7XG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnVHJ5aW5nIHRvIHJlLXJlbmRlciBhZnRlciBXZWJHTCBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkLicpXG4gICAgdGhpcy5zZXRBbGxPcGVyYXRpb25zVG9EaXJ0eSgpXG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLmZvckVhY2goKG9wZXJhdGlvbikgPT4ge1xuICAgICAgb3BlcmF0aW9uLmRpc3Bvc2VSZW5kZXJUZXh0dXJlKClcbiAgICB9KVxuICAgIHRoaXMucmVuZGVyKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBFeHBvcnRzIHRoZSBpbWFnZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLiBSZXN1bHQgb2YgdGhlIFByb21pc2UgaXMgdGhlIGV4cG9ydGVkIGltYWdlIG9yIGRhdGEgdXJsLlxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5SZW5kZXJUeXBlfSBbcmVuZGVyVHlwZT1QaG90b0VkaXRvclNESy5SZW5kZXJUeXBlLkRBVEFVUkxdIC0gVGhlIG91dHB1dCB0eXBlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkltYWdlRm9ybWF0fSBbaW1hZ2VGb3JtYXQ9UGhvdG9FZGl0b3JTREsuSW1hZ2VGb3JtYXQuUE5HXSAtIFRoZSBvdXRwdXQgaW1hZ2UgZm9ybWF0XG4gICAqIEBwYXJhbSAge051bWJlcn0gW3F1YWxpdHk9MC44XSAtIFRoZSBpbWFnZSBxdWFsaXR5LCBiZXR3ZWVuIDAgYW5kIDFcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIGV4cG9ydCAocmVuZGVyVHlwZSA9IFJlbmRlclR5cGUuREFUQVVSTCwgaW1hZ2VGb3JtYXQgPSBJbWFnZUZvcm1hdC5QTkcsIHF1YWxpdHkgPSAwLjgpIHtcbiAgICB0aGlzLl9yZW5kZXJNb2RlID0gJ2V4cG9ydCdcbiAgICBjb25zdCB0ZW1wRGltZW5zaW9ucyA9IHRoaXMuX3JlbmRlcmVyLmdldERpbWVuc2lvbnMoKVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZVRvKHRoaXMuZ2V0RmluYWxEaW1lbnNpb25zKCkpXG5cbiAgICByZXR1cm4gSW1hZ2VFeHBvcnRlci52YWxpZGF0ZVNldHRpbmdzKHJlbmRlclR5cGUsIGltYWdlRm9ybWF0KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKVxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlRXhwb3J0ZXIuZXhwb3J0KFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcy5faW1hZ2UsXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZ2V0Q2FudmFzKCksXG4gICAgICAgICAgcmVuZGVyVHlwZSxcbiAgICAgICAgICBpbWFnZUZvcm1hdCxcbiAgICAgICAgICBxdWFsaXR5KVxuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZVRvKHRlbXBEaW1lbnNpb25zKVxuICAgICAgICB0aGlzLl9yZW5kZXJNb2RlID0gdGhpcy5fZGVmYXVsdFJlbmRlck1vZGVcbiAgICAgICAgdGhpcy5zZXRBbGxPcGVyYXRpb25zVG9EaXJ0eSgpXG4gICAgICAgIHRoaXMucmVuZGVyKClcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBpbWFnZSB0byB0aGUgY2FudmFzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICByZW5kZXIgKCkge1xuICAgIGlmICghdGhpcy5faW1hZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gc2V0IGFuIGltYWdlIGJlZm9yZSBjYWxsaW5nIFBob3RvRWRpdG9yU0RLI3JlbmRlci4nKVxuICAgIH1cblxuICAgIGxldCBjb250ZXh0ID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgaWYgKGNvbnRleHQuc3RhcnRGcmFtZSkge1xuICAgICAgY29udGV4dC5zdGFydEZyYW1lKClcbiAgICB9XG5cbiAgICBsZXQgcGVyZlRlc3RcbiAgICBpZiAoTG9nLmNhbkxvZygnaW5mbycpKSB7XG4gICAgICBwZXJmVGVzdCA9IG5ldyBQZXJmb3JtYW5jZVRlc3QoJ+KaoeKaoeKaoScsICdGcmFtZSByZW5kZXJpbmcnKVxuICAgIH1cbiAgICBMb2cuaW5mbygn4pqh4pqh4pqhJywgJ1JlbmRlcmluZyBzdGFydHMnKVxuXG4gICAgdGhpcy5fY29udGFpbmVyLnNldFBvc2l0aW9uKDAsIDApXG4gICAgdGhpcy5fY29udGFpbmVyLnNldFNjYWxlKDEsIDEpXG4gICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLCAwKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRQb3NpdGlvbigwLCAwKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRTY2FsZSgxLCAxKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRSb3RhdGlvbigwKVxuXG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLl9vcGVyYXRpb25zU3RhY2tcbiAgICBzdGFjay51cGRhdGVEaXJ0aW5lc3NGb3JSZW5kZXJlcih0aGlzLl9yZW5kZXJlcilcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX2lucHV0VGV4dHVyZSlcbiAgICB0aGlzLl9jb250YWluZXIudXBkYXRlVHJhbnNmb3JtKClcblxuICAgIHJldHVybiBzdGFjay52YWxpZGF0ZVNldHRpbmdzKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHN0YWNrLnJlbmRlcih0aGlzLCB0aGlzLl9zcHJpdGUpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3JlbmRlck1vZGUpIHtcbiAgICAgICAgICBjYXNlICdkeW5hbWljJzpcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjZW50ZXIgaW1hZ2UsIHNldCBzY2FsZSB0byB6b29tIGxldmVsXG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9yZW5kZXJlci5nZXREaW1lbnNpb25zKClcbiAgICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgICAgLmRpdmlkZSgyKVxuICAgICAgICAgICAgICAuYWRkKHRoaXMuX29mZnNldClcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRTY2FsZSh0aGlzLl96b29tLCB0aGlzLl96b29tKVxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnNldFBvc2l0aW9uKGNlbnRlcilcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5zZXRBbmNob3IoMC41LCAwLjUpXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUodGhpcy5fc3ByaXRlU2NhbGUsIHRoaXMuX3Nwcml0ZVNjYWxlKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICAgICAgLy8gTW92ZSBzcHJpdGUgdG8gdXBwZXIgbGVmdCBoYW5kIGNvcm5lciwgcmVuZGVyIGF0IGZ1bGwgc2NhbGVcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRTY2FsZSgxLCAxKVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLCAwKVxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlLnNldFBvc2l0aW9uKDAsIDApXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUoMSwgMSlcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZS5zZXRSb3RhdGlvbigwKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAocGVyZlRlc3QpIHtcbiAgICAgICAgICBwZXJmVGVzdC5zdG9wKClcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dC5lbmRGcmFtZSkge1xuICAgICAgICAgIGNvbnRleHQuZW5kRnJhbWUoKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gT1BFUkFUSU9OU1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYWxsIGRlZmF1bHQgb3BlcmF0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlZ2lzdGVyT3BlcmF0aW9ucyAoKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9ucyA9IHt9XG5cbiAgICBmb3IgKGxldCBvcGVyYXRpb25OYW1lIGluIE9wZXJhdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IE9wZXJhdGlvbnNbb3BlcmF0aW9uTmFtZV1cbiAgICAgIHRoaXMuX29wZXJhdGlvbnNbb3BlcmF0aW9uLmlkZW50aWZpZXJdID0gb3BlcmF0aW9uXG4gICAgfVxuXG4gICAgdGhpcy5fb3BlcmF0aW9ucyA9IFV0aWxzLmV4dGVuZCh0aGlzLl9vcGVyYXRpb25zLFxuICAgICAgdGhpcy5fb3B0aW9ucy5leHRlbnNpb25zLm9wZXJhdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbGwgb3BlcmF0aW9ucyBpbiB0aGUgc3RhY2sgdG8gZGlydHlcbiAgICovXG4gIHNldEFsbE9wZXJhdGlvbnNUb0RpcnR5ICgpIHtcbiAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2suc2V0QWxsVG9EaXJ0eSgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvcGVyYXRpb24gd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMgPSB7fV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBbYWRkVG9TdGFjayA9IHRydWVdXG4gICAqIEByZXR1cm5zIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259XG4gICAqL1xuICBjcmVhdGVPcGVyYXRpb24gKGlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSwgYWRkVG9TdGFjayA9IHRydWUpIHtcbiAgICBjb25zdCBPcGVyYXRpb24gPSB0aGlzLl9vcGVyYXRpb25zW2lkZW50aWZpZXJdXG4gICAgaWYgKCFPcGVyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gb3BlcmF0aW9uIHdpdGggaWRlbnRpZmllciBcXGAke2lkZW50aWZpZXJ9XFxgIGZvdW5kLmApXG4gICAgfVxuXG4gICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IE9wZXJhdGlvbih0aGlzLCBvcHRpb25zKVxuICAgIGlmIChhZGRUb1N0YWNrKSB7XG4gICAgICB0aGlzLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBvcGVyYXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBvcGVyYXRpb24gdG8gdGhlIG9wZXJhdGlvbnMgc3RhY2tcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKi9cbiAgYWRkT3BlcmF0aW9uIChvcGVyYXRpb24pIHtcbiAgICB0aGlzLl9vcGVyYXRpb25zU3RhY2sucHVzaChvcGVyYXRpb24pXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIGZyb20gdGhlIG9wZXJhdGlvbnMgc3RhY2tcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICovXG4gIHJlbW92ZU9wZXJhdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLnJlbW92ZShvcGVyYXRpb24pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBESU1FTlNJT05TXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluaXRpYWwgaW1hZ2UgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9XG4gICAqL1xuICBnZXRJbnB1dERpbWVuc2lvbnMgKCkge1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy5faW5wdXRUZXh0dXJlLmdldEZyYW1lKClcbiAgICByZXR1cm4gbmV3IFZlY3RvcjIoZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaW5hbCBkaW1lbnNpb25zIHRoYXQgdGhlIGlucHV0IGltYWdlIHdvdWxkIGhhdmVcbiAgICogYWZ0ZXIgYWxsIGV4aXN0aW5nIG9wZXJhdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0RmluYWxEaW1lbnNpb25zICgpIHtcbiAgICBsZXQgZGltZW5zaW9ucyA9IHRoaXMuZ2V0SW5wdXREaW1lbnNpb25zKClcbiAgICBjb25zdCBvcGVyYXRpb25zU3RhY2sgPSB0aGlzLl9vcGVyYXRpb25zU3RhY2tcblxuICAgIG9wZXJhdGlvbnNTdGFjay5mb3JFYWNoKChvcGVyYXRpb24pID0+IHtcbiAgICAgIGRpbWVuc2lvbnMgPSBvcGVyYXRpb24uZ2V0TmV3RGltZW5zaW9ucyhkaW1lbnNpb25zKVxuICAgIH0pXG5cbiAgICByZXR1cm4gZGltZW5zaW9ucy5yb3VuZCgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzcHJpdGUgZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgKi9cbiAgZ2V0T3V0cHV0RGltZW5zaW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmluYWxEaW1lbnNpb25zKCkuY2xvbmUoKVxuICAgICAgLm11bHRpcGx5KHRoaXMuX3pvb20pXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSVNDXG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgdmVyc2lvbiB1cGRhdGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tGb3JVcGRhdGVzICgpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy52ZXJzaW9uQ2hlY2spIHtcbiAgICAgIHRoaXMuX3ZlcnNpb25DaGVja2VyID0gbmV3IFZlcnNpb25DaGVja2VyKHRoaXMudmVyc2lvbilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlbmRlciB0ZXh0dXJlIGZvciB0aGUgY3VycmVudCByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX1cbiAgICogQFRPRE8gIFRoaXMgZG9lcyBwcm9iYWJseSBub3QgYmVsb25nIGhlcmVcbiAgICovXG4gIGNyZWF0ZVJlbmRlclRleHR1cmUgKCkge1xuICAgIGNvbnN0IHsgcGl4ZWxSYXRpbyB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy5fc3ByaXRlLmdldFRleHR1cmUoKS5nZXRGcmFtZSgpXG4gICAgcmV0dXJuIG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZSh0aGlzLl9yZW5kZXJlciwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCwgcGl4ZWxSYXRpbylcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgcmVuZGVyZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0UmVuZGVyZXIgKCkge1xuICAgIGNvbnN0IHJlbmRlcmVyT3B0aW9ucyA9IHtcbiAgICAgIGNhbnZhczogdGhpcy5fb3B0aW9ucy5jYW52YXMsXG4gICAgICBwaXhlbFJhdGlvOiB0aGlzLl9vcHRpb25zLnBpeGVsUmF0aW8sXG4gICAgICBkZWJ1ZzogdGhpcy5fb3B0aW9ucy5kZWJ1ZyxcbiAgICAgIHRyYW5zcGFyZW50OiB0aGlzLl9vcHRpb25zLnRyYW5zcGFyZW50XG4gICAgfVxuXG4gICAgbGV0IHdpZHRoLCBoZWlnaHRcbiAgICBpZiAodGhpcy5fcmVuZGVyTW9kZSA9PT0gJ2R5bmFtaWMnICYmIHRoaXMuX29wdGlvbnMuY2FudmFzKSB7XG4gICAgICBjb25zdCB7IGNhbnZhcyB9ID0gdGhpcy5fb3B0aW9uc1xuICAgICAgd2lkdGggPSBjYW52YXMud2lkdGhcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ltYWdlKSB7XG4gICAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5nZXRGaW5hbERpbWVuc2lvbnMoKVxuICAgICAgd2lkdGggPSBkaW1lbnNpb25zLnhcbiAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMueVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcHJlZmVycmVkUmVuZGVyZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBjYXNlICd3ZWJnbCc6XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gRW5naW5lLmF1dG9EZXRlY3RSZW5kZXJlcih3aWR0aCwgaGVpZ2h0LCByZW5kZXJlck9wdGlvbnMpXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm9uKCdjb250ZXh0LXJlc3RvcmVkJywgdGhpcy5fb25Db250ZXh0UmVzdG9yZWQpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBFbmdpbmUuQ2FudmFzUmVuZGVyZXIod2lkdGgsIGhlaWdodCwgcmVuZGVyZXJPcHRpb25zKVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5vbignY29udGV4dC1yZXN0b3JlZCcsIHRoaXMuX29uQ29udGV4dFJlc3RvcmVkKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgTG9nLndhcm4oJ1Bob3RvRWRpdG9yU0RLJywgYFBob3RvRWRpdG9yU0RLIEVycm9yOiBSZW5kZXJlciBcXGAke3RoaXMuX3ByZWZlcnJlZFJlbmRlcmVyfVxcYCBub3Qgc3VwcG9ydGVkLiBGYWxsaW5nIGJhY2sgdG8gYXV0b21hdGljYWxseSBkZXRlY3RlZCByZW5kZXJlci5gKVxuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IEVuZ2luZS5hdXRvRGV0ZWN0UmVuZGVyZXIod2lkdGgsIGhlaWdodCwgcmVuZGVyZXJPcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSByZW5kZXJlciB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICovXG4gIHJlc2l6ZVRvIChkaW1lbnNpb25zKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIucmVzaXplVG8oZGltZW5zaW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgYWxsIGN1c3RvbSBhbmQgc2VsZWN0ZWQgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQgKCkge1xuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5jbGVhcigpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFWElGXG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZXhpZiBkYXRhIGFuZCBmaXhlcyB0aGUgb3JpZW50YXRpb24gaWYgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBUT0RPIE1vdmUgdGhpcyBzb21ld2hlcmUgZWxzZVxuICAgKi9cbiAgcGFyc2VFeGlmIChpbWFnZSkge1xuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgeyBzcmMgfSA9IGltYWdlXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IE5vZGVDYW52YXMgPSByZXF1aXJlKCdjYW52YXMnKVxuICAgICAgaWYgKGltYWdlIGluc3RhbmNlb2YgTm9kZUNhbnZhcy5JbWFnZSAmJlxuICAgICAgICAgIGltYWdlLnJhd1NvdXJjZSkge1xuICAgICAgICBzcmMgPSBpbWFnZS5yYXdTb3VyY2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRXhpZi5pc0pQRUcoc3JjKSkge1xuICAgICAgbGV0IGV4aWYgPSBudWxsXG4gICAgICB0cnkge1xuICAgICAgICBleGlmID0gRXhpZi5mcm9tQmFzZTY0U3RyaW5nKHNyYylcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBpZiAoIWV4aWYpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlmXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBFWElGIG9yaWVudGF0aW9uIHRhZyBhbmQgZml4ZXMgaXQgd2l0aCB0aGUgT3JpZW50YXRpb25PcGVyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICogQFRPRE8gTW92ZSB0aGlzIHNvbWV3aGVyZSBlbHNlXG4gICAqL1xuICBfaGFuZGxlRXhpZk9yaWVudGF0aW9uICgpIHtcbiAgICBsZXQgZXhpZlRhZ3MgPSB0aGlzLl9leGlmLmdldFRhZ3MoKVxuXG4gICAgaWYgKGV4aWZUYWdzICYmIGV4aWZUYWdzLk9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCByb3RhdGlvbk5lZWRzQ2hhbmdlID0gZXhpZlRhZ3MuT3JpZW50YXRpb24gIT09IDEgJiZcbiAgICAgICAgZXhpZlRhZ3MuT3JpZW50YXRpb24gIT09IDJcbiAgICAgIGNvbnN0IGZsaXBOZWVkc0NoYW5nZSA9IFsyLCA0LCA1LCA3XS5pbmRleE9mKGV4aWZUYWdzLk9yaWVudGF0aW9uKSAhPT0gLTFcblxuICAgICAgbGV0IG9yaWVudGF0aW9uT3BlcmF0aW9uXG4gICAgICBpZiAocm90YXRpb25OZWVkc0NoYW5nZSB8fCBmbGlwTmVlZHNDaGFuZ2UpIHtcbiAgICAgICAgb3JpZW50YXRpb25PcGVyYXRpb24gPSB0aGlzLmNyZWF0ZU9wZXJhdGlvbignb3JpZW50YXRpb24nKVxuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25OZWVkc0NoYW5nZSkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJvdGF0ZVxuICAgICAgICBsZXQgZGVncmVlcyA9IDBcbiAgICAgICAgc3dpdGNoIChleGlmVGFncy5PcmllbnRhdGlvbikge1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBkZWdyZWVzID0gLTkwXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkZWdyZWVzID0gLTE4MFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgZGVncmVlcyA9IDkwXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZW50YXRpb25PcGVyYXRpb24uc2V0Um90YXRpb24oZGVncmVlcylcbiAgICAgIH1cblxuICAgICAgaWYgKFsyLCA0XS5pbmRleE9mKGV4aWZUYWdzLk9yaWVudGF0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgb3JpZW50YXRpb25PcGVyYXRpb24uc2V0RmxpcEhvcml6b250YWxseSh0cnVlKVxuICAgICAgfVxuXG4gICAgICBpZiAoWzUsIDddLmluZGV4T2YoZXhpZlRhZ3MuT3JpZW50YXRpb24pICE9PSAtMSkge1xuICAgICAgICBvcmllbnRhdGlvbk9wZXJhdGlvbi5zZXRGbGlwVmVydGljYWxseSh0cnVlKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9leGlmLnNldE9yaWVudGF0aW9uKDEpXG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR0VUVEVSUyAvIFNFVFRFUlNcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGltYWdlIGlzIHByb3ZpZGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGhhc0ltYWdlICgpIHtcbiAgICByZXR1cm4gKHRoaXMuX2ltYWdlICE9PSBudWxsICYmIHR5cGVvZiB0aGlzLl9pbWFnZSAhPT0gJ3VuZGVmaW5lZCcpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2VcbiAgICogQHJldHVybiB7SW1hZ2V9XG4gICAqL1xuICBnZXRJbWFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW1hZ2UgYW5kIHBhcnNlcyB0aGUgZXhpZiBkYXRhXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRXhpZn0gW2V4aWYgPSBudWxsXVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gW2RpbWVuc2lvbnNdXG4gICAqL1xuICBzZXRJbWFnZSAoaW1hZ2UsIGV4aWYgPSBudWxsLCBkaW1lbnNpb25zID0gbnVsbCkge1xuICAgIHRoaXMuX29wdGlvbnMuaW1hZ2UgPSBpbWFnZVxuICAgIHRoaXMuX2ltYWdlID0gaW1hZ2VcbiAgICBpZiAoIWV4aWYpIHtcbiAgICAgIHRoaXMuX2V4aWYgPSB0aGlzLnBhcnNlRXhpZihpbWFnZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhpZiA9IGV4aWZcbiAgICB9XG4gICAgaWYgKHRoaXMuX2V4aWYpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUV4aWZPcmllbnRhdGlvbigpXG4gICAgfVxuXG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBuZXcgRW5naW5lLkJhc2VUZXh0dXJlKHRoaXMuX2ltYWdlKVxuICAgIGNvbnN0IGZyYW1lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLl9pbWFnZS53aWR0aCwgdGhpcy5faW1hZ2UuaGVpZ2h0KVxuICAgIGlmIChkaW1lbnNpb25zKSB7XG4gICAgICBmcmFtZS53aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgICAgZnJhbWUuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG4gICAgfVxuXG4gICAgdGhpcy5faW5wdXRUZXh0dXJlID0gbmV3IEVuZ2luZS5UZXh0dXJlKGJhc2VUZXh0dXJlLCBmcmFtZSlcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl9pbnB1dFRleHR1cmUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2FudmFzXG4gICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fVxuICAgKi9cbiAgZ2V0Q2FudmFzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0Q2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqL1xuICBzZXRDYW52YXMgKGNhbnZhcykge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldENhbnZhcyhjYW52YXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3ByaXRlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TcHJpdGV9XG4gICAqL1xuICBnZXRTcHJpdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zcHJpdGVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXJcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkNvbnRhaW5lcn1cbiAgICovXG4gIGdldENvbnRhaW5lciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wZXJhdGlvbiBzdGFja1xuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zU3RhY2t9XG4gICAqL1xuICBnZXRPcGVyYXRpb25zU3RhY2sgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVyYXRpb25zU3RhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGVyYXRpb25zIHN0YWNrXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1N0YWNrfSBvcGVyYXRpb25zU3RhY2tcbiAgICovXG4gIHNldE9wZXJhdGlvbnNTdGFjayAob3BlcmF0aW9uc1N0YWNrKSB7XG4gICAgaWYgKHRoaXMuX29wZXJhdGlvbnNTdGFjaykge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uc1N0YWNrLm9mZihFdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICAgIH1cblxuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjayA9IG9wZXJhdGlvbnNTdGFja1xuICAgIHRoaXMuX29wZXJhdGlvbnNTdGFjay5vbihFdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGF2YWlsYWJsZSBvcGVyYXRpb25zXG4gICAqIEByZXR1cm4ge09wZXJhdGlvbltdfVxuICAgKi9cbiAgZ2V0T3BlcmF0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZXJhdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfVxuICAgKi9cbiAgZ2V0UmVuZGVyZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmluZyBvZmZzZXRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyaW5nIG9mZnNldFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMnxOdW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKi9cbiAgc2V0T2Zmc2V0IChvZmZzZXQsIHkpIHtcbiAgICBpZiAob2Zmc2V0IGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgdGhpcy5fb2Zmc2V0LmNvcHkob2Zmc2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vZmZzZXQuc2V0KG9mZnNldCwgeSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgem9vbSBsZXZlbFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRab29tICgpIHtcbiAgICByZXR1cm4gdGhpcy5fem9vbVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHpvb20gbGV2ZWxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHpvb21cbiAgICovXG4gIHNldFpvb20gKHpvb20pIHtcbiAgICB0aGlzLl96b29tID0gem9vbVxuICAgIHRoaXMuX2NvbnRhaW5lci5zZXRTY2FsZSh0aGlzLl96b29tLCB0aGlzLl96b29tKVxuICAgIHRoaXMuX2NvbnRhaW5lci51cGRhdGVUcmFuc2Zvcm0oKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG91dHB1dCBzcHJpdGUncyBzY2FsZVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRTcHJpdGVTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Nwcml0ZVNjYWxlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3ByaXRlIHNjYWxlIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3ByaXRlU2NhbGVcbiAgICovXG4gIHNldFNwcml0ZVNjYWxlIChzcHJpdGVTY2FsZSkge1xuICAgIHRoaXMuX3Nwcml0ZVNjYWxlID0gc3ByaXRlU2NhbGVcbiAgICB0aGlzLl9zcHJpdGUuc2V0U2NhbGUoc3ByaXRlU2NhbGUpXG4gICAgdGhpcy5fc3ByaXRlLnVwZGF0ZVRyYW5zZm9ybSgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGl4ZWwgcmF0aW9cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0UGl4ZWxSYXRpbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucGl4ZWxSYXRpb1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEV4aWYgaW5zdGFuY2VcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRXhpZn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZ2V0RXhpZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4aWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldE9wdGlvbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5wdXQgdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZX1cbiAgICovXG4gIGdldElucHV0VGV4dHVyZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0VGV4dHVyZVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRElTUE9TQUxcblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhlIFNES1xuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuZGlzcG9zZSgpXG4gICAgaWYgKHRoaXMuX2V4aWYpIHtcbiAgICAgIHRoaXMuX2V4aWYuZGlzcG9zZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBob3RvRWRpdG9yU0RLXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3Nkay5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IExvZyB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29uZmlndXJhYmxlIGZyb20gJy4uLy4uL2xpYi9jb25maWd1cmFibGUnXG5pbXBvcnQgU2hhZGVyIGZyb20gJy4uL3NoYWRlcnMvc2hhZGVyJ1xuaW1wb3J0IFRleHR1cmVTaGFkZXIgZnJvbSAnLi4vc2hhZGVycy90ZXh0dXJlLXNoYWRlcidcblxuLyoqXG4gKiBBIGZpbHRlciBjYW4gYmUgYXR0YWNoZWQgdG8gYSBEaXNwbGF5T2JqZWN0IGFuZCBhZmZlY3RzIHRoZSB3YXkgaXQgaXMgZGlzcGxheWVkLlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5Db25maWd1cmFibGVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgQ29uZmlndXJhYmxlIHtcbiAgLyoqXG4gICAqIEdvZXMgdGhyb3VnaCB0aGUgYXZhaWxhYmxlIG9wdGlvbnMsIHNldHMgX29wdGlvbnMgZGVmYXVsdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaW5pdE9wdGlvbnMgKCkge1xuICAgIHRoaXMuX3NoYWRlcnMgPSBbXVxuICAgIHRoaXMuX2F2YWlsYWJsZVVuaWZvcm1zID0gVGV4dHVyZVNoYWRlci5kZWZhdWx0VW5pZm9ybXNcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gVGV4dHVyZVNoYWRlci5kZWZhdWx0QXR0cmlidXRlc1xuICAgIHRoaXMuX3ZlcnRleFNvdXJjZSA9IFRleHR1cmVTaGFkZXIuZGVmYXVsdFZlcnRleFNvdXJjZVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gVGV4dHVyZVNoYWRlci5kZWZhdWx0RnJhZ21lbnRTb3VyY2VcblxuICAgIHRoaXMuX2luaXRVbmlmb3JtcygpXG4gICAgc3VwZXIuX2luaXRPcHRpb25zKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgdW5pZm9ybXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0VW5pZm9ybXMgKCkge1xuICAgIHRoaXMuX3VuaWZvcm1zID0ge31cbiAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMuX2F2YWlsYWJsZVVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gdGhpcy5fYXZhaWxhYmxlVW5pZm9ybXNbbmFtZV1cbiAgICAgIHRoaXMuX3VuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICB0eXBlOiB1bmlmb3JtLnR5cGUsXG4gICAgICAgIHZhbHVlOiB1bmlmb3JtLmRlZmF1bHQgfHwgbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9wdGlvbnMgYXJlIGFsc28gdHVybmVkIGludG8gdW5pZm9ybXNcbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHRoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICAgIGlmICghb3B0aW9uQ29uZmlnLnVuaWZvcm1UeXBlKSB7XG4gICAgICAgIExvZy50cmFjZSh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBPcHRpb24gXFxgJHtvcHRpb25OYW1lfVxcYCBpcyBtaXNzaW5nIGEgXFxgdW5pZm9ybVR5cGVcXGAhYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuaWZvcm1zW2B1XyR7b3B0aW9uTmFtZX1gXSA9IHtcbiAgICAgICAgICB0eXBlOiBvcHRpb25Db25maWcudW5pZm9ybVR5cGUsXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbkNvbmZpZy5kZWZhdWx0IHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIG9wdGlvbiwgdmFsaWRhdGVzIGl0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtCb29sZWFufSB1cGRhdGUgPSB0cnVlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0T3B0aW9uIChvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlID0gdHJ1ZSkge1xuICAgIHN1cGVyLnNldE9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSwgdXBkYXRlKVxuXG4gICAgbGV0IHVuaWZvcm1WYWx1ZSA9IHZhbHVlXG4gICAgY29uc3Qgb3B0aW9uQ29uZmlnID0gdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdXG5cbiAgICBpZiAoIW9wdGlvbkNvbmZpZy51bmlmb3JtVHlwZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChvcHRpb25Db25maWcudHlwZSkge1xuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICBpZiAob3B0aW9uQ29uZmlnLnVuaWZvcm1UeXBlID09PSAnNGYnKSB7XG4gICAgICAgICAgdW5pZm9ybVZhbHVlID0gdmFsdWUudG9HTENvbG9yKClcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25Db25maWcudW5pZm9ybVR5cGUgPT09ICczZicpIHtcbiAgICAgICAgICB1bmlmb3JtVmFsdWUgPSB2YWx1ZS50b1JHQkdMQ29sb3IoKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd2ZWN0b3IyJzpcbiAgICAgICAgdW5pZm9ybVZhbHVlID0gW3ZhbHVlLngsIHZhbHVlLnldXG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdGhpcy5zZXRVbmlmb3JtKGB1XyR7b3B0aW9uTmFtZX1gLCB1bmlmb3JtVmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gdW5pZm9ybSB0byB0aGUgZ2l2ZW4gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN5bmMgPSBmYWxzZVxuICAgKi9cbiAgc2V0VW5pZm9ybSAobmFtZSwgdmFsdWUsIHN5bmMgPSBmYWxzZSkge1xuICAgIHRoaXMuX3VuaWZvcm1zW25hbWVdLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiB1bmlmb3JtcyB0byB0aGVpciB2YWx1ZXNcbiAgICogQHBhcmFtIHtPYmplY3R9ICB1bmlmb3Jtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN5bmMgPSBmYWxzZVxuICAgKi9cbiAgc2V0VW5pZm9ybXMgKHVuaWZvcm1zLCBzeW5jID0gZmFsc2UpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICB0aGlzLl91bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHVuaWZvcm1zW25hbWVdXG4gICAgICBpZiAoc3luYykge1xuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtKG5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgdW5pZm9ybSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgc3luY1VuaWZvcm0gKG5hbWUpIHtcbiAgICB0aGlzLl9zaGFkZXJzLmZvckVhY2goKHNoYWRlcikgPT4ge1xuICAgICAgc2hhZGVyLnN5bmNVbmlmb3JtKG5hbWUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgYWxsIHVuaWZvcm1zIHdpdGggV2ViR0xcbiAgICovXG4gIHN5bmNVbmlmb3JtcyAoKSB7XG4gICAgdGhpcy5fc2hhZGVycy5mb3JFYWNoKChzaGFkZXIpID0+IHtcbiAgICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhZGVyIGZvciB0aGUgZ2l2ZW4gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TaGFkZXJ9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXRTaGFkZXJGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGxldCBzaGFkZXIgPSB0aGlzLl9zaGFkZXJzW2dsLmlkXVxuXG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHNoYWRlciA9IG5ldyBTaGFkZXIocmVuZGVyZXIsXG4gICAgICAgIHRoaXMuX3ZlcnRleFNvdXJjZSxcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UsXG4gICAgICAgIHRoaXMuX3VuaWZvcm1zLFxuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzXG4gICAgICApXG5cbiAgICAgIHRoaXMuX3NoYWRlcnNbZ2wuaWRdID0gc2hhZGVyXG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYWRlclxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICovXG4gIGFwcGx5IChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgdGhpcy5fYXBwbHlXZWJHTChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIpXG4gICAgfSBlbHNlIGlmIChyZW5kZXJlci5pc09mVHlwZSgnY2FudmFzJykpIHtcbiAgICAgIHRoaXMuX2FwcGx5Q2FudmFzKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhcilcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgV2ViR0xSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlXZWJHTCAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuZ2V0U2hhZGVyRm9yUmVuZGVyZXIocmVuZGVyZXIpXG5cbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQob3V0cHV0VGFyZ2V0KVxuICAgIGlmIChjbGVhcikge1xuICAgICAgb3V0cHV0VGFyZ2V0LmNsZWFyKClcbiAgICB9XG5cbiAgICByZW5kZXJlci5zZXRTaGFkZXIoc2hhZGVyKVxuXG4gICAgY29uc3QgcHJvamVjdGlvbk1hdHJpeCA9IHJlbmRlcmVyLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKS5nZXRQcm9qZWN0aW9uTWF0cml4KCkudG9BcnJheSgpXG4gICAgc2hhZGVyLnNldFVuaWZvcm0oJ3VfcHJvak1hdHJpeCcsIHByb2plY3Rpb25NYXRyaXgpXG4gICAgc2hhZGVyLnN5bmNVbmlmb3JtcygpXG5cbiAgICAvLyBSZW5kZXIhXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMClcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBpbnB1dFRhcmdldC5nZXRUZXh0dXJlKCkpXG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIExvZy53YXJuKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ2BfYXBwbHlDYW52YXNgIGlzIG5vdCBpbXBsZW1lbnRlZC4gSnVzdCBjb3B5aW5nIGltYWdlIGRhdGEgZnJvbSBgaW5wdXRUYXJnZXRgIHRvIGBvdXRwdXRUYXJnZXRgLicpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBGaWx0ZXJcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX3NoYWRlcnMuZm9yRWFjaCgoc2hhZGVyKSA9PiBzaGFkZXIuZGlzcG9zZSgpKVxuICAgIHRoaXMuX3NoYWRlcnMgPSBbXVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvZmlsdGVycy9maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBVdGlscyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udGV4dFBlcmZvcm1hbmNlSG9vayBmcm9tICcuLi8uLi91dGlscy9jb250ZXh0LXBlcmZvcm1hbmNlLWhvb2snXG5pbXBvcnQgQmFzZVJlbmRlcmVyIGZyb20gJy4uL2Jhc2UtcmVuZGVyZXInXG5pbXBvcnQgQ2FudmFzUmVuZGVyVGFyZ2V0IGZyb20gJy4uLy4uL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IENhbnZhc0ZpbHRlck1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlcnMvY2FudmFzLWZpbHRlci1tYW5hZ2VyJ1xuXG4vKipcbiAqIFRoZSByZW5kZXJlciB0aGF0IGlzIHVzZWQgZm9yIENhbnZhczJEIHJlbmRlcmluZ1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbmNsYXNzIENhbnZhc1JlbmRlcmVyIGV4dGVuZHMgQmFzZVJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBDYW52YXNSZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl90eXBlID0gJ2NhbnZhcydcblxuICAgIHRoaXMuc2V0Q2FudmFzKHRoaXMuX29wdGlvbnMuY2FudmFzIHx8IHRoaXMuX2NyZWF0ZUNhbnZhcygpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjYW52YXMgZWxlbWVudFxuICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2FudmFzICgpIHtcbiAgICByZXR1cm4gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgdGhpcyByZW5kZXJlclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNvbnRleHQgKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2NhbnZhc1xuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGVidWcpIHtcbiAgICAgIGN0eCA9IG5ldyBDb250ZXh0UGVyZm9ybWFuY2VIb29rKGN0eClcbiAgICB9XG5cbiAgICB0aGlzLmlkID0gY3R4LmlkID0gQ2FudmFzUmVuZGVyZXIuY29udGV4dElkKytcbiAgICB0aGlzLl9jb250ZXh0ID0gY3R4XG4gICAgY3R4LnJlbmRlcmVyID0gdGhpc1xuXG4gICAgdGhpcy5lbWl0KCdjb250ZXh0JywgY3R4KVxuXG4gICAgcmV0dXJuIGN0eFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jb250ZXh0XG5cbiAgICAvLyBFbmFibGUgaW1hZ2Ugc21vb3RoaW5nIGlmIGF2YWlsYWJsZVxuICAgIGlmICghKCdpbWFnZVNtb290aGluZ0VuYWJsZWQnIGluIGN0eCkpIHtcbiAgICAgIFsnbW96JywgJ3dlYmtpdCcsICdtcyddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKGN0eFtwcm9wXSkge1xuICAgICAgICAgIGN0eFtwcm9wXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0ID0gbmV3IENhbnZhc1JlbmRlclRhcmdldCh0aGlzLl93aWR0aCxcbiAgICAgIHRoaXMuX2hlaWdodCxcbiAgICAgIHRoaXMuX3BpeGVsUmF0aW8sXG4gICAgICB0aGlzLl9jYW52YXMsXG4gICAgICB0aGlzLl9jb250ZXh0KVxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQpXG5cbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyID0gbmV3IENhbnZhc0ZpbHRlck1hbmFnZXIodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICAvLyBTaW5jZSB0aGUgZ2l2ZW4gZGlzcGxheU9iamVjdCBpcyB0aGUgXCJyb290XCIgb2JqZWN0XG4gICAgLy8gcmlnaHQgbm93LCB3ZSBuZWVkIHRvIGdpdmUgaXQgYSBkdW1teSAvIGZha2Ugb2JqZWN0XG4gICAgLy8gYXMgcGFyZW50IHdpdGggdGhlIGRlZmF1bHQgd29ybGQgdHJhbnNmb3JtIGFuZCBhbHBoYVxuICAgIGNvbnN0IG9yaWdpbmFsUGFyZW50ID0gZGlzcGxheU9iamVjdC5nZXRQYXJlbnQoKVxuICAgIGRpc3BsYXlPYmplY3Quc2V0UGFyZW50KHRoaXMuX2Zha2VPYmplY3QpXG5cbiAgICAvLyBVcGRhdGUgdHJhbnNmb3JtcyBhbmQgcmVuZGVyIHRoaXMgb2JqZWN0XG4gICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKVxuXG4gICAgLy8gUmVzZXQgcGFyZW50XG4gICAgZGlzcGxheU9iamVjdC5zZXRQYXJlbnQob3JpZ2luYWxQYXJlbnQpXG5cbiAgICAvLyBSZXNldCB0cmFuc2Zvcm1cbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG5cbiAgICAvLyBSZXNldCBhbHBoYVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDFcblxuICAgIC8vIENsZWFyIHRoZSB2aWV3XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9jYW52YXNcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgaWYgKHRoaXMuX2NsZWFyQ29sb3IuYSAhPT0gMCkge1xuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NsZWFyQ29sb3IudG9SR0JBKClcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLl9yZW5kZXJUYXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGFyZ2V0fSByZW5kZXJUYXJnZXRcbiAgICovXG4gIHJlbmRlckRpc3BsYXlPYmplY3QgKGRpc3BsYXlPYmplY3QsIHJlbmRlclRhcmdldCkge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVuZGVyVGFyZ2V0ID0gdGhpcy5fcmVuZGVyVGFyZ2V0XG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5zZXRGaWx0ZXJTdGFjayhyZW5kZXJUYXJnZXQuZ2V0RmlsdGVyU3RhY2soKSlcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgZGlzcGxheU9iamVjdC5yZW5kZXJDYW52YXModGhpcylcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChvcmlnaW5hbFJlbmRlclRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH1cbiAgICovXG4gIGdldEN1cnJlbnRSZW5kZXJUYXJnZXQgKCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmVuZGVyIHRhcmdldFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IHJlbmRlclRhcmdldFxuICAgKi9cbiAgc2V0UmVuZGVyVGFyZ2V0IChyZW5kZXJUYXJnZXQpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAqL1xuICBnZXRDb250ZXh0ICgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldC5nZXRDb250ZXh0KCkgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFJlbmRlcmVyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyLmRpc3Bvc2UoKVxuICB9XG59XG5cbkNhbnZhc1JlbmRlcmVyLmNvbnRleHRJZCA9IDBcbkNhbnZhc1JlbmRlcmVyLnR5cGUgPSAnQ2FudmFzMkQnXG5cbmV4cG9ydCBkZWZhdWx0IENhbnZhc1JlbmRlcmVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS9yZW5kZXJlcnMvY2FudmFzL2NhbnZhcy1yZW5kZXJlci5qc1xuICoqLyIsIi8qIGVzbGludCBjb25zdHJ1Y3Rvci1zdXBlcjogMCAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEdsb2JhbHMgZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBPYmplY3RSZW5kZXJlciBmcm9tICcuL29iamVjdC1yZW5kZXJlcidcblxuLyoqXG4gKiBUaGUgT2JqZWN0UmVuZGVyZXIgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIFNwcml0ZSBpbnN0YW5jZXNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRW5naW5lLk9iamVjdFJlbmRlcmVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRW5naW5lXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBTcHJpdGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTcHJpdGVSZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX21heEJhdGNoU2l6ZSA9IEdsb2JhbHMuQkFUQ0hfU0laRVxuICAgIHRoaXMuX3ZlcnRpY2VzID0gbmV3IEFycmF5QnVmZmVyKEdsb2JhbHMuQkFUQ0hfU0laRSAqIDQgKiBHbG9iYWxzLlZFUlRFWF9CWVRFX1NJWkUpXG4gICAgdGhpcy5fcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl92ZXJ0aWNlcylcbiAgICB0aGlzLl9jb2xvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fdmVydGljZXMpXG4gICAgdGhpcy5faW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShHbG9iYWxzLkJBVENIX1NJWkUgKiA2KVxuXG4gICAgLy8gRmlsbCB2ZXJ0ZXggcG9zaXRpb24gaW5kaWNlc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IEdsb2JhbHMuQkFUQ0hfU0laRSAqIDY7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAwXSA9IGogKyAwXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAxXSA9IGogKyAxXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAyXSA9IGogKyAyXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyAzXSA9IGogKyAwXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyA0XSA9IGogKyAyXG4gICAgICB0aGlzLl9pbmRpY2VzW2kgKyA1XSA9IGogKyAzXG4gICAgfVxuXG4gICAgdGhpcy5fc2hhZGVycyA9IFtdXG4gICAgdGhpcy5fc3ByaXRlcyA9IFtdXG5cbiAgICB0aGlzLl9jdXJyZW50QmF0Y2hTaXplID0gMFxuICAgIHRoaXMuX2N1cnJlbnRCYXNlVGV4dHVyZSA9IG51bGxcblxuICAgIHRoaXMuX29uQ29udGV4dENoYW5nZSgpXG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gc3ByaXRlIHRvIHRoZSBiYXRjaFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfSBzcHJpdGVcbiAgICovXG4gIHJlbmRlciAoc3ByaXRlKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHNwcml0ZS5nZXRUZXh0dXJlKClcbiAgICBjb25zdCB0ZXh0dXJlRnJhbWUgPSB0ZXh0dXJlLmdldEZyYW1lKClcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKVxuXG4gICAgLy8gSGFzIHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgYmVlbiByZWFjaGVkPyBGbHVzaCFcbiAgICBpZiAodGhpcy5fY3VycmVudEJhdGNoU2l6ZSA+PSB0aGlzLl9tYXhCYXRjaFNpemUpIHtcbiAgICAgIHRoaXMuZmx1c2goKVxuICAgICAgdGhpcy5fY3VycmVudEJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmVcbiAgICB9XG5cbiAgICAvLyBObyB1cGRhdGVkIFVWcyA9PiBObyByZW5kZXJpbmdcbiAgICBjb25zdCB1dnMgPSB0ZXh0dXJlLmdldFVWcygpXG4gICAgaWYgKCF1dnMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpbGwgcG9zaXRpb25zIGFycmF5XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9jdXJyZW50QmF0Y2hTaXplICogR2xvYmFscy5WRVJURVhfQllURV9TSVpFXG4gICAgdGhpcy5fYWRkVmVydGV4Q29vcmRpbmF0ZXMoc3ByaXRlLCBpbmRleCwgdGV4dHVyZUZyYW1lKVxuICAgIHRoaXMuX2FkZFRleHR1cmVVVnMoc3ByaXRlLCBpbmRleCwgdXZzKVxuICAgIHRoaXMuX2FkZENvbG9ycyhzcHJpdGUsIGluZGV4KVxuXG4gICAgLy8gQWRkIHRoZSBzcHJpdGUgdG8gdGhlIGxpc3Qgb2Ygc3ByaXRlc1xuICAgIHRoaXMuX3Nwcml0ZXNbdGhpcy5fY3VycmVudEJhdGNoU2l6ZV0gPSBzcHJpdGVcbiAgICB0aGlzLl9jdXJyZW50QmF0Y2hTaXplKytcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjb2xvciB0byB0aGUgcG9zaXRpb25zIGFycmF5IGZvciB0aGUgZ2l2ZW4gc3ByaXRlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNwcml0ZX0gc3ByaXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZENvbG9ycyAoc3ByaXRlLCBpbmRleCkge1xuICAgIGNvbnN0IGNvbG9ycyA9IHRoaXMuX2NvbG9yc1xuICAgIGNvbnN0IHRpbnQgPSBzcHJpdGUuZ2V0VGludCgpXG4gICAgY29uc3QgY29sb3IgPSAodGludCA+PiAxNikgKyAodGludCAmIDB4ZmYwMCkgKyAoKHRpbnQgJiAweGZmKSA8PCAxNikgKyAoc3ByaXRlLmdldFdvcmxkQWxwaGEoKSAqIDI1NSA8PCAyNClcbiAgICBjb2xvcnNbaW5kZXggKyA0XSA9XG4gICAgICBjb2xvcnNbaW5kZXggKyA5XSA9XG4gICAgICBjb2xvcnNbaW5kZXggKyAxNF0gPVxuICAgICAgY29sb3JzW2luZGV4ICsgMTldID0gY29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB0ZXh0dXJlIFVWIGNvb3JkaW5hdGVzIHRvIHRoZSBwb3NpdGlvbnMgYXJyYXkgZm9yIHRoZSBnaXZlbiBzcHJpdGVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuU3ByaXRlfSBzcHJpdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmVVVnN9IHV2c1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FkZFRleHR1cmVVVnMgKHNwcml0ZSwgaW5kZXgsIHV2cykge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuX3Bvc2l0aW9uc1xuXG4gICAgLy8gQWRkIFVWc1xuICAgIGxldCB1dkNvb3JkcyA9IHV2cy5nZXRVVnNBdCgwKVxuICAgIHBvc2l0aW9uc1tpbmRleCArIDJdID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDNdID0gdXZDb29yZHMueVxuXG4gICAgdXZDb29yZHMgPSB1dnMuZ2V0VVZzQXQoMSlcbiAgICBwb3NpdGlvbnNbaW5kZXggKyA3XSA9IHV2Q29vcmRzLnhcbiAgICBwb3NpdGlvbnNbaW5kZXggKyA4XSA9IHV2Q29vcmRzLnlcblxuICAgIHV2Q29vcmRzID0gdXZzLmdldFVWc0F0KDIpXG4gICAgcG9zaXRpb25zW2luZGV4ICsgMTJdID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDEzXSA9IHV2Q29vcmRzLnlcblxuICAgIHV2Q29vcmRzID0gdXZzLmdldFVWc0F0KDMpXG4gICAgcG9zaXRpb25zW2luZGV4ICsgMTddID0gdXZDb29yZHMueFxuICAgIHBvc2l0aW9uc1tpbmRleCArIDE4XSA9IHV2Q29vcmRzLnlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSB2ZXJ0ZXggY29vcmRpbmF0ZXMgdG8gdGhlIHBvc2l0aW9ucyBhcnJheSBmb3IgdGhlIGdpdmVuXG4gICAqIHNwcml0ZSBhbmQgdGV4dHVyZSBmcmFtZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX0gdGV4dHVyZUZyYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYWRkVmVydGV4Q29vcmRpbmF0ZXMgKHNwcml0ZSwgaW5kZXgsIHRleHR1cmVGcmFtZSkge1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuX3Bvc2l0aW9uc1xuICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLmdldFdvcmxkVHJhbnNmb3JtKClcblxuICAgIC8vIFRyYW5zZm9ybSBzcHJpdGUgY29vcmRzIHdpdGggYW5jaG9yIGluIG1pbmRcbiAgICBjb25zdCBhbmNob3IgPSBzcHJpdGUuZ2V0QW5jaG9yKClcbiAgICBjb25zdCByZWN0UG9zaXRpb25zID0gd29ybGRUcmFuc2Zvcm0ucmVjdGFuZ2xlVG9Db29yZGluYXRlcyh0ZXh0dXJlRnJhbWUsIGFuY2hvcilcblxuICAgIGNvbnN0IHN0cmlkZSA9IDVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgcG9zaXRpb25zW2luZGV4ICsgaSAqIHN0cmlkZV0gPSByZWN0UG9zaXRpb25zW2ldLnhcbiAgICAgIHBvc2l0aW9uc1tpbmRleCArIGkgKiBzdHJpZGUgKyAxXSA9IHJlY3RQb3NpdGlvbnNbaV0ueVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJpbmcgY29udGV4dCBjaGFuZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25Db250ZXh0Q2hhbmdlICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgdGhpcy5fc2hhZGVyID0gdGhpcy5fcmVuZGVyZXIuc2hhZGVycy5kZWZhdWx0XG5cbiAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKVxuICAgIHRoaXMuX2luZGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGV4QnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2luZGljZXMsIGdsLlNUQVRJQ19EUkFXKVxuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRleEJ1ZmZlcilcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IHJlbmRlcmVyIGlzIGFjdGl2YXRlZFxuICAgKi9cbiAgc3RhcnQgKCkge1xuICAgIHRoaXMuX3NoYWRlci5zZXR1cEJ1ZmZlcnModGhpcy5fdmVydGV4QnVmZmVyLCB0aGlzLl9pbmRleEJ1ZmZlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBxdWV1ZWQgc3ByaXRlcyBpbiBiYXRjaGVzLCBldmVyeSB0aW1lIHRoZSBiYXNlIHRleHR1cmUgaGFzIGNoYW5nZWQsXG4gICAqIGl0IGZsdXNoZXMgdGhlIGN1cnJlbnQgYmF0Y2ggdG8gdGhlIGdyYXBoaWNzIGNhcmRcbiAgICovXG4gIGZsdXNoICgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyXG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcblxuICAgIGlmICh0aGlzLl9jdXJyZW50QmF0Y2hTaXplID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY3VycmVudEJhdGNoU2l6ZSA+IEdsb2JhbHMuQkFUQ0hfU0laRSAqIDAuNSkge1xuICAgICAgLy8gVXBsb2FkIHdob2xlIEFycmF5QnVmZmVyXG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5fdmVydGljZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgdXBsb2FkIHN1YiBhcnJheVxuICAgICAgY29uc3Qgc3ViQXJyYXkgPSB0aGlzLl9wb3NpdGlvbnMuc3ViYXJyYXkoMCwgdGhpcy5fY3VycmVudEJhdGNoU2l6ZSAqIEdsb2JhbHMuVkVSVEVYX0JZVEVfU0laRSlcbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBzdWJBcnJheSlcbiAgICB9XG5cbiAgICAvLyBJbml0IHZhcmlhYmxlc1xuICAgIGxldCBjdXJyZW50QmF0Y2hTaXplID0gMFxuICAgIGxldCBjdXJyZW50QmFzZVRleHR1cmUgPSBudWxsXG4gICAgbGV0IG5leHRCYXNlVGV4dHVyZSA9IG51bGxcbiAgICBsZXQgY3VycmVudFNoYWRlciA9IG51bGxcbiAgICBsZXQgbmV4dFNoYWRlciA9IG51bGxcbiAgICBsZXQgc2hhZGVyQ2hhbmdlZCA9IGZhbHNlXG4gICAgbGV0IHRleHR1cmVDaGFuZ2VkID0gZmFsc2VcbiAgICBsZXQgc3ByaXRlID0gbnVsbFxuICAgIGxldCBiYXRjaFN0YXJ0SW5kZXggPSAwXG5cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IHRoaXMuX2N1cnJlbnRCYXRjaFNpemU7IGkgPCBqOyBpKyspIHtcbiAgICAgIHNwcml0ZSA9IHRoaXMuX3Nwcml0ZXNbaV1cblxuICAgICAgbmV4dEJhc2VUZXh0dXJlID0gc3ByaXRlLmdldFRleHR1cmUoKS5nZXRCYXNlVGV4dHVyZSgpXG4gICAgICBuZXh0U2hhZGVyID0gc3ByaXRlLmdldFNoYWRlcigpIHx8IHRoaXMuX3NoYWRlclxuICAgICAgc2hhZGVyQ2hhbmdlZCA9IGN1cnJlbnRTaGFkZXIgIT09IG5leHRTaGFkZXJcbiAgICAgIHRleHR1cmVDaGFuZ2VkID0gY3VycmVudEJhc2VUZXh0dXJlICE9PSBuZXh0QmFzZVRleHR1cmVcblxuICAgICAgaWYgKHRleHR1cmVDaGFuZ2VkIHx8IHNoYWRlckNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQmF0Y2goY3VycmVudEJhc2VUZXh0dXJlLCBjdXJyZW50QmF0Y2hTaXplLCBiYXRjaFN0YXJ0SW5kZXgpXG5cbiAgICAgICAgYmF0Y2hTdGFydEluZGV4ID0gaVxuICAgICAgICBjdXJyZW50QmF0Y2hTaXplID0gMFxuICAgICAgICBjdXJyZW50QmFzZVRleHR1cmUgPSBuZXh0QmFzZVRleHR1cmVcblxuICAgICAgICAvLyBTaGFkZXIgaGFzIGNoYW5nZWQsIHNldCBpdFxuICAgICAgICBpZiAoc2hhZGVyQ2hhbmdlZCkge1xuICAgICAgICAgIGN1cnJlbnRTaGFkZXIgPSBuZXh0U2hhZGVyXG4gICAgICAgICAgcmVuZGVyZXIuc2V0U2hhZGVyKGN1cnJlbnRTaGFkZXIpXG5cbiAgICAgICAgICBjb25zdCByZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KClcbiAgICAgICAgICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gcmVuZGVyVGFyZ2V0LmdldFByb2plY3Rpb25NYXRyaXgoKS50b0FycmF5KClcbiAgICAgICAgICBjdXJyZW50U2hhZGVyLnNldFVuaWZvcm0oJ3VfcHJvak1hdHJpeCcsIHByb2plY3Rpb25NYXRyaXgpXG4gICAgICAgICAgY3VycmVudFNoYWRlci5zeW5jVW5pZm9ybXMoKVxuXG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50QmF0Y2hTaXplKytcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJCYXRjaChjdXJyZW50QmFzZVRleHR1cmUsIGN1cnJlbnRCYXRjaFNpemUsIGJhdGNoU3RhcnRJbmRleClcblxuICAgIC8vIFJlc2V0IHRoZSBiYXRjaFxuICAgIHRoaXMuX2N1cnJlbnRCYXRjaFNpemUgPSAwXG4gICAgdGhpcy5fc3ByaXRlcyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY3VycmVudCBiYXRjaFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlXG4gICAqIEBwYXJhbSAge051bWJlcn0gYmF0Y2hTaXplXG4gICAqIEBwYXJhbSAge051bWJlcn0gYmF0Y2hTdGFydEluZGV4XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyQmF0Y2ggKGJhc2VUZXh0dXJlLCBiYXRjaFNpemUsIGJhdGNoU3RhcnRJbmRleCkge1xuICAgIGlmIChiYXRjaFNpemUgPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJcbiAgICBjb25zdCBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgbGV0IGdsVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmdldEdMVGV4dHVyZUZvcklkKGdsLmlkKVxuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICBnbFRleHR1cmUgPSByZW5kZXJlci5nZXRPckNyZWF0ZUdMVGV4dHVyZShiYXNlVGV4dHVyZSlcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVRleHR1cmUoYmFzZVRleHR1cmUpXG4gICAgfVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBiYXNlVGV4dHVyZS5nZXRHTFVuaXQoKSlcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpXG5cbiAgICBjb25zdCB2ZXJ0aWNlc0NvdW50ID0gYmF0Y2hTaXplICogNlxuICAgIGNvbnN0IHZlcnRleE9mZnNldCA9IGJhdGNoU3RhcnRJbmRleCAqIDYgKiAyXG4gICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdmVydGljZXNDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIHZlcnRleE9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIE9iamVjdFJlbmRlcmVyXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyXG4gICAgY29uc3QgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KClcblxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKVxuXG4gICAgdGhpcy5fdmVydGljZXMgPSBudWxsXG4gICAgdGhpcy5fcG9zaXRpb25zID0gbnVsbFxuICAgIHRoaXMuX2NvbG9ycyA9IG51bGxcbiAgICB0aGlzLl9pbmRpY2VzID0gbnVsbFxuXG4gICAgc3VwZXIuZGlzcG9zZSgpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlUmVuZGVyZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL3JlbmRlcmVycy93ZWJnbC9vYmplY3QtcmVuZGVyZXJzL3Nwcml0ZS1yZW5kZXJlci5qc1xuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgTG9nLCBVdGlscyB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgQmFzZVJlbmRlcmVyIGZyb20gJy4uL2Jhc2UtcmVuZGVyZXInXG5pbXBvcnQgV2ViR0xSZW5kZXJUYXJnZXQgZnJvbSAnLi4vLi4vdXRpbHMvd2ViZ2wtcmVuZGVyLXRhcmdldCdcbmltcG9ydCBPYmplY3RSZW5kZXJlciBmcm9tICcuL29iamVjdC1yZW5kZXJlcnMvb2JqZWN0LXJlbmRlcmVyJ1xuaW1wb3J0IFNwcml0ZVJlbmRlcmVyIGZyb20gJy4vb2JqZWN0LXJlbmRlcmVycy9zcHJpdGUtcmVuZGVyZXInXG5pbXBvcnQgVGV4dHVyZVNoYWRlciBmcm9tICcuLi8uLi9zaGFkZXJzL3RleHR1cmUtc2hhZGVyJ1xuaW1wb3J0IERpc3BsYXlPYmplY3QgZnJvbSAnLi4vLi4vZGlzcGxheS9kaXNwbGF5LW9iamVjdCdcbmltcG9ydCBXZWJHTEZpbHRlck1hbmFnZXIgZnJvbSAnLi4vLi4vbWFuYWdlcnMvd2ViZ2wtZmlsdGVyLW1hbmFnZXInXG5pbXBvcnQgQ29udGV4dFBlcmZvcm1hbmNlSG9vayBmcm9tICcuLi8uLi91dGlscy9jb250ZXh0LXBlcmZvcm1hbmNlLWhvb2snXG5pbXBvcnQgUGl4ZWxBcnJheUltYWdlIGZyb20gJy4uLy4uL3V0aWxzL3BpeGVsLWFycmF5LWltYWdlJ1xuXG4vLyBGb3Igc2VydmVyLXNpZGUgZW52aXJvbm1lbnRzXG5pbXBvcnQgQ2FudmFzIGZyb20gJ2NhbnZhcydcbmNvbnN0IE5vZGVDYW52YXNJbWFnZSA9IHR5cGVvZiBDYW52YXMgIT09ICd1bmRlZmluZWQnID8gQ2FudmFzLkltYWdlIDogdW5kZWZpbmVkXG5cbi8qKlxuICogVGhlIHJlbmRlcmVyIHRoYXQgaXMgdXNlZCBmb3IgV2ViR0wgcmVuZGVyaW5nXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlUmVuZGVyZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFdlYkdMUmVuZGVyZXIgZXh0ZW5kcyBCYXNlUmVuZGVyZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFdlYkdMUmVuZGVyZXJcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl90eXBlID0gJ3dlYmdsJ1xuXG4gICAgdGhpcy5fdGV4dHVyZXMgPSBbXVxuICAgIHRoaXMuX2Zha2VPYmplY3QgPSBuZXcgRGlzcGxheU9iamVjdCgpXG4gICAgdGhpcy5fb25Db250ZXh0TG9zdCA9IHRoaXMuX29uQ29udGV4dExvc3QuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uQ29udGV4dFJlc3RvcmVkID0gdGhpcy5fb25Db250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5zZXRDYW52YXModGhpcy5fb3B0aW9ucy5jYW52YXMgfHwgVXRpbHMuY3JlYXRlQ2FudmFzKCkpXG5cbiAgICB0aGlzLnNoYWRlcnMgPSB0aGlzLl9pbml0U2hhZGVycygpXG4gICAgdGhpcy5yZW5kZXJlcnMgPSB0aGlzLl9pbml0UmVuZGVyZXJzKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENPTlRFWFQgTE9TU1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBXZWJHTCBjb250ZXh0IGhhcyBiZWVuIGxvc3RcbiAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNvbnRleHRMb3N0IChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgTG9nLndhcm4odGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnV2ViR0wgY29udGV4dCBoYXMgYmVlbiBsb3N0IC0gdHJ5aW5nIHRvIHJlc3RvcmUuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBXZWJHTCBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkLiBDbGVhbnMgdXAgYW5kIHJlc2V0cyBldmVyeXRoaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ29udGV4dFJlc3RvcmVkICgpIHtcbiAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsICdXZWJHTCBjb250ZXh0IGhhcyBiZWVuIHJlc3RvcmVkLiBDbGVhcmluZyBhbGwgdGV4dHVyZXMuJylcblxuICAgIHRoaXMuX3RleHR1cmVzLmZvckVhY2goKHRleHR1cmUpID0+IHtcbiAgICAgIHRleHR1cmUuZGlzcG9zZUdMVGV4dHVyZXModGhpcylcbiAgICB9KVxuXG4gICAgdGhpcy5fY3JlYXRlQ29udGV4dCgpXG4gICAgdGhpcy5fc2V0dXBDb250ZXh0KClcbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQtcmVzdG9yZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGJlZm9yZSB0aGUgY29udGV4dCBoYXMgYmVlbiBzZXQgdXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkJlZm9yZUNvbnRleHQgKCkge1xuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIgPSBuZXcgV2ViR0xGaWx0ZXJNYW5hZ2VyKHRoaXMpXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gc2hhZGVyIHRvIGFjdGl2ZVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TaGFkZXJ9IHNoYWRlclxuICAgKi9cbiAgc2V0U2hhZGVyIChzaGFkZXIpIHtcbiAgICB0aGlzLl9jdXJyZW50U2hhZGVyID0gc2hhZGVyXG4gICAgdGhpcy5fY29udGV4dC51c2VQcm9ncmFtKHNoYWRlci5nZXRQcm9ncmFtKCkpXG4gICAgdGhpcy5fc2V0QXR0cmlidXRlc0ZvclNoYWRlcihzaGFkZXIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FudmFzIHRvIHRoZSBnaXZlbiBvbmVcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gICAqL1xuICBzZXRDYW52YXMgKGNhbnZhcykge1xuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5fb25Db250ZXh0TG9zdClcbiAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuX29uQ29udGV4dFJlc3RvcmVkKVxuICAgIH1cblxuICAgIGlmIChjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcikgeyAvLyBub2RlLWNhbnZhcyBkb2Vzbid0IGhhdmUgZXZlbnRzXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX29uQ29udGV4dExvc3QpXG4gICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLl9vbkNvbnRleHRSZXN0b3JlZClcbiAgICB9XG5cbiAgICBzdXBlci5zZXRDYW52YXMoY2FudmFzKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwbG9hZHMgdGhlIGdpdmVuIHNoYWRlcidzIGF0dHJpYnV0ZXMgdG8gdGhlIEdQVVxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TaGFkZXJ9IHNoYWRlclxuICAgKi9cbiAgX3NldEF0dHJpYnV0ZXNGb3JTaGFkZXIgKHNoYWRlcikge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dFxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBzaGFkZXIuZ2V0QXR0cmlidXRlcygpXG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb25zID0gc2hhZGVyLmdldEF0dHJpYnV0ZUxvY2F0aW9ucygpXG5cbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHJpYnV0ZU5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxvY2F0aW9uID0gYXR0cmlidXRlTG9jYXRpb25zW2F0dHJpYnV0ZU5hbWVdXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyaWJ1dGVMb2NhdGlvbilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBkZWZhdWx0IHNoYWRlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRTaGFkZXJzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVmYXVsdDogbmV3IFRleHR1cmVTaGFkZXIodGhpcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGF2YWlsYWJsZSBvYmplY3QgcmVuZGVyZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0UmVuZGVyZXJzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3ByaXRlOiBuZXcgU3ByaXRlUmVuZGVyZXIodGhpcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoaXMgcmVuZGVyZXJcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDb250ZXh0ICgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jYW52YXNcbiAgICBsZXQgZ2wgPSBudWxsXG5cbiAgICAvLyBJZiBub2RlLWdsIGlzIGF2YWlsYWJsZSwgdXNlIGl0IGZvciBjb250ZXh0IGNyZWF0aW9uLiBUaGlzIGFsbG93cyB1c1xuICAgIC8vIHRvIHJlbmRlciBpbWFnZXMgb24gdGhlIHNlcnZlci1zaWRlIHdpdGggaGFyZHdhcmUgYWNjZWxlcmF0ZWQgZ3JhcGhpY3NcbiAgICBsZXQgY3JlYXRlQ29udGV4dCA9IHJlcXVpcmUoJ2dsJylcbiAgICBpZiAoY3JlYXRlQ29udGV4dCkge1xuICAgICAgZ2wgPSBjcmVhdGVDb250ZXh0KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpXG4gICAgfVxuXG4gICAgLy8gSG9vayB1cCBXZWJHTERlYnVnVXRpbHMgaWYgcHJlc2VudFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzICYmIHRoaXMuX29wdGlvbnMuZGVidWcpIHtcbiAgICAgIGNvbnN0IGxvZ0dMID0gKGZ1bmN0aW9uTmFtZSwgYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnbC4nICsgZnVuY3Rpb25OYW1lICsgJygnICtcbiAgICAgICAgICB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzLmdsRnVuY3Rpb25BcmdzVG9TdHJpbmcoZnVuY3Rpb25OYW1lLCBhcmdzKSArICcpJylcbiAgICAgIH1cbiAgICAgIGdsID0gd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlRGVidWdDb250ZXh0KGdsLCBudWxsLCBsb2dHTClcbiAgICB9XG5cbiAgICAvLyBIb29rIHVwIENvbnRleHRQZXJmb3JtYW5jZUhvb2sgaWYgZGVidWcgaXMgZW5hYmxlZFxuICAgIGlmICh0aGlzLl9vcHRpb25zLmRlYnVnKSB7XG4gICAgICBnbCA9IG5ldyBDb250ZXh0UGVyZm9ybWFuY2VIb29rKGdsKVxuICAgIH1cblxuICAgIHRoaXMuaWQgPSBnbC5pZCA9IFdlYkdMUmVuZGVyZXIuY29udGV4dElkKytcbiAgICB0aGlzLl9jb250ZXh0ID0gZ2xcbiAgICBnbC5yZW5kZXJlciA9IHRoaXNcblxuICAgIHRoaXMuX21heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG5cbiAgICB0aGlzLmVtaXQoJ2NvbnRleHQnLCBnbClcblxuICAgIHJldHVybiBnbFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGlzIHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBDb250ZXh0ICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVClcbiAgICBnbC5kaXNhYmxlKGdsLkNVTExfRkFDRSlcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpXG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSlcblxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQodGhpcyxcbiAgICAgIHRoaXMuX3dpZHRoLFxuICAgICAgdGhpcy5faGVpZ2h0LFxuICAgICAgdGhpcy5fcGl4ZWxSYXRpbyxcbiAgICAgIHRydWUpXG4gICAgdGhpcy5zZXRSZW5kZXJUYXJnZXQodGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemVzIHRoZSBjb250ZXh0IGFuZCB2aWV3IHRvIHRoZSBnaXZlbiBzaXplXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gZGltZW5zaW9uc1xuICAgKi9cbiAgcmVzaXplVG8gKGRpbWVuc2lvbnMpIHtcbiAgICBzdXBlci5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgIGlmICh0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0LnJlc2l6ZVRvKGRpbWVuc2lvbnMpXG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmUoJ2dsJykpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQucmVzaXplKGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHJlbmRlciB0YXJnZXQgdG8gdGhlIHBhc3NlZCBvbmUgYW5kIGFjdGl2YXRlc1xuICAgKiBpdCBmb3IgcmVuZGVyaW5nXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0XG4gICAqL1xuICBzZXRSZW5kZXJUYXJnZXQgKHJlbmRlclRhcmdldCkge1xuICAgIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXRcbiAgICB0aGlzLl9jdXJyZW50UmVuZGVyVGFyZ2V0LmFjdGl2YXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IG9iamVjdCByZW5kZXJlciB0byB0aGUgZ2l2ZW4gb25lXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLk9iamVjdFJlbmRlcmVyfSBvYmplY3RSZW5kZXJlclxuICAgKi9cbiAgc2V0T2JqZWN0UmVuZGVyZXIgKG9iamVjdFJlbmRlcmVyKSB7XG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLnN0b3AoKVxuICAgIHRoaXMuX2N1cnJlbnRPYmplY3RSZW5kZXJlciA9IG9iamVjdFJlbmRlcmVyXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLnN0YXJ0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCh0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQuY2xlYXIodGhpcy5fY2xlYXJDb2xvcilcblxuICAgIC8vIFNpbmNlIHRoZSBnaXZlbiBkaXNwbGF5T2JqZWN0IGlzIHRoZSBcInJvb3RcIiBvYmplY3RcbiAgICAvLyByaWdodCBub3csIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIGR1bW15IC8gZmFrZSBvYmplY3RcbiAgICAvLyBhcyBwYXJlbnQgd2l0aCB0aGUgZGVmYXVsdCB3b3JsZCB0cmFuc2Zvcm0gYW5kIGFscGhhXG4gICAgY29uc3Qgb3JpZ2luYWxQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LmdldFBhcmVudCgpXG4gICAgZGlzcGxheU9iamVjdC5zZXRQYXJlbnQodGhpcy5fZmFrZU9iamVjdClcblxuICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm1zIGFuZCByZW5kZXIgdGhpcyBvYmplY3RcbiAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpXG5cbiAgICAvLyBSZXNldCBwYXJlbnRcbiAgICBkaXNwbGF5T2JqZWN0LnNldFBhcmVudChvcmlnaW5hbFBhcmVudClcblxuICAgIHRoaXMucmVuZGVyRGlzcGxheU9iamVjdChkaXNwbGF5T2JqZWN0LCB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIERpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3RcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRhcmdldH0gcmVuZGVyVGFyZ2V0XG4gICAqL1xuICByZW5kZXJEaXNwbGF5T2JqZWN0IChkaXNwbGF5T2JqZWN0LCByZW5kZXJUYXJnZXQpIHtcbiAgICB0aGlzLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpXG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5zZXRGaWx0ZXJTdGFjayhyZW5kZXJUYXJnZXQuZ2V0RmlsdGVyU3RhY2soKSlcbiAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcldlYkdMKHRoaXMpXG4gICAgdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyLmZsdXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGNvbnRleHRcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGdsLmNsZWFyQ29sb3IuYXBwbHkoZ2wsIHRoaXMuX2NsZWFyQ29sb3IudG9HTENvbG9yKCkpXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuZC9vciBjcmVhdGVzIGEgV2ViR0xUZXh0dXJlIGZvciB0aGUgZ2l2ZW4gQmFzZVRleHR1cmUgb2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5CYXNlVGV4dHVyZX0gdGV4dHVyZVxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuV2ViR0xUZXh0dXJlfVxuICAgKi9cbiAgZ2V0T3JDcmVhdGVHTFRleHR1cmUgKHRleHR1cmUpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX2NvbnRleHRcblxuICAgIGxldCBnbFRleHR1cmUgPSB0ZXh0dXJlLmdldEdMVGV4dHVyZUZvcklkKGdsLmlkKVxuICAgIGlmICghZ2xUZXh0dXJlKSB7XG4gICAgICBnbFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgICAgIHRleHR1cmUuc2V0R0xUZXh0dXJlRm9ySWQoZ2xUZXh0dXJlLCBnbC5pZClcblxuICAgICAgLy8gSG9sZCByZWZlcmVuY2UgdG8gdGV4dHVyZSBmb3IgZWFzaWVyIGRpc3Bvc2FsXG4gICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHRleHR1cmUpXG4gICAgfVxuXG4gICAgcmV0dXJuIGdsVGV4dHVyZVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGdpdmVuIHRleHR1cmVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VUZXh0dXJlfSB0ZXh0dXJlXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFt1cGxvYWQgPSB0cnVlXVxuICAgKi9cbiAgdXBkYXRlVGV4dHVyZSAodGV4dHVyZSwgdXBsb2FkID0gdHJ1ZSkge1xuICAgIGxldCBzb3VyY2UgPSB0ZXh0dXJlLmdldFNvdXJjZSgpXG4gICAgY29uc3QgaGFzU291cmNlID0gISFzb3VyY2VcblxuICAgIGNvbnN0IGdsID0gdGhpcy5fY29udGV4dFxuICAgIGNvbnN0IGdsVW5pdCA9IHRleHR1cmUuZ2V0R0xVbml0KClcbiAgICBjb25zdCBnbFRleHR1cmUgPSB0aGlzLmdldE9yQ3JlYXRlR0xUZXh0dXJlKHRleHR1cmUpXG5cbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgZ2xVbml0KVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSlcblxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSlcblxuICAgIGlmIChyZXF1aXJlKCdnbCcpKSB7XG4gICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKVxuICAgIH1cblxuICAgIGlmICh1cGxvYWQgJiYgaGFzU291cmNlKSB7XG4gICAgICBpZiAodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZSB8fFxuICAgICAgICAgIHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQ2FudmFzJyB8fFxuICAgICAgICAgIChzb3VyY2UudGFnTmFtZSAmJiBzb3VyY2UudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJykpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBjbGllbnQtc2lkZSBiZWhhdmlvcjogVXBsb2FkIHRoZSBgc291cmNlYCBpbWFnZVxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNvdXJjZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluIGNhc2Ugd2UncmUgb24gdGhlIHNlcnZlciBzaWRlLCBjb252ZXJ0IGEgYG5vZGUtY2FudmFzYCBJbWFnZSBvYmplY3RcbiAgICAgICAgLy8gaW50byBhIFBpeGVsQXJyYXlJbWFnZVxuICAgICAgICBpZiAodHlwZW9mIE5vZGVDYW52YXNJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgTm9kZUNhbnZhc0ltYWdlKSB7XG4gICAgICAgICAgc291cmNlID0gUGl4ZWxBcnJheUltYWdlLmZyb21Ob2RlQ2FudmFzSW1hZ2Uoc291cmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBsb2FkIHRoZSBQaXhlbEFycmF5SW1hZ2UncyBkYXRhIChhIFVpbnQ4QXJyYXkpXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzb3VyY2UuZGF0YSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dHVyZS5pc01pcE1hcHBpbmdFbmFibGVkKCkpIHtcbiAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgIH1cbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5nZXRHTEZpbHRlcihnbCwgJ21pbicpKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0ZXh0dXJlLmdldEdMRmlsdGVyKGdsLCAnbWFnJykpXG4gICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0TWF4RGltZW5zaW9ucyAoKSB7XG4gICAgLy8gbm9kZS1nbCBzdXBwb3J0XG4gICAgY29uc3QgY3JlYXRlQ29udGV4dCA9IHJlcXVpcmUoJ2dsJylcbiAgICBpZiAoY3JlYXRlQ29udGV4dCkge1xuICAgICAgY29uc3QgZ2wgPSBjcmVhdGVDb250ZXh0KDEsIDEpXG4gICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzID0gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKVxuICAgIGlmICghZ2wpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCByZW5kZXIgdGFyZ2V0XG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9XG4gICAqL1xuICBnZXRDdXJyZW50UmVuZGVyVGFyZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX2N1cnJlbnRSZW5kZXJUYXJnZXQgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG9iamVjdCByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuT2JqZWN0UmVuZGVyZXJ9XG4gICAqL1xuICBnZXRDdXJyZW50T2JqZWN0UmVuZGVyZXIgKCkgeyByZXR1cm4gdGhpcy5fY3VycmVudE9iamVjdFJlbmRlcmVyIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgcmVuZGVyZXIgaXMgc3VwcG9ydGVkIG9uIHRoZSBjdXJyZW50IGRldmljZSBhbmQgYnJvd3NlclxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU3VwcG9ydGVkICgpIHtcbiAgICBpZiAocmVxdWlyZSgnZ2wnKSkge1xuICAgICAgLy8gV2UncmUgb24gdGhlIHNlcnZlciBzaWRlIGFuZCBub2RlLWdsIGlzIGF2YWlsYWJsZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGxldCBjYW52YXMgPSBVdGlscy5jcmVhdGVDYW52YXMoKVxuICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKVxuICAgIHJldHVybiAhIWdsXG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZXMgdGhpcyBSZW5kZXJlclxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5kaXNwb3NlKClcbiAgICB0aGlzLl9jdXJyZW50T2JqZWN0UmVuZGVyZXIuZGlzcG9zZSgpXG4gICAgdGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldC5kaXNwb3NlKClcbiAgICB0aGlzLl90ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB7XG4gICAgICB0ZXh0dXJlLmRpc3Bvc2VHTFRleHR1cmVzKHRoaXMpXG4gICAgfSlcbiAgfVxufVxuXG5XZWJHTFJlbmRlcmVyLmNvbnRleHRJZCA9IDBcbldlYkdMUmVuZGVyZXIudHlwZSA9ICdXZWJHTCdcblxuZXhwb3J0IGRlZmF1bHQgV2ViR0xSZW5kZXJlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvcmVuZGVyZXJzL3dlYmdsL3dlYmdsLXJlbmRlcmVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IFRleHR1cmVTaGFkZXIgZnJvbSAnLi90ZXh0dXJlLXNoYWRlcidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBUZXh0dXJlU2hhZGVyXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS9zaGFkZXJzL2luZGV4LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJy4uL2Rpc3BsYXkvY29udGFpbmVyJ1xuXG4vKipcbiAqIEEgZHJhd2FibGUgcmVjdGFuZ2xlIHdpdGggYSB0ZXh0dXJlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkVuZ2luZS5Db250YWluZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqL1xuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTcHJpdGVcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IHRleHR1cmVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0ZXh0dXJlKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlID0gdGhpcy5fb25UZXh0dXJlVXBkYXRlLmJpbmQodGhpcylcblxuICAgIHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlXG4gICAgdGhpcy5fc2hhZGVyID0gbnVsbFxuXG4gICAgLy8gQ2FjaGVkIGRpbWVuc2lvbnNcbiAgICB0aGlzLl93aWR0aCA9IDBcbiAgICB0aGlzLl9oZWlnaHQgPSAwXG5cbiAgICB0aGlzLl9hbmNob3IgPSBuZXcgVmVjdG9yMigwLCAwKVxuXG4gICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIHNwcml0ZSdzIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVGV4dHVyZVVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgICB0aGlzLl9sb2NhbEJvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgY29udGVudHMgb2YgdGhpcyBjb250YWluZXJcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlcldlYkdMIChyZW5kZXJlcikge1xuICAgIHJlbmRlcmVyLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnJlbmRlcmVycy5zcHJpdGUpXG4gICAgcmVuZGVyZXIucmVuZGVyZXJzLnNwcml0ZS5yZW5kZXIodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250ZW50cyBvZiB0aGlzIGNvbnRhaW5lclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHJlbmRlcmVyKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5fd29ybGRUcmFuc2Zvcm1cbiAgICBjb25zdCB0ZXh0dXJlRnJhbWUgPSB0aGlzLl90ZXh0dXJlLmdldEZyYW1lKClcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZUZyYW1lXG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKVxuXG4gICAgLy8gQXBwbHkgdHJhbnNmb3JtXG4gICAgY29uc3QgZHggPSB0aGlzLl9hbmNob3IueCAqIC13aWR0aFxuICAgIGNvbnN0IGR5ID0gdGhpcy5fYW5jaG9yLnkgKiAtaGVpZ2h0XG4gICAgY29uc3QgY3R4ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY3R4LnNldFRyYW5zZm9ybShcbiAgICAgIHRyYW5zZm9ybS5hLFxuICAgICAgdHJhbnNmb3JtLmIsXG4gICAgICB0cmFuc2Zvcm0uYyxcbiAgICAgIHRyYW5zZm9ybS5kLFxuICAgICAgdHJhbnNmb3JtLnR4ICogcGl4ZWxSYXRpbyxcbiAgICAgIHRyYW5zZm9ybS50eSAqIHBpeGVsUmF0aW9cbiAgICApXG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmdldFdvcmxkQWxwaGEoKVxuXG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSB0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKClcbiAgICBjb25zdCB0ZXh0dXJlUGl4ZWxSYXRpbyA9IGJhc2VUZXh0dXJlLmdldFBpeGVsUmF0aW8oKVxuICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICB0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKCkuZ2V0U291cmNlKCksXG5cbiAgICAgIC8vIFNvdXJjZSB4LCB5LCB3aWR0aCwgaGVpZ2h0XG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHdpZHRoICogdGV4dHVyZVBpeGVsUmF0aW8sXG4gICAgICBoZWlnaHQgKiB0ZXh0dXJlUGl4ZWxSYXRpbyxcblxuICAgICAgLy8gRGVzdGluYXRpb24geCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgZHggKiBwaXhlbFJhdGlvLFxuICAgICAgZHkgKiBwaXhlbFJhdGlvLFxuICAgICAgd2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgaGVpZ2h0ICogcGl4ZWxSYXRpb1xuICAgIClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFBVQkxJQyBBUElcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgc3ByaXRlIGlzIGxvY2F0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0F0UG9zaXRpb24gKHBvc2l0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxQb3NpdGlvbiA9IHRoaXMuX3dvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZVRvVmVjdG9yKHBvc2l0aW9uKVxuICAgIGNvbnN0IHRleHR1cmVGcmFtZSA9IHRoaXMuX3RleHR1cmUuZ2V0RnJhbWUoKVxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGV4dHVyZUZyYW1lXG5cbiAgICBjb25zdCB1cHBlckxlZnQgPSBuZXcgVmVjdG9yMigtd2lkdGgsIC1oZWlnaHQpXG4gICAgdXBwZXJMZWZ0Lm11bHRpcGx5KHRoaXMuX2FuY2hvcilcbiAgICBjb25zdCBsb3dlclJpZ2h0ID0gdXBwZXJMZWZ0LmNsb25lKClcbiAgICAgIC5hZGQod2lkdGgsIGhlaWdodClcblxuICAgIGlmIChsb2NhbFBvc2l0aW9uLnggPCB1cHBlckxlZnQueCB8fCBsb2NhbFBvc2l0aW9uLnggPiBsb3dlclJpZ2h0LnggfHxcbiAgICAgICAgbG9jYWxQb3NpdGlvbi55IDwgdXBwZXJMZWZ0LnkgfHwgbG9jYWxQb3NpdGlvbi55ID4gbG93ZXJSaWdodC55KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vbi1nbG9iYWwgYm91bmRzIG9mIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldExvY2FsQm91bmRzICgpIHtcbiAgICBpZiAodGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9sb2NhbEJvdW5kc1xuICAgICAgY29uc3QgdGV4dHVyZUZyYW1lID0gdGhpcy5fdGV4dHVyZS5nZXRGcmFtZSgpXG5cbiAgICAgIGJvdW5kcy54ID0gLXRleHR1cmVGcmFtZS53aWR0aCAqIHRoaXMuX2FuY2hvci54XG4gICAgICBib3VuZHMueSA9IC10ZXh0dXJlRnJhbWUuaGVpZ2h0ICogdGhpcy5fYW5jaG9yLnlcbiAgICAgIGJvdW5kcy53aWR0aCA9IHRleHR1cmVGcmFtZS53aWR0aFxuICAgICAgYm91bmRzLmhlaWdodCA9IHRleHR1cmVGcmFtZS5oZWlnaHRcblxuICAgICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsQm91bmRzLmNsb25lKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZHMgZm9yIHRoaXMgRGlzcGxheU9iamVjdFxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5NYXRoLlJlY3RhbmdsZX1cbiAgICovXG4gIGdldEJvdW5kcyAoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kc05lZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX2JvdW5kc1xuICAgICAgY29uc3QgdGV4dHVyZUZyYW1lID0gdGhpcy5fdGV4dHVyZS5nZXRGcmFtZSgpXG5cbiAgICAgIC8vIEBUT0RPIE9wdGltaXplIHRoaXMgKGlmIG5lY2Vzc2FyeSkuIFdlIGNvdWxkIHNraXAgbWF0cml4IGFwcGxpY2F0aW9uXG4gICAgICAvLyAgICAgICB3aGVuIHRoZXJlJ3Mgbm8gcm90YXRpb25cbiAgICAgIGNvbnN0IHdvcmxkVHJhbnNmb3JtID0gdGhpcy5fd29ybGRUcmFuc2Zvcm1cbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuX2FuY2hvclxuICAgICAgY29uc3QgcG9zaXRpb25zID0gd29ybGRUcmFuc2Zvcm0ucmVjdGFuZ2xlVG9Db29yZGluYXRlcyh0ZXh0dXJlRnJhbWUsIGFuY2hvcilcblxuICAgICAgbGV0IG1pblggPSBwb3NpdGlvbnNbMF0ueFxuICAgICAgbGV0IG1pblkgPSBwb3NpdGlvbnNbMF0ueVxuICAgICAgbGV0IG1heFggPSBtaW5YXG4gICAgICBsZXQgbWF4WSA9IG1pbllcblxuICAgICAgcG9zaXRpb25zLmZvckVhY2goKHt4LCB5fSkgPT4ge1xuICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeClcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpXG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KVxuICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSlcbiAgICAgIH0pXG5cbiAgICAgIGJvdW5kcy54ID0gbWluWFxuICAgICAgYm91bmRzLndpZHRoID0gTWF0aC5hYnMobWF4WCAtIG1pblgpXG4gICAgICBib3VuZHMueSA9IG1pbllcbiAgICAgIGJvdW5kcy5oZWlnaHQgPSBNYXRoLmFicyhtYXhZIC0gbWluWSlcblxuICAgICAgdGhpcy5fYm91bmRzTmVlZFVwZGF0ZSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZHMuY2xvbmUoKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gR0VUVEVSUyAvIFNFVFRFUlNcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB0ZXh0dXJlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5UZXh0dXJlfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBnZXRUZXh0dXJlICgpIHsgcmV0dXJuIHRoaXMuX3RleHR1cmUgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0dXJlXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlRleHR1cmV9IHRleHR1cmVcbiAgICovXG4gIHNldFRleHR1cmUgKHRleHR1cmUpIHtcbiAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZXh0dXJlKSB7XG4gICAgICB0aGlzLl90ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlKVxuICAgIH1cblxuICAgIHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlXG4gICAgaWYgKHRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKS5pc0xvYWRlZCgpKSB7XG4gICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKVxuICAgIH1cbiAgICB0ZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhZGVyXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5TaGFkZXJ9XG4gICAqL1xuICBnZXRTaGFkZXIgKCkgeyByZXR1cm4gdGhpcy5fc2hhZGVyIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2hhZGVyXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlNoYWRlcn0gc2hhZGVyXG4gICAqL1xuICBzZXRTaGFkZXIgKHNoYWRlcikgeyB0aGlzLl9zaGFkZXIgPSBzaGFkZXIgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCAoKSB7IHJldHVybiB0aGlzLl93aWR0aCB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKi9cbiAgc2V0V2lkdGggKHdpZHRoKSB7XG4gICAgdGhpcy5fc2NhbGUueCA9IHdpZHRoIC8gdGhpcy5fdGV4dHVyZS5nZXRGcmFtZSgpLndpZHRoXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFxuICAgIHRoaXMuX2JvdW5kc05lZWRVcGRhdGUgPSB0cnVlXG4gICAgdGhpcy5fbG9jYWxCb3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRIZWlnaHQgKCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0IH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaGVpZ2h0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHNldEhlaWdodCAoaGVpZ2h0KSB7XG4gICAgdGhpcy5fc2NhbGUueSA9IGhlaWdodCAvIHRoaXMuX3RleHR1cmUuZ2V0RnJhbWUoKS5oZWlnaHRcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHRcbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhbmNob3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0QW5jaG9yICgpIHsgcmV0dXJuIHRoaXMuX2FuY2hvciB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFuY2hvclxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn0gYW5jaG9yXG4gICAqL1xuICBzZXRBbmNob3IgKGFuY2hvciwgeSkge1xuICAgIGlmIChhbmNob3IgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICB0aGlzLl9hbmNob3IuY29weShhbmNob3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2FuY2hvci5zZXQoYW5jaG9yLCB5KVxuICAgIH1cbiAgICB0aGlzLl9ib3VuZHNOZWVkVXBkYXRlID0gdHJ1ZVxuICAgIHRoaXMuX2xvY2FsQm91bmRzTmVlZFVwZGF0ZSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIFNwcml0ZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgaWYgKHRoaXMuX3RleHR1cmUpIHtcbiAgICAgIHRoaXMuX3RleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwcml0ZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvc3ByaXRlcy9zcHJpdGUuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBSZWN0YW5nbGUgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi90ZXh0dXJlJ1xuaW1wb3J0IEJhc2VUZXh0dXJlIGZyb20gJy4vYmFzZS10ZXh0dXJlJ1xuaW1wb3J0IFdlYkdMUmVuZGVyVGFyZ2V0IGZyb20gJy4uL3V0aWxzL3dlYmdsLXJlbmRlci10YXJnZXQnXG5pbXBvcnQgQ2FudmFzUmVuZGVyVGFyZ2V0IGZyb20gJy4uL3V0aWxzL2NhbnZhcy1yZW5kZXItdGFyZ2V0J1xuaW1wb3J0IFdlYkdMRmlsdGVyTWFuYWdlciBmcm9tICcuLi9tYW5hZ2Vycy93ZWJnbC1maWx0ZXItbWFuYWdlcidcbmltcG9ydCBDYW52YXNGaWx0ZXJNYW5hZ2VyIGZyb20gJy4uL21hbmFnZXJzL2NhbnZhcy1maWx0ZXItbWFuYWdlcidcblxuLyoqXG4gKiBBIHRleHR1cmUgdGhhdCB5b3UgY2FuIHJlbmRlciB0b1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5FbmdpbmUuVGV4dHVyZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUmVuZGVyVGV4dHVyZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFt3aWR0aCA9IDEwMF1cbiAgICogQHBhcmFtICB7TnVtYmVyfSBbaGVpZ2h0ID0gMTAwXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtwaXhlbFJhdGlvID0gMV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZW5kZXJlciwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCwgcGl4ZWxSYXRpbyA9IDEpIHtcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZSgpXG4gICAgY29uc3QgZnJhbWUgPSBiYXNlVGV4dHVyZS5nZXRGcmFtZSgpXG4gICAgZnJhbWUud2lkdGggPSB3aWR0aFxuICAgIGZyYW1lLmhlaWdodCA9IGhlaWdodFxuICAgIGJhc2VUZXh0dXJlLnNldFBpeGVsUmF0aW8ocGl4ZWxSYXRpbylcbiAgICBiYXNlVGV4dHVyZS5zZXRMb2FkZWQodHJ1ZSlcbiAgICBzdXBlcihiYXNlVGV4dHVyZSwgbmV3IFJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KSlcblxuICAgIC8vIFJlbmRlclRleHR1cmUgaXMgYWx3YXlzIGxvYWRlZCFcbiAgICB0aGlzLl9sb2FkZWQgPSB0cnVlXG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodFxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvXG4gICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlclxuXG4gICAgdGhpcy5fc2V0dXBGaWx0ZXJNYW5hZ2VyKClcbiAgICB0aGlzLl9zZXR1cEJ1ZmZlcigpXG4gICAgdGhpcy5fdXBkYXRlVVZzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBmaWx0ZXIgbWFuYWdlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwRmlsdGVyTWFuYWdlciAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyLmlzT2ZUeXBlKCd3ZWJnbCcpKSB7XG4gICAgICB0aGlzLl9maWx0ZXJNYW5hZ2VyID0gbmV3IFdlYkdMRmlsdGVyTWFuYWdlcih0aGlzLl9yZW5kZXJlcilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlbmRlcmVyLmlzT2ZUeXBlKCdjYW52YXMnKSkge1xuICAgICAgdGhpcy5fZmlsdGVyTWFuYWdlciA9IG5ldyBDYW52YXNGaWx0ZXJNYW5hZ2VyKHRoaXMuX3JlbmRlcmVyKVxuICAgIH1cblxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIucmVzaXplVG8obmV3IFZlY3RvcjIodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYnVmZmVyIHRoYXQgd2UncmUgcmVuZGVyaW5nIHRvXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBCdWZmZXIgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLl9yZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgdGhpcy5fc2V0dXBXZWJHTEJ1ZmZlcigpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZW5kZXJlci5pc09mVHlwZSgnY2FudmFzJykpIHtcbiAgICAgIHRoaXMuX3NldHVwQ2FudmFzUmVuZGVyVGFyZ2V0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgV2ViR0xSZW5kZXJUYXJnZXQgZm9yIHRoaXMgUmVuZGVyVGV4dHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwV2ViR0xCdWZmZXIgKCkge1xuICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh0aGlzLl9yZW5kZXJlciwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgdGhpcy5fcGl4ZWxSYXRpbylcbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5zZXRHTFRleHR1cmVGb3JJZCh0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0VGV4dHVyZSgpLCB0aGlzLl9yZW5kZXJlci5nZXRDb250ZXh0KCkuaWQpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGZvciB0aGlzIFJlbmRlclRleHR1cmVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cENhbnZhc1JlbmRlclRhcmdldCAoKSB7XG4gICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IENhbnZhc1JlbmRlclRhcmdldChcbiAgICAgIHRoaXMuX3dpZHRoLFxuICAgICAgdGhpcy5faGVpZ2h0LFxuICAgICAgdGhpcy5fcGl4ZWxSYXRpbylcbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5zZXRTb3VyY2UodGhpcy5fcmVuZGVyVGFyZ2V0LmdldENhbnZhcygpKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGlzIHRleHR1cmUncyByZW5kZXIgYnVmZmVyXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuQ29sb3J9IGNvbG9yXG4gICAqL1xuICBjbGVhciAoY29sb3IpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQuY2xlYXIoY29sb3IpXG4gIH1cblxuICAvKipcbiAgICogUmVzaXplcyB0aGlzIFJlbmRlclRleHR1cmUgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqL1xuICByZXNpemVUbyAoZGltZW5zaW9ucykge1xuICAgIGlmICh0aGlzLl93aWR0aCA9PT0gZGltZW5zaW9ucy54ICYmIHRoaXMuX2hlaWdodCA9PT0gZGltZW5zaW9ucy55KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMueFxuICAgIHRoaXMuX2hlaWdodCA9IGRpbWVuc2lvbnMueVxuICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gZGltZW5zaW9ucy54XG4gICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gZGltZW5zaW9ucy55XG5cbiAgICB0aGlzLl9iYXNlVGV4dHVyZS5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgIHRoaXMuX3JlbmRlclRhcmdldC5yZXNpemVUbyhkaW1lbnNpb25zKVxuICAgIHRoaXMuX2ZpbHRlck1hbmFnZXIucmVzaXplVG8oZGltZW5zaW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqL1xuICByZW5kZXIgKGRpc3BsYXlPYmplY3QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5fcmVuZGVyZXIuaXNPZlR5cGUoJ3dlYmdsJykpIHtcbiAgICAgIHRoaXMuX3JlbmRlcldlYkdMKGRpc3BsYXlPYmplY3QpXG4gICAgfSBlbHNlIGlmICh0aGlzLl9yZW5kZXJlci5pc09mVHlwZSgnY2FudmFzJykpIHtcbiAgICAgIHRoaXMuX3JlbmRlckNhbnZhcyhkaXNwbGF5T2JqZWN0KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlbmRlclRleHR1cmUgZG9lcyBub3Qgc3VwcG9ydCByZW5kZXJpbmcgdmlhICR7dGhpcy5fcmVuZGVyZXIuY29uc3RydWN0b3IubmFtZX1gKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBEaXNwbGF5T2JqZWN0IHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyV2ViR0wgKGRpc3BsYXlPYmplY3QpIHtcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQuYWN0aXZhdGUoKVxuXG4gICAgZGlzcGxheU9iamVjdC5nZXRXb3JsZFRyYW5zZm9ybSgpLnJlc2V0KClcbiAgICBkaXNwbGF5T2JqZWN0LmdldENoaWxkcmVuKCkuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpXG4gICAgfSlcblxuICAgIGNvbnN0IHRlbXBGaWx0ZXJNYW5hZ2VyID0gdGhpcy5fcmVuZGVyZXIuZ2V0RmlsdGVyTWFuYWdlcigpXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0RmlsdGVyTWFuYWdlcih0aGlzLl9maWx0ZXJNYW5hZ2VyKVxuICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlckRpc3BsYXlPYmplY3QoZGlzcGxheU9iamVjdCwgdGhpcy5fcmVuZGVyVGFyZ2V0KVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldEZpbHRlck1hbmFnZXIodGVtcEZpbHRlck1hbmFnZXIpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gRGlzcGxheU9iamVjdCB1c2luZyBDYW52YXMyRFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlckNhbnZhcyAoZGlzcGxheU9iamVjdCkge1xuICAgIGRpc3BsYXlPYmplY3QuZ2V0V29ybGRUcmFuc2Zvcm0oKS5yZXNldCgpXG4gICAgZGlzcGxheU9iamVjdC5nZXRDaGlsZHJlbigpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKVxuICAgIH0pXG5cbiAgICBjb25zdCB0ZW1wRmlsdGVyTWFuYWdlciA9IHRoaXMuX3JlbmRlcmVyLmdldEZpbHRlck1hbmFnZXIoKVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldEZpbHRlck1hbmFnZXIodGhpcy5fZmlsdGVyTWFuYWdlcilcbiAgICB0aGlzLl9yZW5kZXJlci5yZW5kZXJEaXNwbGF5T2JqZWN0KGRpc3BsYXlPYmplY3QsIHRoaXMuX3JlbmRlclRhcmdldClcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRGaWx0ZXJNYW5hZ2VyKHRlbXBGaWx0ZXJNYW5hZ2VyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlciB0YXJnZXRcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuRW5naW5lLldlYkdMUmVuZGVyVGFyZ2V0fVxuICAgKi9cbiAgZ2V0UmVuZGVyVGFyZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JlbmRlclRhcmdldCB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgUmVuZGVyVGV4dHVyZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgdGhpcy5fYmFzZVRleHR1cmUuZGlzcG9zZSh0aGlzLl9yZW5kZXJlcilcbiAgICB0aGlzLl9yZW5kZXJUYXJnZXQuZGlzcG9zZSgpXG4gICAgdGhpcy5fZmlsdGVyTWFuYWdlci5kaXNwb3NlKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJUZXh0dXJlXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL2VuZ2luZS90ZXh0dXJlcy9yZW5kZXItdGV4dHVyZS5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHJlY3RhbmdsZSB0aGF0IGlzIHJlbmRlcmVkIHVzaW5nIFdlYkdMXG4gKiBAY2xhc3NcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5FbmdpbmVcbiAqIEBpZ25vcmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFF1YWQge1xuICBjb25zdHJ1Y3RvciAocmVuZGVyZXIpIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyXG5cbiAgICB0aGlzLl92ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEwMCwgMCxcbiAgICAgIDEwMCwgMTAwLFxuICAgICAgMCwgMTAwXG4gICAgXSlcblxuICAgIHRoaXMuX3V2cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMCwgMCxcbiAgICAgIDEsIDAsXG4gICAgICAxLCAxLFxuICAgICAgMCwgMVxuICAgIF0pXG5cbiAgICB0aGlzLl9pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAgIDAsIDEsIDIsIDAsIDMsIDJcbiAgICBdKVxuXG4gICAgdGhpcy5fY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAxLCAxLCAxLCAxLFxuICAgICAgMSwgMSwgMSwgMSxcbiAgICAgIDEsIDEsIDEsIDEsXG4gICAgICAxLCAxLCAxLCAxXG4gICAgXSlcblxuICAgIHRoaXMuX2luaXRCdWZmZXJzKClcbiAgICB0aGlzLl91cGxvYWRCdWZmZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIHRoZSBnaXZlbiByZWN0YW5nbGVzIHRvIHRoZSBxdWFkXG4gICAqIEBwYXJhbSAge1JlY3RhbmdsZX0gcmVjdDFcbiAgICogQHBhcmFtICB7UmVjdGFuZ2xlfSByZWN0MlxuICAgKi9cbiAgbWFwIChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHJlY3QyXG5cbiAgICAvLyBVcGRhdGUgdGhlIFVWc1xuICAgIC8vIFdlIGRvbid0IGhhdmUgYW55IHRyYW5zbGF0aW9uLCBzbyB0aGVzZSBmb3VyXG4gICAgLy8gdmFsdWVzIGFyZSBhbGwgd2UgbmVlZFxuICAgIHRoaXMuX3V2c1syXSA9IHJlY3QyLndpZHRoIC8gcmVjdDEud2lkdGhcbiAgICB0aGlzLl91dnNbNF0gPSB0aGlzLl91dnNbMl1cbiAgICB0aGlzLl91dnNbNV0gPSByZWN0Mi5oZWlnaHQgLyByZWN0MS5oZWlnaHRcbiAgICB0aGlzLl91dnNbN10gPSB0aGlzLl91dnNbNV1cblxuICAgIC8vIFVwZGF0ZSB0aGUgdmVydGljZXNcbiAgICB0aGlzLl92ZXJ0aWNlc1swXSA9IHhcbiAgICB0aGlzLl92ZXJ0aWNlc1sxXSA9IHlcblxuICAgIHRoaXMuX3ZlcnRpY2VzWzJdID0geCArIHJlY3QyLndpZHRoXG4gICAgdGhpcy5fdmVydGljZXNbM10gPSB5XG5cbiAgICB0aGlzLl92ZXJ0aWNlc1s0XSA9IHRoaXMuX3ZlcnRpY2VzWzJdXG4gICAgdGhpcy5fdmVydGljZXNbNV0gPSB5ICsgcmVjdDIuaGVpZ2h0XG5cbiAgICB0aGlzLl92ZXJ0aWNlc1s2XSA9IHhcbiAgICB0aGlzLl92ZXJ0aWNlc1s3XSA9IHRoaXMuX3ZlcnRpY2VzWzVdXG5cbiAgICB0aGlzLl91cGxvYWRCdWZmZXJzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYnVmZmVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2luaXRCdWZmZXJzICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuXG4gICAgLy8gSW5pdCB2ZXJ0ZXggYnVmZmVyXG4gICAgdGhpcy5fdmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGV4QnVmZmVyKVxuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAoOCArIDggKyAxNikgKiA0LCBnbC5EWU5BTUlDX0RSQVcpXG5cbiAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5faW5kZXhCdWZmZXIpXG4gICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5faW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpXG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkcyB0aGUgYnVmZmVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwbG9hZEJ1ZmZlcnMgKCkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5fcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG5cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGV4QnVmZmVyKVxuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLl92ZXJ0aWNlcylcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgOCAqIDQsIHRoaXMuX3V2cylcbiAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgKDggKyA4KSAqIDQsIHRoaXMuX2NvbG9ycylcbiAgfVxuXG4gIGdldFZlcnRleEJ1ZmZlciAoKSB7IHJldHVybiB0aGlzLl92ZXJ0ZXhCdWZmZXIgfVxuICBnZXRJbmRleEJ1ZmZlciAoKSB7IHJldHVybiB0aGlzLl9pbmRleEJ1ZmZlciB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGlzIFF1YWQncyBidWZmZXJzXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuX3JlbmRlcmVyLmdldENvbnRleHQoKVxuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl92ZXJ0ZXhCdWZmZXIpXG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2luZGV4QnVmZmVyKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFF1YWRcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL3V0aWxzL3F1YWQuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBVViBjb29yZGluYXRlcyBvZiBhIHRleHR1cmVcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkVuZ2luZVxuICovXG5jbGFzcyBUZXh0dXJlVVZzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBUZXh0dXJlVVZzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fdXZzID0gW1xuICAgICAgbmV3IFZlY3RvcjIoMCwgMCksXG4gICAgICBuZXcgVmVjdG9yMigxLCAwKSxcbiAgICAgIG5ldyBWZWN0b3IyKDEsIDEpLFxuICAgICAgbmV3IFZlY3RvcjIoMCwgMSlcbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgVVZzIGJhc2VkIG9uIHRoZSBnaXZlbiBiYXNlZnJhbWVcbiAgICogQHBhcmFtICB7UmVjdGFuZ2xlfSBmcmFtZVxuICAgKiBAcGFyYW0gIHtSZWN0YW5nbGV9IGJhc2VGcmFtZVxuICAgKi9cbiAgdXBkYXRlIChmcmFtZSwgYmFzZUZyYW1lKSB7XG4gICAgLy8gVXBwZXIgbGVmdFxuICAgIGxldCB1diA9IHRoaXMuX3V2c1swXVxuICAgIHV2LnggPSBmcmFtZS54IC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IGZyYW1lLnkgLyBiYXNlRnJhbWUuaGVpZ2h0XG5cbiAgICAvLyBVcHBlciByaWdodFxuICAgIHV2ID0gdGhpcy5fdXZzWzFdXG4gICAgdXYueCA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IGZyYW1lLnkgLyBiYXNlRnJhbWUuaGVpZ2h0XG5cbiAgICAvLyBMb3dlciByaWdodFxuICAgIHV2ID0gdGhpcy5fdXZzWzJdXG4gICAgdXYueCA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIGJhc2VGcmFtZS5oZWlnaHRcblxuICAgIC8vIExvd2VyIGxlZnRcbiAgICB1diA9IHRoaXMuX3V2c1szXVxuICAgIHV2LnggPSBmcmFtZS54IC8gYmFzZUZyYW1lLndpZHRoXG4gICAgdXYueSA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIGJhc2VGcmFtZS5oZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBVViBjb29yZGluYXRlcyBmb3IgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSAge051bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKi9cbiAgZ2V0VVZzQXQgKGluZGV4KSB7IHJldHVybiB0aGlzLl91dnNbaW5kZXhdIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVYgY29vcmRpbmF0ZXNcbiAgICogQHJldHVybiB7QXJyYXkuPFBob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMj59XG4gICAqL1xuICBnZXRVVnMgKCkgeyByZXR1cm4gdGhpcy5fdXZzIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dHVyZVVWc1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9lbmdpbmUvdXRpbHMvdGV4dHVyZS11dnMuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEEgY291cGxlIG9mIHV0aWxpdHkgZnVuY3Rpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5jb25zdCBVdGlscyA9IHtcbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byB1bmRlZmluZWQuIE9uY2UgYVxuICAgKiBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IC4uLnNvdXJjZXNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZGVmYXVsdHM6IChvYmplY3QsIC4uLnNvdXJjZXMpID0+IHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIENsb25lIHNvdXJjZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaV1cbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmplY3Rba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICogc291cmNlcy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gLi4uc291cmNlc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBleHRlbmQ6IChvYmplY3QsIC4uLnNvdXJjZXMpID0+IHtcbiAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgbGV0IG5ld09iamVjdCA9IHt9XG4gICAgZm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XVxuICAgIH1cblxuICAgIC8vIEV4dGVuZCBzb3VyY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldXG4gICAgICBmb3IgKGxldCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIG5ld09iamVjdFtrZXldID0gc291cmNlW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqZWN0XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVXRpbHNcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vZW5naW5lL3V0aWxzL3V0aWxzLmpzXG4gKiovIiwiLyohXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBQaG90b0VkaXRvclNESyBmcm9tICcuL3NkaydcblxuLyoqXG4gKiBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBTREtcbiAqIEBuYW1lIFBob3RvRWRpdG9yU0RLLnZlcnNpb25cbiAqIEBpbnRlcm5hbCBLZWVwIGluIHN5bmMgd2l0aCBwYWNrYWdlLmpzb25cbiAqL1xuUGhvdG9FZGl0b3JTREsudmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxuLy8gTmFtZXNwYWNlc1xuaW1wb3J0ICogYXMgTWF0aCBmcm9tICcuL2xpYi9tYXRoLydcblBob3RvRWRpdG9yU0RLLk1hdGggPSBNYXRoXG5cbmltcG9ydCAqIGFzIE9wZXJhdGlvbnMgZnJvbSAnLi9vcGVyYXRpb25zLydcblBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMgPSBPcGVyYXRpb25zXG5cbmltcG9ydCAqIGFzIEZpbHRlcnMgZnJvbSAnLi9vcGVyYXRpb25zL2ZpbHRlcnMvJ1xuUGhvdG9FZGl0b3JTREsuRmlsdGVycyA9IEZpbHRlcnNcblxuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzLydcblBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXMgPSBGaWx0ZXJQcmltaXRpdmVzXG5cbmltcG9ydCBFbmdpbmUgZnJvbSAnLi9lbmdpbmUvJ1xuUGhvdG9FZGl0b3JTREsuRW5naW5lID0gRW5naW5lXG5cbi8vIENsYXNzZXNcbmltcG9ydCBDb2xvciBmcm9tICcuL2xpYi9jb2xvcidcblBob3RvRWRpdG9yU0RLLkNvbG9yID0gQ29sb3JcblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL29wZXJhdGlvbnMvZmlsdGVycy9maWx0ZXInXG5QaG90b0VkaXRvclNESy5GaWx0ZXIgPSBGaWx0ZXJcblxuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbnMvb3BlcmF0aW9uJ1xuUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uID0gT3BlcmF0aW9uXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9saWIvZXZlbnQtZW1pdHRlcidcblBob3RvRWRpdG9yU0RLLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlclxuXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnXG5QaG90b0VkaXRvclNESy5VdGlscyA9IFV0aWxzXG5cbmltcG9ydCBPcGVyYXRpb25zU3RhY2sgZnJvbSAnLi9saWIvb3BlcmF0aW9ucy1zdGFjaydcblBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNTdGFjayA9IE9wZXJhdGlvbnNTdGFja1xuXG5pbXBvcnQgRVhJRiBmcm9tICcuL2xpYi9leGlmJ1xuUGhvdG9FZGl0b3JTREsuRVhJRiA9IEVYSUZcblxuaW1wb3J0IFByb21pc2UgZnJvbSAnLi92ZW5kb3IvcHJvbWlzZSdcblBob3RvRWRpdG9yU0RLLlByb21pc2UgPSBQcm9taXNlXG5cbi8vIENvbnN0YW50c1xuaW1wb3J0IHsgUmVuZGVyVHlwZSwgSW1hZ2VGb3JtYXQgfSBmcm9tICcuL2NvbnN0YW50cydcblBob3RvRWRpdG9yU0RLLlJlbmRlclR5cGUgPSBSZW5kZXJUeXBlXG5QaG90b0VkaXRvclNESy5JbWFnZUZvcm1hdCA9IEltYWdlRm9ybWF0XG5cbi8vIExpYnNcbmltcG9ydCB7IGRlZmF1bHQgYXMgQmFzZTY0IH0gZnJvbSAnLi9saWIvYmFzZTY0J1xuUGhvdG9FZGl0b3JTREsuQmFzZTY0ID0gQmFzZTY0XG5cbm1vZHVsZS5leHBvcnRzID0gUGhvdG9FZGl0b3JTREtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vaW5kZXguanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG4vKipcbiAqIEFuIEFycmF5U3RyZWFtIHByb3ZpZGVzIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBhIGJ5dGUgYXJyYXlcbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIEFycmF5U3RyZWFtIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQXJyYXlTdHJlYW1cbiAgICogQHBhcmFtICB7QXJyYXl9IGJ1ZlxuICAgKi9cbiAgY29uc3RydWN0b3IgKGJ1Zikge1xuICAgIHRoaXMuX2hlYWQgPSAwXG4gICAgdGhpcy5fYnVmID0gYnVmXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyA4IGJpdCBpbnRlZ2VyXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBlZWtJbnQ4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmW3RoaXMuX2hlYWRdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyAxNiBiaXQgaW50ZWdlclxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbGl0dGxlRW5kaWFuID0gZmFsc2VdXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHBlZWtJbnQxNiAobGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBhID0gdGhpcy5fYnVmW3RoaXMuX2hlYWRdXG4gICAgY29uc3QgYiA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV1cbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgcmV0dXJuIChhIDw8IDgpICsgYlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGIgPDwgOCkgKyBhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMjQgYml0IGludGVnZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBwZWVrSW50MjQgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkXVxuICAgIGNvbnN0IGIgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDFdXG4gICAgY29uc3QgYyA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMl1cbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgcmV0dXJuIChhIDw8IDE2KSArIChiIDw8IDgpICsgY1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGMgPDwgMTYpICsgKGIgPDwgOCkgKyBhXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMzIgYml0IGludGVnZXJcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBwZWVrSW50MzIgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkXVxuICAgIGNvbnN0IGIgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDFdXG4gICAgY29uc3QgYyA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMl1cbiAgICBjb25zdCBkID0gdGhpcy5fYnVmW3RoaXMuX2hlYWQgKyAzXVxuICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICByZXR1cm4gKGEgPDwgMzIpICsgKGIgPDwgMTYpICsgKGMgPDwgOCkgKyBkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZCA8PCAzMikgKyAoYyA8PCAxNikgKyAoYiA8PCA4KSArIGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBnaXZlbiAxNiBiaXQgaW50ZWdlciBhdCB0aGUgY3VycmVudCBoZWFkIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge051bWJlcn0gbnVtXG4gICAqL1xuICB3cml0ZUludDE2IChudW0pIHtcbiAgICB0aGlzLl9idWZbdGhpcy5faGVhZF0gPSBudW0gPj4gOCAvLyB1cHBlclxuICAgIHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV0gPSBudW0gJiAweGZmIC8vIGxvd2VyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyA4IGJpdCBpbnRlZ2VyIGFuZCBtb3ZlcyB0aGUgaGVhZCBieSAxIGJ5dGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgcmVhZEludDggKCkge1xuICAgIGNvbnN0IG51bSA9IHRoaXMucGVla0ludDgoKVxuICAgIHRoaXMuX2hlYWQgKz0gMVxuICAgIHJldHVybiBudW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZm9sbG93aW5nIDE2IGJpdCBpbnRlZ2VyIGFuZCBtb3ZlcyB0aGUgaGVhZCBieSAyIGJ5dGVzXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtsaXR0bGVFbmRpYW4gPSBmYWxzZV1cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgcmVhZEludDE2IChsaXR0bGVFbmRpYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IG51bSA9IHRoaXMucGVla0ludDE2KGxpdHRsZUVuZGlhbilcbiAgICB0aGlzLl9oZWFkICs9IDJcbiAgICByZXR1cm4gbnVtXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZvbGxvd2luZyAyNCBiaXQgaW50ZWdlciBhbmQgbW92ZXMgdGhlIGhlYWQgYnkgMyBieXRlc1xuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbGl0dGxlRW5kaWFuID0gZmFsc2VdXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHJlYWRJbnQyNCAobGl0dGxlRW5kaWFuID0gZmFsc2UpIHtcbiAgICBjb25zdCBudW0gPSB0aGlzLnBlZWtJbnQyNChsaXR0bGVFbmRpYW4pXG4gICAgdGhpcy5faGVhZCArPSAzXG4gICAgcmV0dXJuIG51bVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgMzIgYml0IGludGVnZXIgYW5kIG1vdmVzIHRoZSBoZWFkIGJ5IDQgYnl0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2xpdHRsZUVuZGlhbiA9IGZhbHNlXVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICByZWFkSW50MzIgKGxpdHRsZUVuZGlhbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgbnVtID0gdGhpcy5wZWVrSW50MzIobGl0dGxlRW5kaWFuKVxuICAgIHRoaXMuX2hlYWQgKz0gNFxuICAgIHJldHVybiBudW1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBsZW5ndGhcbiAgICogQHBhcmFtICB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAobGVuZ3RoKSB7XG4gICAgbGV0IHN0ciA9ICcnXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gdGhpcy5yZWFkSW50OCgpXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyYWN0ZXIpXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGhlYWQgcG9zaXRpb25cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0SGVhZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoZWFkIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWFkXG4gICAqL1xuICBzZXRIZWFkIChoZWFkKSB7XG4gICAgdGhpcy5faGVhZCA9IGhlYWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBBcnJheVN0cmVhbVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvYXJyYXktc3RyZWFtLmpzXG4gKiovIiwiLyogZ2xvYmFsIEltYWdlICovXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuaW1wb3J0IHsgUmVuZGVyVHlwZSwgSW1hZ2VGb3JtYXQgfSBmcm9tICcuLi9jb25zdGFudHMnXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi91dGlscydcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IEV4aWYgZnJvbSAnLi9leGlmJ1xuaW1wb3J0IE5vZGVHTEV4cG9ydGVyIGZyb20gJy4vbm9kZS1nbC1leHBvcnRlcidcbmltcG9ydCBDYW52YXMgZnJvbSAnY2FudmFzJ1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIFBob3RvRWRpdG9yU0RLLkltYWdlRXhwb3J0ZXJcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEltYWdlRXhwb3J0ZXIge1xuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBnaXZlbiBSZW5kZXJUeXBlIGFuZCBJbWFnZUZvcm1hdFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5SZW5kZXJUeXBlfSByZW5kZXJUeXBlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkltYWdlRm9ybWF0fSBpbWFnZUZvcm1hdFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAdG9kbyBDbGVhbiB0aGlzIG1lc3MgdXBcbiAgICovXG4gIHN0YXRpYyB2YWxpZGF0ZVNldHRpbmdzIChyZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgIHJlbmRlclR5cGU6IHJlbmRlclR5cGUsXG4gICAgICAgIGltYWdlRm9ybWF0OiBpbWFnZUZvcm1hdFxuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBSZW5kZXJUeXBlXG4gICAgICBpZiAoKHR5cGVvZiBzZXR0aW5ncy5yZW5kZXJUeXBlICE9PSAndW5kZWZpbmVkJyAmJiBzZXR0aW5ncy5yZW5kZXJUeXBlICE9PSBudWxsKSAmJlxuICAgICAgICAgIFV0aWxzLnZhbHVlcyhSZW5kZXJUeXBlKS5pbmRleE9mKHNldHRpbmdzLnJlbmRlclR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVuZGVyIHR5cGU6ICcgKyBzZXR0aW5ncy5yZW5kZXJUeXBlKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2V0dGluZ3MucmVuZGVyVHlwZSA9IFJlbmRlclR5cGUuREFUQVVSTFxuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBJbWFnZUZvcm1hdFxuICAgICAgaWYgKCh0eXBlb2Ygc2V0dGluZ3MuaW1hZ2VGb3JtYXQgIT09ICd1bmRlZmluZWQnICYmIHNldHRpbmdzLmltYWdlRm9ybWF0ICE9PSBudWxsKSAmJlxuICAgICAgICAgIFV0aWxzLnZhbHVlcyhJbWFnZUZvcm1hdCkuaW5kZXhPZihzZXR0aW5ncy5pbWFnZUZvcm1hdCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSBmb3JtYXQ6ICcgKyBzZXR0aW5ncy5pbWFnZUZvcm1hdClcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGltYWdlRm9ybWF0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZXR0aW5ncy5pbWFnZUZvcm1hdCA9IEltYWdlRm9ybWF0LlBOR1xuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgdHlwZSAnYnVmZmVyJyBvbmx5IGF2YWlsYWJsZSBpbiBub2RlXG4gICAgICBpZiAoc2V0dGluZ3MucmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5CVUZGRVIgJiZcbiAgICAgICAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXIgdHlwZSBcXCdidWZmZXJcXCcgaXMgb25seSBhdmFpbGFibGUgd2hlbiB1c2luZyBub2RlLmpzJylcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShzZXR0aW5ncylcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgdGhlIGltYWdlIGZyb20gdGhlIGdpdmVuIGNhbnZhcyB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAqIEBwYXJhbSAge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuUmVuZGVyVHlwZX0gcmVuZGVyVHlwZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5JbWFnZUZvcm1hdH0gaW1hZ2VGb3JtYXRcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbcXVhbGl0eSA9IDAuOF1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHN0YXRpYyBleHBvcnQgKHNkaywgaW1hZ2UsIGNhbnZhcywgcmVuZGVyVHlwZSwgaW1hZ2VGb3JtYXQsIHF1YWxpdHkgPSAwLjgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHJlc3VsdFxuICAgICAgaWYgKHJlbmRlclR5cGUgPT09IFJlbmRlclR5cGUuSU1BR0UgfHxcbiAgICAgICAgICByZW5kZXJUeXBlID09PSBSZW5kZXJUeXBlLkRBVEFVUkwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gUXVhbGl0eSBub3Qgc3VwcG9ydGVkIGluIG5vZGUgZW52aXJvbm1lbnQgLyBub2RlLWNhbnZhc1xuICAgICAgICAgIHJlc3VsdCA9IGNhbnZhcy50b0RhdGFVUkwoaW1hZ2VGb3JtYXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZUZvcm1hdCwgcXVhbGl0eSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gaW1hZ2UncyBgc3JjYCBhdHRyaWJ1dGUgaXMgYSBqcGVnIGRhdGEgdXJsLCB3ZSBjYW4gcmVzdG9yZVxuICAgICAgICAvLyB0aGUgZXhpZiBpbmZvcm1hdGlvblxuICAgICAgICBpZiAoRXhpZi5pc0pQRUcoaW1hZ2Uuc3JjKSAmJiBFeGlmLmlzSlBFRyhyZXN1bHQpKSB7XG4gICAgICAgICAgY29uc3QgZXhpZiA9IHNkay5nZXRFeGlmKClcbiAgICAgICAgICBpZiAoZXhpZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gZXhpZi5yZXN0b3JlRXhpZlRhZ3MocmVzdWx0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG4gICAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoJ3dlYmdsJykgJiYgKHR5cGVvZiBDYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIENhbnZhcykpIHtcbiAgICAgICAgTm9kZUdMRXhwb3J0ZXIucmVuZGVyQ29udGV4dFRvQ2FudmFzKHJlbmRlcmVyLmdldENvbnRleHQoKSwgY2FudmFzKVxuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5JTUFHRSkge1xuICAgICAgICBsZXQgb3V0cHV0SW1hZ2VcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBJbWFnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBOb3QgYSBicm93c2VyIGVudmlyb25tZW50XG4gICAgICAgICAgdmFyIENhbnZhc0ltYWdlID0gcmVxdWlyZSgnY2FudmFzJykuSW1hZ2VcbiAgICAgICAgICBvdXRwdXRJbWFnZSA9IG5ldyBDYW52YXNJbWFnZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0SW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0SW1hZ2Uuc3JjID0gcmVzdWx0XG4gICAgICAgIHJlc29sdmUob3V0cHV0SW1hZ2UpXG4gICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09IFJlbmRlclR5cGUuREFUQVVSTCkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdClcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5CVUZGRVIpIHtcbiAgICAgICAgcmVzb2x2ZShjYW52YXMudG9CdWZmZXIoKSlcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5NU0JMT0IpIHtcbiAgICAgICAgcmVzb2x2ZShjYW52YXMubXNUb0Jsb2IoKSlcbiAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gUmVuZGVyVHlwZS5CTE9CKSB7XG4gICAgICAgIGNhbnZhcy50b0Jsb2IoKGJsb2IpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGJsb2IpXG4gICAgICAgIH0sIGltYWdlRm9ybWF0LCBxdWFsaXR5KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VFeHBvcnRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9saWIvaW1hZ2UtZXhwb3J0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgQ2FudmFzIGZyb20gJ2NhbnZhcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZUdMRXhwb3J0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgbm9kZS1jYW52YXNgIENhbnZhcyBhbmQgcmVuZGVycyB0aGUgaW1hZ2UgZnJvbSB0aGUgYGdsYCBjb250ZXh0IG9udG8gaXRcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJpbmdDb250ZXh0MkR9IGdsXG4gICAqIEBwYXJhbSAge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBzdGF0aWMgcmVuZGVyQ29udGV4dFRvQ2FudmFzIChnbCwgY2FudmFzKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXNcbiAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpXG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpXG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgQ2FudmFzLkltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KVxuXG4gICAgbGV0IGkgPSAwXG4gICAgcGl4ZWxzLmZvckVhY2goKCkgPT4ge1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaV0gPSBwaXhlbHNbaV1cbiAgICAgIGkrK1xuICAgIH0pXG5cbiAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL25vZGUtZ2wtZXhwb3J0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBMb2cgfSBmcm9tICcuLi9nbG9iYWxzJ1xuXG5jb25zdCBWRVJTSU9OX0NIRUNLX0ZOID0gJ2ltZ2x5U0RLVmVyc2lvbkNhbGxiYWNrJ1xuY29uc3QgVkVSU0lPTl9DSEVDS19VUkwgPSBgaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL3ZlcnNpb24uanNvbj9zZGs9aHRtbDUmanNvbmNhbGxiYWNrPSR7VkVSU0lPTl9DSEVDS19GTn1gXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlcmUgaXMgYSBuZXcgdmVyc2lvbiBvZiB0aGUgU0RLIGF2YWlsYWJsZVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREtcbiAqIEBpZ25vcmVcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFZlcnNpb25DaGVja2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbkNoZWNrZXJcbiAgICogQHBhcmFtICB7U3RyaW5nfSB2ZXJzaW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmVyc2lvbikge1xuICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uXG4gICAgdGhpcy5fY2hlY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHZlcnNpb24gb2YgdGhlIFNESyBpcyBvdXRkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrICgpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIExvZy5pbmZvKHRoaXMuY29uc3RydWN0b3IubmFtZSwgJ05vdCBpbiBicm93c2VyIGVudmlyb25tZW50LiBWZXJzaW9uIGNoZWNrIHNraXBwZWQuJylcbiAgICB9XG5cbiAgICBsZXQgc2VsZiA9IHRoaXNcbiAgICB3aW5kb3dbVkVSU0lPTl9DSEVDS19GTl0gPSAocmVzcG9uc2UpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5vdXRkYXRlZCkge1xuICAgICAgICBMb2cud2Fybih0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGBZb3VyIFZlcnNpb24gJHtzZWxmLl92ZXJzaW9ufSBpcyBvdXRkYXRlZC4gQ3VycmVudCB2ZXJzaW9uIGlzICR7cmVzcG9uc2UudmVyc2lvbn0uYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICBzY3JpcHQuc3JjID0gVkVSU0lPTl9DSEVDS19VUkwgKyAnJnZlcnNpb249JyArIHRoaXMuX3ZlcnNpb25cbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVyc2lvbkNoZWNrZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vbGliL3ZlcnNpb24tY2hlY2tlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFZlY3RvcjIgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuaW1wb3J0IEFkanVzdG1lbnRzRmlsdGVyIGZyb20gJy4vYWRqdXN0bWVudHMvYWRqdXN0bWVudHMtZmlsdGVyJ1xuXG4vKipcbiAqIEFwcGxpZXMgYWRqdXN0bWVudHMgKGJyaWdodG5lc3MsIHNhdHVyYXRpb24sIGNvbnRyYXN0KSB0byB0aGUgaW1hZ2VcbiAqIEBjbGFzc1xuICogQGFsaWFzIE9wZXJhdGlvbnMuQWRqdXN0bWVudHNPcGVyYXRpb25cbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLXG4gKi9cbmNsYXNzIEFkanVzdG1lbnRzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQWRqdXN0bWVudHNPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmJyaWdodG5lc3MgPSAwXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLnNhdHVyYXRpb24gPSAxXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IFtvcHRpb25zLmNvbnRyYXN0ID0gMV1cbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBBZGp1c3RtZW50c0ZpbHRlcigpXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW3RoaXMuX2ZpbHRlcl0pXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHJlbmRlcmVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICBjb25zdCBvdXRwdXRTcHJpdGUgPSBzZGsuZ2V0U3ByaXRlKClcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gdGhpcy5fZ2V0UmVuZGVyVGV4dHVyZShzZGspXG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUob3V0cHV0U3ByaXRlLmdldFRleHR1cmUoKSlcblxuICAgIGNvbnN0IHNwcml0ZUJvdW5kcyA9IG91dHB1dFNwcml0ZS5nZXRCb3VuZHMoKVxuICAgIGNvbnN0IHNwcml0ZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihzcHJpdGVCb3VuZHMud2lkdGgsIHNwcml0ZUJvdW5kcy5oZWlnaHQpXG4gICAgcmVuZGVyVGV4dHVyZS5yZXNpemVUbyhzcHJpdGVEaW1lbnNpb25zKVxuXG4gICAgdGhpcy5fZmlsdGVyLnNldCh7XG4gICAgICBicmlnaHRuZXNzOiB0aGlzLl9vcHRpb25zLmJyaWdodG5lc3MsXG4gICAgICBzYXR1cmF0aW9uOiB0aGlzLl9vcHRpb25zLnNhdHVyYXRpb24sXG4gICAgICBjb250cmFzdDogdGhpcy5fb3B0aW9ucy5jb250cmFzdFxuICAgIH0pXG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcblxuICAgIHRoaXMuc2V0RGlydHlGb3JSZW5kZXJlcihmYWxzZSwgcmVuZGVyZXIpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5BZGp1c3RtZW50c09wZXJhdGlvbi5pZGVudGlmaWVyID0gJ2FkanVzdG1lbnRzJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5BZGp1c3RtZW50c09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgYnJpZ2h0bmVzczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICBzYXR1cmF0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxLjAgfSxcbiAgY29udHJhc3Q6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEuMCB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFkanVzdG1lbnRzT3BlcmF0aW9uXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvYWRqdXN0bWVudHMtb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSwgRW5naW5lLCBWZWN0b3IyLCBDb2xvciB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuXG5jbGFzcyBCb3JkZXJGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi9zaGFkZXJzL29wZXJhdGlvbnMvYm9yZGVyLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCB7IGNvbG9yLCB0aGlja25lc3MgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIG91dHB1dENvbnRleHQuc2F2ZSgpXG4gICAgb3V0cHV0Q29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKVxuICAgIG91dHB1dENvbnRleHQuYmVnaW5QYXRoKClcbiAgICBvdXRwdXRDb250ZXh0LmxpbmVXaWR0aCA9IHRoaWNrbmVzcyAqIDJcbiAgICBvdXRwdXRDb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IudG9SR0JBKClcbiAgICBvdXRwdXRDb250ZXh0LnJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuICAgIG91dHB1dENvbnRleHQuc3Ryb2tlKClcbiAgICBvdXRwdXRDb250ZXh0LnJlc3RvcmUoKVxuICB9XG59XG5cbkJvcmRlckZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgY29sb3I6IHsgdHlwZTogJ2NvbG9yJywgZGVmYXVsdDogQ29sb3IuQkxBQ0ssIHVuaWZvcm1UeXBlOiAnNGYnIH0sXG4gIHRoaWNrbmVzczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICB0ZXh0dXJlU2l6ZTogeyB0eXBlOiAndmVjdG9yMicsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAsIDApLCB1bmlmb3JtVHlwZTogJzJmJyB9XG59XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgYSBib3JkZXIgYXJvdW5kIHRoZSBjYW52YXNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1xuICovXG5jbGFzcyBCb3JkZXJPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCb3JkZXJPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IEJvcmRlckZpbHRlcigpXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW3RoaXMuX2ZpbHRlcl0pXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYm9yZGVyIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICBjb25zdCBvdXRwdXRTcHJpdGUgPSBzZGsuZ2V0U3ByaXRlKClcbiAgICBjb25zdCByZW5kZXJUZXh0dXJlID0gdGhpcy5fZ2V0UmVuZGVyVGV4dHVyZShzZGspXG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUob3V0cHV0U3ByaXRlLmdldFRleHR1cmUoKSlcblxuICAgIGNvbnN0IHNwcml0ZUJvdW5kcyA9IG91dHB1dFNwcml0ZS5nZXRCb3VuZHMoKVxuICAgIGNvbnN0IHNwcml0ZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihzcHJpdGVCb3VuZHMud2lkdGgsIHNwcml0ZUJvdW5kcy5oZWlnaHQpXG5cbiAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKHNwcml0ZURpbWVuc2lvbnMpXG5cbiAgICBjb25zdCB7IGNvbG9yLCB0aGlja25lc3MgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIC8vIFVwZGF0ZSB1bmlmb3Jtc1xuICAgIHRoaXMuX2ZpbHRlci5zZXQoe1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICB0ZXh0dXJlU2l6ZTogc3ByaXRlRGltZW5zaW9uc1xuICAgIH0pXG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcbiAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZmFsc2UsIHJlbmRlcmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQm9yZGVyT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnYm9yZGVyJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5Cb3JkZXJPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbG9yOiB7IHR5cGU6ICdjb2xvcicsIGRlZmF1bHQ6IG5ldyBDb2xvcigwLCAwLCAwLCAxKSB9LFxuICB0aGlja25lc3M6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDUgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb3JkZXJPcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9ib3JkZXItb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSwgQ29uc3RhbnRzLCBFbmdpbmUsIFZlY3RvcjIsIENvbG9yLCBVdGlscyB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuaW1wb3J0IFBhdGggZnJvbSAnLi9icnVzaC9wYXRoJ1xuaW1wb3J0IENvbnRyb2xQb2ludCBmcm9tICcuL2JydXNoL2NvbnRyb2wtcG9pbnQnXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgYnJ1c2hlcyBvbiB0aGUgY2FudmFzXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgQnJ1c2hPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCcnVzaE9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9icnVzaENhbnZhc0RpcnR5ID0gdHJ1ZVxuICAgIHRoaXMuX2JydXNoQ2FudmFzID0gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICB0aGlzLl90ZXh0dXJlID0gRW5naW5lLlRleHR1cmUuZnJvbUNhbnZhcyh0aGlzLl9icnVzaENhbnZhcylcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl90ZXh0dXJlKVxuXG4gICAgdGhpcy5faW5wdXRTcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX3Nwcml0ZSlcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5faW5wdXRTcHJpdGUpXG4gICAgdGhpcy5fY29udGFpbmVyLmFkZENoaWxkKHRoaXMuX3Nwcml0ZSlcblxuICAgIHRoaXMuX29uUGF0aFVwZGF0ZSA9IHRoaXMuX29uUGF0aFVwZGF0ZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSA9IHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlLmJpbmQodGhpcylcbiAgICB0aGlzLl9zZGsub24oQ29uc3RhbnRzLkV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHBhdGggaGFzIGJlZW4gdXBkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uUGF0aFVwZGF0ZSAoKSB7XG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhYm91dCB0byBiZSB1cGRhdGVkLiBJZiB0aGUgY3JvcFxuICAgKiBvciByb3RhdGlvbiBvcGVyYXRpb24gaXMgdXBkYXRlZCwgdGhpcyB3aWxsIGJlIHJlY29nbml6ZWQgYW5kIHRoZVxuICAgKiBzdGlja2VycyB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHlcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGUgKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gb3BlcmF0aW9uLmNvbnN0cnVjdG9yXG5cbiAgICBpZiAoaWRlbnRpZmllciA9PT0gJ2Nyb3AnICYmXG4gICAgICAgICdzdGFydCcgaW4gb3B0aW9ucyAmJlxuICAgICAgICAnZW5kJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLl9hcHBseUNyb3Aob3BlcmF0aW9uLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVyID09PSAnb3JpZW50YXRpb24nKSB7XG4gICAgICBpZiAoJ3JvdGF0aW9uJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5Um90YXRpb24ob3BlcmF0aW9uLCBvcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBpZiAoJ2ZsaXBWZXJ0aWNhbGx5JyBpbiBvcHRpb25zICYmXG4gICAgICAgICAgb3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkgIT09IG9wdGlvbnMuZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlGbGlwKG9wZXJhdGlvbiwgJ3ZlcnRpY2FsJylcbiAgICAgIH1cblxuICAgICAgaWYgKCdmbGlwSG9yaXpvbnRhbGx5JyBpbiBvcHRpb25zICYmXG4gICAgICAgICAgb3BlcmF0aW9uLmdldEZsaXBIb3Jpem9udGFsbHkoKSAhPT0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIHRoaXMuX2FwcGx5RmxpcChvcGVyYXRpb24sICdob3Jpem9udGFsJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVUERBVEUgQlkgT1RIRVIgT1BFUkFUSU9OXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIGNyb3AgY2hhbmdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQ3JvcE9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q3JvcCAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5wdXREaW1lbnNpb25zID0gdGhpcy5fc2RrLmdldElucHV0RGltZW5zaW9ucygpXG5cbiAgICBjb25zdCBvbGRTdGFydCA9IG9wZXJhdGlvbi5nZXRTdGFydCgpXG4gICAgY29uc3QgbmV3U3RhcnQgPSBvcHRpb25zLnN0YXJ0XG5cbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguZm9yRWFjaENvbnRyb2xQb2ludCgoY29udHJvbFBvaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29udHJvbFBvaW50LmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgICBjb250cm9sUG9pbnQuc2V0UG9zaXRpb24oXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICAgIG9sZFN0YXJ0LmNsb25lKCkuc3VidHJhY3QobmV3U3RhcnQpLm11bHRpcGx5KGlucHV0RGltZW5zaW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKVxuICAgIHRoaXMuY2xlYXJCcnVzaENhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gcm90YXRpb24gY2hhbmdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuUm90YXRpb25PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseVJvdGF0aW9uIChvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpXG4gICAgY29uc3QgbmV3Um90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uXG4gICAgY29uc3QgZGVncmVlc0RpZmZlcmVuY2UgPSBuZXdSb3RhdGlvbiAtIG9sZFJvdGF0aW9uXG5cbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSB0aGlzLl9zZGsuZ2V0RmluYWxEaW1lbnNpb25zKClcbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguZm9yRWFjaENvbnRyb2xQb2ludCgoY29udHJvbFBvaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gY29udHJvbFBvaW50LmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgICBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IDkwIHx8IChvbGRSb3RhdGlvbiA9PT0gMjcwICYmIG5ld1JvdGF0aW9uID09PSAwKSkge1xuICAgICAgICAgIHBvc2l0aW9uLmZsaXAoKVxuICAgICAgICAgIHBvc2l0aW9uLnggPSBmaW5hbERpbWVuc2lvbnMueSAtIHBvc2l0aW9uLnhcbiAgICAgICAgfSBlbHNlIGlmIChkZWdyZWVzRGlmZmVyZW5jZSA9PT0gLTkwIHx8IChvbGRSb3RhdGlvbiA9PT0gLTI3MCAmJiBuZXdSb3RhdGlvbiA9PT0gMCkpIHtcbiAgICAgICAgICBwb3NpdGlvbi5mbGlwKClcbiAgICAgICAgICBwb3NpdGlvbi55ID0gZmluYWxEaW1lbnNpb25zLnggLSBwb3NpdGlvbi55XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbFBvaW50LnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlLCB0cnVlKVxuICAgIHRoaXMuY2xlYXJCcnVzaENhbnZhcygpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBhIGZsaXAgd2l0aCB0aGUgZ2l2ZW4gZGlyZWN0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGlyZWN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlGbGlwIChvcGVyYXRpb24sIGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHJvdGF0aW9uID0gb3BlcmF0aW9uLmdldFJvdGF0aW9uKClcbiAgICBpZiAocm90YXRpb24gPT09IDkwIHx8IHJvdGF0aW9uID09PSAyNzApIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2hvcml6b250YWwnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJlY3Rpb24gPSAndmVydGljYWwnXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gdGhpcy5fc2RrLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgdGhpcy5fb3B0aW9ucy5wYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBwYXRoLmZvckVhY2hDb250cm9sUG9pbnQoKGNvbnRyb2xQb2ludCkgPT4ge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbnRyb2xQb2ludC5nZXRQb3NpdGlvbigpLmNsb25lKClcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgIHBvc2l0aW9uLnggPSBmaW5hbERpbWVuc2lvbnMueCAtIHBvc2l0aW9uLnhcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICAgICAgcG9zaXRpb24ueSA9IGZpbmFsRGltZW5zaW9ucy55IC0gcG9zaXRpb24ueVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sUG9pbnQuc2V0UG9zaXRpb24ocG9zaXRpb24pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLnNldERpcnR5KHRydWUsIHRydWUpXG4gICAgdGhpcy5jbGVhckJydXNoQ2FudmFzKClcbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFJFTkRFUklOR1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBicnVzaCBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQG92ZXJyaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICB0aGlzLnJlbmRlckJydXNoQ2FudmFzKHNkaylcblxuICAgIGNvbnN0IHJlbmRlcmVyID0gc2RrLmdldFJlbmRlcmVyKClcbiAgICBjb25zdCBvdXRwdXRTcHJpdGUgPSBzZGsuZ2V0U3ByaXRlKClcbiAgICB0aGlzLl9pbnB1dFNwcml0ZS5zZXRUZXh0dXJlKG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgcmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0aGlzLl90ZXh0dXJlLmdldEJhc2VUZXh0dXJlKCkpXG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHRoaXMuX2dldFJlbmRlclRleHR1cmUoc2RrKVxuICAgIGNvbnN0IG91dHB1dEJvdW5kcyA9IG91dHB1dFNwcml0ZS5nZXRCb3VuZHMoKVxuICAgIHJlbmRlclRleHR1cmUucmVzaXplVG8obmV3IFZlY3RvcjIob3V0cHV0Qm91bmRzLndpZHRoLCBvdXRwdXRCb3VuZHMuaGVpZ2h0KSlcblxuICAgIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcbiAgICBvdXRwdXRTcHJpdGUuc2V0VGV4dHVyZShyZW5kZXJUZXh0dXJlKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBicnVzaCBjYW52YXNcbiAgICovXG4gIGNsZWFyQnJ1c2hDYW52YXMgKCkge1xuICAgIGlmICghdGhpcy5fYnJ1c2hDYW52YXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2JydXNoQ2FudmFzRGlydHkgPSB0cnVlXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fYnJ1c2hDYW52YXNcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgYnJ1c2ggY2FudmFzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGEgdGV4dHVyZSBpbiBXZWJHTFxuICAgKiBhbmQgYXMgYW4gaW1hZ2UgaW4gY2FudmFzXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVuZGVyQnJ1c2hDYW52YXMgKHNkaywgY2FudmFzID0gdGhpcy5fYnJ1c2hDYW52YXMpIHtcbiAgICBjb25zdCBmaW5hbERpbWVuc2lvbnMgPSBzZGsuZ2V0RmluYWxEaW1lbnNpb25zKClcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSBmaW5hbERpbWVuc2lvbnMueCB8fFxuICAgICAgICBjYW52YXMuaGVpZ2h0ICE9PSBmaW5hbERpbWVuc2lvbnMueSkge1xuICAgICAgY2FudmFzLndpZHRoID0gZmluYWxEaW1lbnNpb25zLnhcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBmaW5hbERpbWVuc2lvbnMueVxuICAgICAgdGhpcy5fdGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpLnVwZGF0ZSgpXG4gICAgfVxuXG4gICAgY29uc3QgcGF0aHMgPSB0aGlzLl9vcHRpb25zLnBhdGhzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldXG4gICAgICBwYXRoLnJlbmRlclRvQ2FudmFzKGNhbnZhcylcbiAgICB9XG4gICAgdGhpcy5fYnJ1c2hDYW52YXNEaXJ0eSA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIG5ldyBwYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aGlja25lc3NcbiAgICogQHBhcmFtIHtDb2xvcn0gY29sb3JcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvbi5QYXRofVxuICAgKi9cbiAgY3JlYXRlUGF0aCAodGhpY2tuZXNzLCBjb2xvcikge1xuICAgIGNvbnN0IHBhdGggPSBuZXcgQnJ1c2hPcGVyYXRpb24uUGF0aCh0aGlzLCB0aGlja25lc3MsIGNvbG9yKVxuICAgIHBhdGgub24oJ3VwZGF0ZScsIHRoaXMuX29uUGF0aFVwZGF0ZSlcbiAgICB0aGlzLl9vcHRpb25zLnBhdGhzLnB1c2gocGF0aClcbiAgICB0aGlzLnNldERpcnR5KHRydWUpXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkaXJ0aW5lc3MgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5XG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuRW5naW5lLkJhc2VSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2V0UGF0aHNUb0RpcnR5ID0gZmFsc2VdXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0RGlydHlGb3JSZW5kZXJlciAoZGlydHksIHJlbmRlcmVyLCBzZXRQYXRoc1RvRGlydHkgPSBmYWxzZSkge1xuICAgIHN1cGVyLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyKVxuXG4gICAgaWYgKHNldFBhdGhzVG9EaXJ0eSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy5wYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgIHBhdGguc2V0RGlydHkoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciBhbGwgcmVuZGVyZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2V0UGF0aHNUb0RpcnR5ID0gZmFsc2VdXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc2V0RGlydHkgKGRpcnR5LCBzZXRQYXRoc1RvRGlydHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHJlbmRlcmVySWQgaW4gdGhpcy5fZGlydGluZXNzKSB7XG4gICAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHsgaWQ6IHJlbmRlcmVySWQgfSwgc2V0UGF0aHNUb0RpcnR5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlcyB0aGlzIG9wZXJhdGlvblxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGRpc3Bvc2UgKCkge1xuICAgIHRoaXMuX3Nkay5vZmYoQ29uc3RhbnRzLkV2ZW50cy5PUEVSQVRJT05fVVBEQVRFRCwgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUpXG4gIH1cbn1cblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQnJ1c2hPcGVyYXRpb24uaWRlbnRpZmllciA9ICdicnVzaCdcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQnJ1c2hPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHRoaWNrbmVzczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMTAgfSxcbiAgY29sb3I6IHsgdHlwZTogJ2NvbG9yJywgZGVmYXVsdDogbmV3IENvbG9yKDEsIDAsIDAsIDEpIH0sXG4gIHBhdGhzOiB7IHR5cGU6ICdhcnJheScsIGRlZmF1bHQ6IFtdLCBzZXR0ZXI6IGZ1bmN0aW9uIChwYXRocykge1xuICAgIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgIHBhdGguc2V0RGlydHkodHJ1ZSlcbiAgICB9KVxuICAgIHRoaXMuY2xlYXJCcnVzaENhbnZhcygpXG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICAgIHJldHVybiBwYXRoc1xuICB9fVxufVxuXG5CcnVzaE9wZXJhdGlvbi5QYXRoID0gUGF0aFxuQnJ1c2hPcGVyYXRpb24uQ29udHJvbFBvaW50ID0gQ29udHJvbFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IEJydXNoT3BlcmF0aW9uXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvYnJ1c2gtb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBDb250cm9sUG9pbnQgZnJvbSAnLi9jb250cm9sLXBvaW50J1xuXG4vKipcbiAqIEEgcGF0aCB0aGF0IGNhbiBiZSBkcmF3biBvbiBhIHtAbGluayBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9ufS4gU2hvdWxkIG9ubHkgYmVcbiAqIGNyZWF0ZWQgdXNpbmcge0BsaW5rIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb24jY3JlYXRlUGF0aH1cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRXZlbnRFbWl0dGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5CcnVzaE9wZXJhdGlvblxuICovXG5jbGFzcyBQYXRoIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQYXRoXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRoaWNrbmVzc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5Db2xvcn0gY29sb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yIChvcGVyYXRpb24sIHRoaWNrbmVzcywgY29sb3IpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fdGhpY2tuZXNzID0gdGhpY2tuZXNzXG4gICAgdGhpcy5fY29sb3IgPSBjb2xvclxuICAgIHRoaXMuX2NvbnRyb2xQb2ludHMgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoaXMgcGF0aCBvbnRvIHRoZSBnaXZlbiBjYW52YXNcbiAgICogQHBhcmFtICB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICAgKi9cbiAgcmVuZGVyVG9DYW52YXMgKGNhbnZhcykge1xuICAgIGlmICh0aGlzLl9jb250cm9sUG9pbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBsYXN0Q29udHJvbFBvaW50ID0gdGhpcy5fY29udHJvbFBvaW50c1swXVxuICAgIGxldCBjb250cm9sUG9pbnQgPSBsYXN0Q29udHJvbFBvaW50XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl9jb250cm9sUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb250cm9sUG9pbnQgPSB0aGlzLl9jb250cm9sUG9pbnRzW2ldXG4gICAgICBjb250cm9sUG9pbnQucmVuZGVyVG9DYW52YXMoY2FudmFzLCBsYXN0Q29udHJvbFBvaW50KVxuICAgICAgbGFzdENvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29udHJvbCBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKi9cbiAgYWRkQ29udHJvbFBvaW50IChwb3NpdGlvbikge1xuICAgIGNvbnN0IGNvbnRyb2xQb2ludCA9IG5ldyBDb250cm9sUG9pbnQodGhpcywgcG9zaXRpb24pXG4gICAgdGhpcy5fY29udHJvbFBvaW50cy5wdXNoKGNvbnRyb2xQb2ludClcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGF0aCBjb2xvclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5Db2xvcn1cbiAgICovXG4gIGdldENvbG9yICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXRoJ3Mgc3Ryb2tlIHRoaWNrbmVzc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRUaGlja25lc3MgKCkge1xuICAgIHJldHVybiB0aGlzLl90aGlja25lc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgcGF0aCdzIGNvbnRyb2wgcG9pbnRzXG4gICAqIEByZXR1cm4ge0FycmF5LjxQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLkJydXNoT3BlcmF0aW9uLkNvbnRyb2xQb2ludD59XG4gICAqL1xuICBnZXRDb250cm9sUG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbFBvaW50c1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBwYXRoIHRvIGRpcnR5XG4gICAqL1xuICBzZXREaXJ0eSAoKSB7XG4gICAgdGhpcy5fY29udHJvbFBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgcG9pbnQuc2V0RGlydHkoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgYGl0ZXJhdG9yYCBmb3IgZWFjaCBjb250cm9sIHBvaW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKi9cbiAgZm9yRWFjaENvbnRyb2xQb2ludCAoaXRlcmF0b3IpIHtcbiAgICB0aGlzLl9jb250cm9sUG9pbnRzLmZvckVhY2goaXRlcmF0b3IpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUGF0aFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2JydXNoL3BhdGguanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFZlY3RvcjIgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBjcm9wIG91dCBhIHBhcnQgb2YgdGhlIGltYWdlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgQ3JvcE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENyb3BPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLCAwKVxuXG4gICAgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUgPSB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fc2RrLm9uKENvbnN0YW50cy5FdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQuIElmIHRoZSBjcm9wXG4gICAqIG9yIHJvdGF0aW9uIG9wZXJhdGlvbiBpcyB1cGRhdGVkLCB0aGlzIHdpbGwgYmUgcmVjb2duaXplZCBhbmQgdGhlXG4gICAqIGNyb3Agd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZ2x5XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlcmF0aW9uVXBkYXRlIChvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkZW50aWZpZXIgfSA9IG9wZXJhdGlvbi5jb25zdHJ1Y3RvclxuXG4gICAgaWYgKGlkZW50aWZpZXIgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgIGlmICgncm90YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlSb3RhdGlvbihvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgICBpZiAoJ2ZsaXBWZXJ0aWNhbGx5JyBpbiBvcHRpb25zIHx8ICdmbGlwSG9yaXpvbnRhbGx5JyBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2FwcGx5RmxpcChvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRklYRVNcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcm90YXRpb24gZG9uZSBieSBhbiBvcmllbnRhdGlvbiBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlSb3RhdGlvbiAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY3VycmVudFJvdGF0aW9uID0gb3BlcmF0aW9uLmdldFJvdGF0aW9uKClcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb25cbiAgICBjb25zdCBkZWdyZWVzRGlmZmVyZW5jZSA9IG5ld1JvdGF0aW9uIC0gY3VycmVudFJvdGF0aW9uXG5cbiAgICBsZXQgc3RhcnQgPSB0aGlzLl9vcHRpb25zLnN0YXJ0LmNsb25lKClcbiAgICBsZXQgZW5kID0gdGhpcy5fb3B0aW9ucy5lbmQuY2xvbmUoKVxuXG4gICAgY29uc3QgdGVtcFN0YXJ0ID0gc3RhcnQuY2xvbmUoKVxuICAgIGlmIChkZWdyZWVzRGlmZmVyZW5jZSA9PT0gOTAgfHwgZGVncmVlc0RpZmZlcmVuY2UgPT09IC0yNzApIHtcbiAgICAgIHN0YXJ0LnNldCgxLjAgLSBlbmQueSwgdGVtcFN0YXJ0LngpXG4gICAgICBlbmQuc2V0KDEuMCAtIHRlbXBTdGFydC55LCBlbmQueClcbiAgICB9IGVsc2UgaWYgKGRlZ3JlZXNEaWZmZXJlbmNlID09PSAtOTAgfHwgZGVncmVlc0RpZmZlcmVuY2UgPT09IDI3MCkge1xuICAgICAgc3RhcnQuc2V0KHRlbXBTdGFydC55LCAxLjAgLSBlbmQueClcbiAgICAgIGVuZC5zZXQoZW5kLnksIDEuMCAtIHRlbXBTdGFydC54KVxuICAgIH1cblxuICAgIHRoaXMuc2V0KHsgc3RhcnQsIGVuZCB9LCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBmbGlwIGRvbmUgYnkgYW4gb3JpZW50YXRpb24gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5RmxpcCAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCdmbGlwVmVydGljYWxseScgaW4gb3B0aW9ucyAmJlxuICAgICAgICBvcGVyYXRpb24uZ2V0RmxpcFZlcnRpY2FsbHkoKSAhPT0gb3B0aW9ucy5mbGlwVmVydGljYWxseSkge1xuICAgICAgdGhpcy5fYXBwbHlGbGlwRGlyZWN0aW9uKG9wZXJhdGlvbiwgJ3ZlcnRpY2FsJylcbiAgICB9XG5cbiAgICBpZiAoJ2ZsaXBIb3Jpem9udGFsbHknIGluIG9wdGlvbnMgJiZcbiAgICAgICAgb3BlcmF0aW9uLmdldEZsaXBIb3Jpem9udGFsbHkoKSAhPT0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbGx5KSB7XG4gICAgICB0aGlzLl9hcHBseUZsaXBEaXJlY3Rpb24ob3BlcmF0aW9uLCAnaG9yaXpvbnRhbCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmbGlwIHdpdGggdGhlIGdpdmVuIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5RmxpcERpcmVjdGlvbiAob3BlcmF0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCByb3RhdGlvbiA9IG9wZXJhdGlvbi5nZXRSb3RhdGlvbigpXG4gICAgaWYgKHJvdGF0aW9uID09PSA5MCB8fCByb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICdob3Jpem9udGFsJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ3ZlcnRpY2FsJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydFxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kXG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICAgIGNvbnN0IHRlbXBTdGFydFggPSBzdGFydC54XG4gICAgICAgIHN0YXJ0LnggPSAxIC0gZW5kLnhcbiAgICAgICAgZW5kLnggPSAxIC0gdGVtcFN0YXJ0WFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgICBjb25zdCB0ZW1wU3RhcnRZID0gc3RhcnQueVxuICAgICAgICBzdGFydC55ID0gMSAtIGVuZC55XG4gICAgICAgIGVuZC55ID0gMSAtIHRlbXBTdGFydFlcbiAgICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICB0aGlzLnNldCh7IHN0YXJ0LCBlbmQgfSwgZmFsc2UpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBSRU5ERVJJTkdcblxuICAvKipcbiAgICogQ3JvcHMgdGhlIGltYWdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlciAoc2RrKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaylcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkpXG5cbiAgICBjb25zdCBvdXRwdXRCb3VuZHMgPSBvdXRwdXRTcHJpdGUuZ2V0Qm91bmRzKClcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gbmV3IFZlY3RvcjIob3V0cHV0Qm91bmRzLndpZHRoLCBvdXRwdXRCb3VuZHMuaGVpZ2h0KVxuXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9vcHRpb25zLnN0YXJ0LmNsb25lKClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kLmNsb25lKClcbiAgICAgIC5tdWx0aXBseShvdXRwdXREaW1lbnNpb25zKVxuXG4gICAgY29uc3QgbmV3RGltZW5zaW9ucyA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KS5mbG9vcigpXG4gICAgcmVuZGVyVGV4dHVyZS5yZXNpemVUbyhuZXdEaW1lbnNpb25zKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFBvc2l0aW9uKC1zdGFydC54LCAtc3RhcnQueSlcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcbiAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIodHJ1ZSwgcmVuZGVyZXIpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIHRoZSBnaXZlbiBkaW1lbnNpb25zIHdpbGwgaGF2ZSBhZnRlciB0aGlzIG9wZXJhdGlvblxuICAgKiBoYXMgYmVlbiBhcHBsaWVkXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXROZXdEaW1lbnNpb25zIChkaW1lbnNpb25zKSB7XG4gICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMuY2xvbmUoKVxuXG4gICAgbGV0IG5ld0RpbWVuc2lvbnMgPSB0aGlzLl9vcHRpb25zLmVuZFxuICAgICAgLmNsb25lKClcbiAgICAgIC5zdWJ0cmFjdCh0aGlzLl9vcHRpb25zLnN0YXJ0KVxuXG4gICAgbmV3RGltZW5zaW9ucy5tdWx0aXBseShkaW1lbnNpb25zKVxuXG4gICAgcmV0dXJuIG5ld0RpbWVuc2lvbnNcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Dcm9wT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnY3JvcCdcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQ3JvcE9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgc3RhcnQ6IHsgdHlwZTogJ3ZlY3RvcjInLCByZXF1aXJlZDogdHJ1ZSwgZGVmYXVsdDogbmV3IFZlY3RvcjIoMCwgMCkgfSxcbiAgZW5kOiB7IHR5cGU6ICd2ZWN0b3IyJywgcmVxdWlyZWQ6IHRydWUsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEsIDEpIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ3JvcE9wZXJhdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgUHJvbWlzZSB9IGZyb20gJy4uL2dsb2JhbHMnXG5pbXBvcnQgT3BlcmF0aW9uIGZyb20gJy4vb3BlcmF0aW9uJ1xuaW1wb3J0IElkZW50aXR5RmlsdGVyIGZyb20gJy4vZmlsdGVycy9pZGVudGl0eS1maWx0ZXInXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGFwcGx5IGEgc2VsZWN0ZWQgZmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgRmlsdGVyT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyIChzZGspIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRGaWx0ZXIucmVuZGVyKHNkaywgdGhpcy5fZ2V0UmVuZGVyVGV4dHVyZShzZGspKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHJlbmRlciAoc2RrKSB7XG4gICAgaWYgKCF0aGlzLmdldEVuYWJsZWQoKSB8fCB0aGlzLl9zZWxlY3RlZEZpbHRlci5jb25zdHJ1Y3Rvci5pc0lkZW50aXR5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9XG5cbiAgICBzdXBlci5yZW5kZXIoc2RrKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldERpcnR5Rm9yUmVuZGVyZXIgKGRpcnR5LCByZW5kZXJlcikge1xuICAgIHN1cGVyLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyKVxuICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyLnNldERpcnR5Rm9yUmVuZGVyZXIoZGlydHksIHJlbmRlcmVyKVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZpbHRlck9wZXJhdGlvbi5pZGVudGlmaWVyID0gJ2ZpbHRlcidcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRmlsdGVyT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpbnRlbnNpdHk6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiAxLFxuICAgIHNldHRlcjogZnVuY3Rpb24gKGludGVuc2l0eSkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIgJiZcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuc2V0SW50ZW5zaXR5KGludGVuc2l0eSlcbiAgICAgIHJldHVybiBpbnRlbnNpdHlcbiAgICB9XG4gIH0sXG4gIGZpbHRlcjogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogSWRlbnRpdHlGaWx0ZXIsXG4gICAgc2V0dGVyOiBmdW5jdGlvbiAoRmlsdGVyKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0ZWRGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIuZGlzcG9zZSgpXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyID0gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy5fc2VsZWN0ZWRGaWx0ZXIgPSBuZXcgRmlsdGVyKHRoaXMuX29wdGlvbnMuaW50ZW5zaXR5KVxuICAgICAgcmV0dXJuIEZpbHRlclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBGaWx0ZXJPcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXItb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEExNSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBBMTVGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMC42M1xuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5CcmlnaHRuZXNzKHtcbiAgICAgIGJyaWdodG5lc3M6IDAuMTJcbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDM4XSxcbiAgICAgICAgICBbOTQsIDk0XSxcbiAgICAgICAgICBbMTQ4LCAxNDJdLFxuICAgICAgICAgIFsxNzUsIDE4N10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbNzcsIDUzXSxcbiAgICAgICAgICBbMTcxLCAxOTBdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAxMF0sXG4gICAgICAgICAgWzQ4LCA4NV0sXG4gICAgICAgICAgWzE3NCwgMjI4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkExNUZpbHRlci5pZGVudGlmaWVyID0gJ2ExNSdcblxuQTE1RmlsdGVyLmRpc3BsYXlOYW1lID0gJzE1J1xuXG5leHBvcnQgZGVmYXVsdCBBMTVGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ExNS1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogQnJlZXplIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEJyZWV6ZUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIERlc2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgIGRlc2F0dXJhdGlvbjogMC41XG4gICAgfSkpXG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzE3MCwgMTcwXSxcbiAgICAgICAgICBbMjEyLCAyMTldLFxuICAgICAgICAgIFsyMzQsIDI0Ml0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTcwLCAxNjhdLFxuICAgICAgICAgIFsyMzQsIDIzMV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxNzAsIDE3MF0sXG4gICAgICAgICAgWzIxMiwgMjA4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJyZWV6ZUZpbHRlci5pZGVudGlmaWVyID0gJ2JyZWV6ZSdcblxuQnJlZXplRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0JyZWV6ZSdcblxuZXhwb3J0IGRlZmF1bHQgQnJlZXplRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9icmVlemUtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEJXIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEJXRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5HcmF5c2NhbGUoKSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJXRmlsdGVyLmlkZW50aWZpZXIgPSAnYncnXG5cbkJXRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0ImVydcblxuZXhwb3J0IGRlZmF1bHQgQldGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3LWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBCV0hhcmQgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgQldIYXJkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5HcmF5c2NhbGUoKSlcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkJXSGFyZEZpbHRlci5pZGVudGlmaWVyID0gJ2J3aGFyZCdcblxuQldIYXJkRmlsdGVyLmRpc3BsYXlOYW1lID0gJzE5MjAnXG5cbmV4cG9ydCBkZWZhdWx0IEJXSGFyZEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvYndoYXJkLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBDZWxzaXVzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIENlbHNpdXNGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNjldLFxuICAgICAgICAgIFs1NSwgMTEwXSxcbiAgICAgICAgICBbMjAyLCAyMzBdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgNDRdLFxuICAgICAgICAgIFs4OSwgOTNdLFxuICAgICAgICAgIFsxODUsIDE0MV0sXG4gICAgICAgICAgWzI1NSwgMTg5XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDc2XSxcbiAgICAgICAgICBbMzksIDgyXSxcbiAgICAgICAgICBbMjE4LCAxMzhdLFxuICAgICAgICAgIFsyNTUsIDE3MV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuQ2Vsc2l1c0ZpbHRlci5pZGVudGlmaWVyID0gJ2NlbHNpdXMnXG5cbkNlbHNpdXNGaWx0ZXIuZGlzcGxheU5hbWUgPSAnQ2Vsc2l1cydcblxuZXhwb3J0IGRlZmF1bHQgQ2Vsc2l1c0ZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2Vsc2l1cy1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogQ2hlc3QgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgQ2hlc3RGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0NCwgNDRdLFxuICAgICAgICAgIFsxMjQsIDE0M10sXG4gICAgICAgICAgWzIyMSwgMjA0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMzAsIDEyN10sXG4gICAgICAgICAgWzIxMywgMTk5XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzUxLCA1Ml0sXG4gICAgICAgICAgWzIxOSwgMjA0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkNoZXN0RmlsdGVyLmlkZW50aWZpZXIgPSAnY2hlc3QnXG5cbkNoZXN0RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0NoZXN0J1xuXG5leHBvcnQgZGVmYXVsdCBDaGVzdEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2hlc3QtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEZpeGllIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEZpeGllRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs0NCwgMjhdLFxuICAgICAgICAgIFs2MywgNDhdLFxuICAgICAgICAgIFsxMjgsIDEzMl0sXG4gICAgICAgICAgWzIzNSwgMjQ4XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsyMCwgMTBdLFxuICAgICAgICAgIFs2MCwgNDVdLFxuICAgICAgICAgIFsxOTAsIDIwOV0sXG4gICAgICAgICAgWzIxMSwgMjMxXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMzFdLFxuICAgICAgICAgIFs0MSwgNjJdLFxuICAgICAgICAgIFsxNTAsIDE0Ml0sXG4gICAgICAgICAgWzIzNCwgMjEyXSxcbiAgICAgICAgICBbMjU1LCAyMjRdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZpeGllRmlsdGVyLmlkZW50aWZpZXIgPSAnZml4aWUnXG5cbkZpeGllRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0ZpeGllJ1xuXG5leHBvcnQgZGVmYXVsdCBGaXhpZUZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZml4aWUtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEZvb2QgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgRm9vZEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgc2F0dXJhdGlvbjogMS4zNVxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICBjb250cmFzdDogMS4xXG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Gb29kRmlsdGVyLmlkZW50aWZpZXIgPSAnZm9vZCdcblxuRm9vZEZpbHRlci5kaXNwbGF5TmFtZSA9ICdGb29kJ1xuXG5leHBvcnQgZGVmYXVsdCBGb29kRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9mb29kLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBGcmlkZ2UgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgRnJpZGdlRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDldLFxuICAgICAgICAgIFsyMSwgMTFdLFxuICAgICAgICAgIFs0NSwgMjRdLFxuICAgICAgICAgIFsyNTUsIDIyMF1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMTJdLFxuICAgICAgICAgIFsyMSwgMjFdLFxuICAgICAgICAgIFs0MiwgNDJdLFxuICAgICAgICAgIFsxNTAsIDE1MF0sXG4gICAgICAgICAgWzE3MCwgMTczXSxcbiAgICAgICAgICBbMjU1LCAyMTBdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMjhdLFxuICAgICAgICAgIFs0MywgNzJdLFxuICAgICAgICAgIFsxMjgsIDE4NV0sXG4gICAgICAgICAgWzI1NSwgMjIwXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5GcmlkZ2VGaWx0ZXIuaWRlbnRpZmllciA9ICdmcmlkZ2UnXG5cbkZyaWRnZUZpbHRlci5kaXNwbGF5TmFtZSA9ICdGcmlkZ2UnXG5cbmV4cG9ydCBkZWZhdWx0IEZyaWRnZUZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZnJpZGdlLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBGcm9udCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBGcm9udEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCA2NV0sXG4gICAgICAgICAgWzI4LCA2N10sXG4gICAgICAgICAgWzY3LCAxMTNdLFxuICAgICAgICAgIFsxMjUsIDE4M10sXG4gICAgICAgICAgWzE4NywgMjE3XSxcbiAgICAgICAgICBbMjU1LCAyMjldXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNDIsIDU5XSxcbiAgICAgICAgICBbMTA0LCAxMzRdLFxuICAgICAgICAgIFsxNjksIDIwOV0sXG4gICAgICAgICAgWzI1NSwgMjQwXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDUyXSxcbiAgICAgICAgICBbNjUsIDY4XSxcbiAgICAgICAgICBbOTMsIDEwNF0sXG4gICAgICAgICAgWzE1MCwgMTUzXSxcbiAgICAgICAgICBbMjU1LCAxOThdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkZyb250RmlsdGVyLmlkZW50aWZpZXIgPSAnZnJvbnQnXG5cbkZyb250RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0Zyb250J1xuXG5leHBvcnQgZGVmYXVsdCBGcm9udEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZnJvbnQtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEdsYW0gRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgR2xhbUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgY29udHJhc3Q6IDEuMVxuICAgIH0pKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzk0LCA3NF0sXG4gICAgICAgICAgWzE4MSwgMjA1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMjcsIDEyN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMDIsIDczXSxcbiAgICAgICAgICBbMjI3LCAyMTNdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuR2xhbUZpbHRlci5pZGVudGlmaWVyID0gJ2dsYW0nXG5cbkdsYW1GaWx0ZXIuZGlzcGxheU5hbWUgPSAnR2xhbSdcblxuZXhwb3J0IGRlZmF1bHQgR2xhbUZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ2xhbS1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogR29iYmxpbiBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBHb2JibGluRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Hb2JibGluKCkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Hb2JibGluRmlsdGVyLmlkZW50aWZpZXIgPSAnZ29iYmxpbidcblxuR29iYmxpbkZpbHRlci5kaXNwbGF5TmFtZSA9ICdHb2JibGluJ1xuXG5leHBvcnQgZGVmYXVsdCBHb2JibGluRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9nb2JibGluLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBLMSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBLMUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzUzLCAzMl0sXG4gICAgICAgIFs5MSwgODBdLFxuICAgICAgICBbMTc2LCAyMDVdLFxuICAgICAgICBbMjU1LCAyNTVdXG4gICAgICBdXG4gICAgfSkpXG5cbiAgICAvLyBTYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5TYXR1cmF0aW9uKHtcbiAgICAgIHNhdHVyYXRpb246IDAuOVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuSzFGaWx0ZXIuaWRlbnRpZmllciA9ICdrMSdcblxuSzFGaWx0ZXIuZGlzcGxheU5hbWUgPSAnSzEnXG5cbmV4cG9ydCBkZWZhdWx0IEsxRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9rMS1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vbGliL2NvbG9yJ1xuXG4vKipcbiAqIEsyIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEsyRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbNTQsIDMzXSxcbiAgICAgICAgWzc3LCA4Ml0sXG4gICAgICAgIFs5NCwgMTAzXSxcbiAgICAgICAgWzEyMiwgMTI2XSxcbiAgICAgICAgWzE3NywgMTkzXSxcbiAgICAgICAgWzIyOSwgMjMyXSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKVxuXG4gICAgLy8gU29mdCBjb2xvciBvdmVybGF5XG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Tb2Z0Q29sb3JPdmVybGF5KHtcbiAgICAgIGNvbG9yOiBuZXcgQ29sb3IoNDAgLyAyNTUsIDQwIC8gMjU1LCA0MCAvIDI1NSlcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbksyRmlsdGVyLmlkZW50aWZpZXIgPSAnazInXG5cbksyRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0syJ1xuXG5leHBvcnQgZGVmYXVsdCBLMkZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvazItZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEs2IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEs2RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbks2RmlsdGVyLmlkZW50aWZpZXIgPSAnazYnXG5cbks2RmlsdGVyLmRpc3BsYXlOYW1lID0gJ0s2J1xuXG5leHBvcnQgZGVmYXVsdCBLNkZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvazYtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIEtEeW5hbWljIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIEtEeW5hbWljRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gVG9uZSBjdXJ2ZVxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIGNvbnRyb2xQb2ludHM6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMTcsIDI3XSxcbiAgICAgICAgWzQ2LCA2OV0sXG4gICAgICAgIFs5MCwgMTEyXSxcbiAgICAgICAgWzE1NiwgMjAwXSxcbiAgICAgICAgWzIwMywgMjQzXSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKVxuXG4gICAgLy8gU2F0dXJhdGlvblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjdcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbktEeW5hbWljRmlsdGVyLmlkZW50aWZpZXIgPSAna2R5bmFtaWMnXG5cbktEeW5hbWljRmlsdGVyLmRpc3BsYXlOYW1lID0gJ0tEeW5hbWljJ1xuXG5leHBvcnQgZGVmYXVsdCBLRHluYW1pY0ZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIExlbmluIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIExlbmluRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjRcbiAgICB9KSlcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzEwNiwgMTExXSxcbiAgICAgICAgICBbMTI5LCAxNTNdLFxuICAgICAgICAgIFsxOTAsIDIyM10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzQwLCAyMF0sXG4gICAgICAgICAgWzYyLCA0MV0sXG4gICAgICAgICAgWzEwNiwgMTA4XSxcbiAgICAgICAgICBbMTMyLCAxNTldLFxuICAgICAgICAgIFsyMDMsIDIzN10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDQwXSxcbiAgICAgICAgICBbNDAsIDQwXSxcbiAgICAgICAgICBbNzMsIDYwXSxcbiAgICAgICAgICBbMTMzLCAxNjBdLFxuICAgICAgICAgIFsxOTEsIDI5N10sXG4gICAgICAgICAgWzIwMywgMjM3XSxcbiAgICAgICAgICBbMjM3LCAyMzldLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuTGVuaW5GaWx0ZXIuaWRlbnRpZmllciA9ICdsZW5pbidcblxuTGVuaW5GaWx0ZXIuZGlzcGxheU5hbWUgPSAnTGVuaW4nXG5cbmV4cG9ydCBkZWZhdWx0IExlbmluRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9sZW5pbi1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogTG9tbyBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBMb21vRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgY29udHJvbFBvaW50czogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFs4NywgMjBdLFxuICAgICAgICBbMTMxLCAxNTZdLFxuICAgICAgICBbMTgzLCAyMDVdLFxuICAgICAgICBbMjU1LCAyMDBdXG4gICAgICBdXG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5Mb21vRmlsdGVyLmlkZW50aWZpZXIgPSAnbG9tbydcblxuTG9tb0ZpbHRlci5kaXNwbGF5TmFtZSA9ICdMb21vJ1xuXG5leHBvcnQgZGVmYXVsdCBMb21vRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9sb21vLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBNZWxsb3cgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgTWVsbG93RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzQxLCA4NF0sXG4gICAgICAgICAgWzg3LCAxMzRdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzI1NSwgMjE2XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsyNTUsIDEzMV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuTWVsbG93RmlsdGVyLmlkZW50aWZpZXIgPSAnbWVsbG93J1xuXG5NZWxsb3dGaWx0ZXIuZGlzcGxheU5hbWUgPSAnTWVsbG93J1xuXG5leHBvcnQgZGVmYXVsdCBNZWxsb3dGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogTW9ybmluZyBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBNb3JuaW5nRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNDBdLFxuICAgICAgICAgIFsyNTUsIDIzMF1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMTBdLFxuICAgICAgICAgIFsyNTUsIDIyNV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAyMF0sXG4gICAgICAgICAgWzI1NSwgMTgxXVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkdsb3coKSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbk1vcm5pbmdGaWx0ZXIuaWRlbnRpZmllciA9ICdtb3JuaW5nJ1xuXG5Nb3JuaW5nRmlsdGVyLmRpc3BsYXlOYW1lID0gJ01vcm5pbmcnXG5cbmV4cG9ydCBkZWZhdWx0IE1vcm5pbmdGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIE9yY2hpZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBPcmNoaWRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzExNSwgMTMwXSxcbiAgICAgICAgICBbMTk1LCAyMTVdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzE0OCwgMTUzXSxcbiAgICAgICAgICBbMTcyLCAyMTVdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCA0Nl0sXG4gICAgICAgICAgWzU4LCA3NV0sXG4gICAgICAgICAgWzE3OCwgMjA1XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcblxuICAgIC8vIFRvbmUgY3VydmVcbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzExNywgMTUxXSxcbiAgICAgICAgWzE4OSwgMjE3XSxcbiAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgXVxuICAgIH0pKVxuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgfSkpXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbHRlcidzIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5PcmNoaWRGaWx0ZXIuaWRlbnRpZmllciA9ICdvcmNoaWQnXG5cbk9yY2hpZEZpbHRlci5kaXNwbGF5TmFtZSA9ICdPcmNoaWQnXG5cbmV4cG9ydCBkZWZhdWx0IE9yY2hpZEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvb3JjaGlkLWZpbHRlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBGaWx0ZXIgZnJvbSAnLi9maWx0ZXInXG5pbXBvcnQgKiBhcyBGaWx0ZXJQcmltaXRpdmVzIGZyb20gJy4vcHJpbWl0aXZlcydcblxuLyoqXG4gKiBQb2xhIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFBvbGFGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgIHJlZDogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbOTQsIDc0XSxcbiAgICAgICAgICBbMTgxLCAyMDVdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgZ3JlZW46IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzM0LCAzNF0sXG4gICAgICAgICAgWzk5LCA3Nl0sXG4gICAgICAgICAgWzE3NiwgMTkwXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGJsdWU6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzEwMiwgNzNdLFxuICAgICAgICAgIFsyMjcsIDIxM10sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgc2F0dXJhdGlvbjogMC44XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkNvbnRyYXN0KHtcbiAgICAgIGNvbnRyYXN0OiAxLjVcbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblBvbGFGaWx0ZXIuaWRlbnRpZmllciA9ICdwb2xhJ1xuXG5Qb2xhRmlsdGVyLmRpc3BsYXlOYW1lID0gJ1BvbGEgU1gnXG5cbmV4cG9ydCBkZWZhdWx0IFBvbGFGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGEtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFBvbGE2NjkgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgUG9sYTY2OUZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFs1NiwgMThdLFxuICAgICAgICAgIFsxOTYsIDIwOV0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCAzOF0sXG4gICAgICAgICAgWzcxLCA4NF0sXG4gICAgICAgICAgWzI1NSwgMjU1XVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDBdLFxuICAgICAgICAgIFsxMzEsIDEzM10sXG4gICAgICAgICAgWzIwNCwgMjExXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICB9KSlcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgY29udHJhc3Q6IDEuNVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuUG9sYTY2OUZpbHRlci5pZGVudGlmaWVyID0gJ3BvbGE2NjknXG5cblBvbGE2NjlGaWx0ZXIuZGlzcGxheU5hbWUgPSAnUG9sYSA2NjknXG5cbmV4cG9ydCBkZWZhdWx0IFBvbGE2NjlGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGE2NjktZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVmVjdG9yMiwgRW5naW5lIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL3ZlbmRvci9wcm9taXNlJ1xuXG5jbGFzcyBCbGVuZEZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZ2VuZXJpYy9ibGVuZC5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQ2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLkVuZ2luZS5SZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgeyBmaWx0ZXJlZENhbnZhcyB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgb3V0cHV0Q29udGV4dC5zYXZlKClcbiAgICBvdXRwdXRDb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIDApXG4gICAgb3V0cHV0Q29udGV4dC5nbG9iYWxBbHBoYSA9IHRoaXMuX29wdGlvbnMuaW50ZW5zaXR5XG4gICAgb3V0cHV0Q29udGV4dC5kcmF3SW1hZ2UoZmlsdGVyZWRDYW52YXMsIDAsIDApXG4gICAgb3V0cHV0Q29udGV4dC5yZXN0b3JlKClcbiAgfVxufVxuXG5CbGVuZEZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgZmlsdGVyZWRJbWFnZTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMSwgdW5pZm9ybVR5cGU6ICdpJyB9LFxuICBmaWx0ZXJlZENhbnZhczogeyB0eXBlOiAnb2JqZWN0JywgZGVmYXVsdDogbnVsbCB9LFxuICBpbnRlbnNpdHk6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiAnZicgfVxufVxuXG4vKipcbiAqIEEgaGVscGVyIGNsYXNzIHRoYXQgY2FuIGNvbGxlY3Qge0BsaW5rIFByaW1pdGl2ZX0gaW5zdGFuY2VzIGFuZCByZW5kZXJcbiAqIHRoZSBzdGFja1xuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKi9cbmNsYXNzIFByaW1pdGl2ZXNTdGFjayB7XG4gIGNvbnN0cnVjdG9yIChpbnRlbnNpdHkgPSAxKSB7XG4gICAgdGhpcy5faW50ZW5zaXR5ID0gaW50ZW5zaXR5XG5cbiAgICB0aGlzLl9zdGFjayA9IFtdXG4gICAgdGhpcy5fZGlydGluZXNzID0ge31cbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlcyA9IHt9XG4gICAgdGhpcy5fY29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxuICAgIHRoaXMuX3Nwcml0ZSA9IG5ldyBFbmdpbmUuU3ByaXRlKClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fc3ByaXRlKVxuXG4gICAgdGhpcy5fYmxlbmRGaWx0ZXIgPSBuZXcgQmxlbmRGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIHByaW1pdGl2ZSB0byB0aGUgc3RhY2tcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5GaWx0ZXIuUHJpbWl0aXZlfSBwcmltaXRpdmVcbiAgICovXG4gIHB1c2ggKHByaW1pdGl2ZSkge1xuICAgIHRoaXMuX3N0YWNrLnB1c2gocHJpbWl0aXZlKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgc3RhY2tcbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLl9zdGFjayA9IFtdXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHN0YWNrXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuRW5naW5lLlJlbmRlclRleHR1cmV9IG91dHB1dFRleHR1cmVcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgdGFrZXMgdGhlIG91dHB1dCBzcHJpdGUncyBjdXJyZW50IHRleHR1cmUgYW5kIHJlbmRlcnNcbiAgICogICAgICAgICAgICAgIGl0IHRvIHRoaXMgc3RhY2sncyBpbnRlcm5hbCByZW5kZXIgdGV4dHVyZS4gSXQgdGhlbiB1c2VzIHRoZVxuICAgKiAgICAgICAgICAgICAgaW50ZXJuYWwgdGV4dHVyZSBhcyBhIHVuaWZvcm0gZm9yIGEgYmxlbmQgc2hhZGVyIGFuZCByZW5kZXJzXG4gICAqICAgICAgICAgICAgICB0aGUgc3ByaXRlIHdpdGggdGhlIG9yaWdpbmFsIHRleHR1cmUgYW5kIHRoZSBibGVuZCBzaGFkZXIgdG9cbiAgICogICAgICAgICAgICAgIHRoZSBvdXRwdXRUZXh0dXJlXG4gICAqL1xuICByZW5kZXIgKHNkaywgb3V0cHV0VGV4dHVyZSkge1xuICAgIGlmICh0aGlzLl9zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG5cbiAgICBsZXQgZmlsdGVyZWRSZW5kZXJUZXh0dXJlID0gdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXIuaWRdXG4gICAgaWYgKCFmaWx0ZXJlZFJlbmRlclRleHR1cmUpIHtcbiAgICAgIGZpbHRlcmVkUmVuZGVyVGV4dHVyZSA9XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVzW3JlbmRlcmVyLmlkXSA9IHNkay5jcmVhdGVSZW5kZXJUZXh0dXJlKClcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRTcHJpdGUgPSBzZGsuZ2V0U3ByaXRlKClcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShvdXRwdXRTcHJpdGUuZ2V0VGV4dHVyZSgpKVxuXG4gICAgLy8gUmVzaXplIGJvdGggdGhlIG91dHB1dCBhbmQgdGVtcCB0ZXh0dXJlXG4gICAgY29uc3Qgc3ByaXRlQm91bmRzID0gb3V0cHV0U3ByaXRlLmdldEJvdW5kcygpXG4gICAgY29uc3Qgc3ByaXRlRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKHNwcml0ZUJvdW5kcy53aWR0aCwgc3ByaXRlQm91bmRzLmhlaWdodClcbiAgICBvdXRwdXRUZXh0dXJlLnJlc2l6ZVRvKHNwcml0ZURpbWVuc2lvbnMpXG4gICAgZmlsdGVyZWRSZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKHNwcml0ZURpbWVuc2lvbnMpXG5cbiAgICBpZiAodGhpcy5pc0RpcnR5Rm9yUmVuZGVyZXIocmVuZGVyZXIpKSB7XG4gICAgICAvLyBVcGRhdGUgcHJpbWl0aXZlc1xuICAgICAgdGhpcy5fc3RhY2suZm9yRWFjaCgocCkgPT4gcC51cGRhdGUoc2RrKSlcblxuICAgICAgLy8gU2V0IGZpbHRlcnNcbiAgICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLl9zdGFjay5tYXAoKHApID0+IHAuZ2V0RmlsdGVyKCkpXG4gICAgICB0aGlzLl9zcHJpdGUuc2V0RmlsdGVycyhmaWx0ZXJzKVxuXG4gICAgICAvLyBSZW5kZXIgdG8gUmVuZGVyVGV4dHVyZVxuICAgICAgZmlsdGVyZWRSZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZmFsc2UsIHJlbmRlcmVyKVxuICAgIH1cblxuICAgIC8vIFVzZSBmaWx0ZXJlZFJlbmRlclRleHR1cmUgYXMgdW5pZm9ybSBmb3IgYmxlbmQgc2hhZGVyLCBibGVuZCB0aGUgdHdvXG4gICAgLy8gdG8gYWNoaWV2ZSBpbnRlbnNpdHlcbiAgICB0aGlzLl9ibGVuZEZpbHRlci5zZXRJbnRlbnNpdHkodGhpcy5faW50ZW5zaXR5KVxuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnY2FudmFzJykpIHtcbiAgICAgIHRoaXMuX2JsZW5kRmlsdGVyLnNldEZpbHRlcmVkQ2FudmFzKGZpbHRlcmVkUmVuZGVyVGV4dHVyZS5nZXRSZW5kZXJUYXJnZXQoKS5nZXRDYW52YXMoKSlcbiAgICB9XG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW1xuICAgICAgdGhpcy5fYmxlbmRGaWx0ZXJcbiAgICBdKVxuXG4gICAgY29uc3QgYmFzZVRleHR1cmUgPSBmaWx0ZXJlZFJlbmRlclRleHR1cmUuZ2V0QmFzZVRleHR1cmUoKVxuICAgIGJhc2VUZXh0dXJlLnNldEdMVW5pdCgxKVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAocmVuZGVyZXIuaXNPZlR5cGUoJ3dlYmdsJykpIHtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZVRleHR1cmUoYmFzZVRleHR1cmUsIGZhbHNlKVxuICAgIH1cblxuICAgIG91dHB1dFRleHR1cmUucmVuZGVyKHRoaXMuX2NvbnRhaW5lcilcblxuICAgIG91dHB1dFNwcml0ZS5zZXRUZXh0dXJlKG91dHB1dFRleHR1cmUpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICBzZXRJbnRlbnNpdHkgKGludGVuc2l0eSkgeyB0aGlzLl9pbnRlbnNpdHkgPSBpbnRlbnNpdHkgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBvcGVyYXRpb24gaXMgZGlydHkgZm9yIHRoZSBnaXZlbiByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSAgcmVuZGVyZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRGlydHlGb3JSZW5kZXJlciAocmVuZGVyZXIpIHtcbiAgICBpZiAoIShyZW5kZXJlci5pZCBpbiB0aGlzLl9kaXJ0aW5lc3MpKSB7XG4gICAgICB0aGlzLl9kaXJ0aW5lc3NbcmVuZGVyZXIuaWRdID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpcnRpbmVzcyBmb3IgdGhlIGdpdmVuIHJlbmRlcmVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgc2V0RGlydHlGb3JSZW5kZXJlciAoZGlydHksIHJlbmRlcmVyKSB7XG4gICAgdGhpcy5fZGlydGluZXNzW3JlbmRlcmVyLmlkXSA9IGRpcnR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGlydGluZXNzIGZvciBhbGwgcmVuZGVyZXJzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICovXG4gIHNldERpcnR5IChkaXJ0eSkge1xuICAgIGZvciAobGV0IHJlbmRlcmVySWQgaW4gdGhpcy5fZGlydGluZXNzKSB7XG4gICAgICB0aGlzLl9kaXJ0aW5lc3NbcmVuZGVyZXJJZF0gPSBkaXJ0eVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgZGlzcG9zZSAoKSB7XG4gICAgZm9yIChsZXQgcmVuZGVyZXJJZCBpbiB0aGlzLl9yZW5kZXJUZXh0dXJlcykge1xuICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXJJZF0uZGlzcG9zZSgpXG4gICAgICBkZWxldGUgdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXJJZF1cbiAgICB9XG4gICAgdGhpcy5fc3RhY2suZm9yRWFjaCgocHJpbWl0aXZlKSA9PiBwcmltaXRpdmUuZGlzcG9zZSgpKVxuICAgIHRoaXMuX3N0YWNrID0gW11cbiAgICB0aGlzLl9ibGVuZEZpbHRlci5kaXNwb3NlKClcblxuICAgIHRoaXMuX3Nwcml0ZS5kaXNwb3NlKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcmltaXRpdmVzU3RhY2tcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMtc3RhY2suanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBFbmdpbmUgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcblxuY2xhc3MgQnJpZ2h0bmVzc0ZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9icmlnaHRuZXNzLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGxldCB7IGJyaWdodG5lc3MgfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGlmIChicmlnaHRuZXNzID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3MgKiAyNTVcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0XG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gKz0gYnJpZ2h0bmVzc1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSArPSBicmlnaHRuZXNzXG4gICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICs9IGJyaWdodG5lc3NcbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQnJpZ2h0bmVzc0ZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgYnJpZ2h0bmVzczogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCwgdW5pZm9ybVR5cGU6ICdmJyB9XG59XG5cbi8qKlxuICogQnJpZ2h0bmVzcyBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIEJyaWdodG5lc3MgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IEJyaWdodG5lc3NGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpbHRlcidzIHVuaWZvcm1zXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIHRoaXMuX2ZpbHRlci5zZXRCcmlnaHRuZXNzKHRoaXMuX29wdGlvbnMuYnJpZ2h0bmVzcylcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgcHJpbWl0aXZlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5CcmlnaHRuZXNzLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0gQnJpZ2h0bmVzc0ZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCBCcmlnaHRuZXNzXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2JyaWdodG5lc3MuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4uLy4uLy4uL2VuZ2luZS8nXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuXG5jbGFzcyBDb250cmFzdEZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5mcmFnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoaXMgZmlsdGVyIHRvIHRoZSBnaXZlbiBpbnB1dFRhcmdldCBhbmQgcmVuZGVycyBpdCB0b1xuICAgKiB0aGUgZ2l2ZW4gb3V0cHV0VGFyZ2V0IHVzaW5nIHRoZSBDYW52YXNSZW5kZXJlclxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBpbnB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBjbGVhciA9IGZhbHNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDYW52YXMgKHJlbmRlcmVyLCBpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0LCBjbGVhciA9IGZhbHNlKSB7XG4gICAgY29uc3QgY2FudmFzID0gaW5wdXRUYXJnZXQuZ2V0Q2FudmFzKClcbiAgICBjb25zdCBpbnB1dENvbnRleHQgPSBpbnB1dFRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBvdXRwdXRDb250ZXh0ID0gb3V0cHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICBsZXQgeyBjb250cmFzdCB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGlmIChjb250cmFzdCA9PT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYW52YXMud2lkdGggKiBjYW52YXMuaGVpZ2h0OyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gaSAqIDRcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IChpbWFnZURhdGEuZGF0YVtpbmRleF0gLSAxMjcpICogY29udHJhc3QgKyAxMjdcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAtIDEyNykgKiBjb250cmFzdCArIDEyN1xuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IChpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkNvbnRyYXN0RmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBjb250cmFzdDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMSwgdW5pZm9ybVR5cGU6ICdmJyB9XG59XG5cbi8qKlxuICogQ29udHJhc3QgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBDb250cmFzdCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBDb250cmFzdEZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyLnNldENvbnRyYXN0KHRoaXMuX29wdGlvbnMuY29udHJhc3QpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuQ29udHJhc3QucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSBDb250cmFzdEZpbHRlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9uc1xuXG5leHBvcnQgZGVmYXVsdCBDb250cmFzdFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9jb250cmFzdC5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vLi4vLi4vZW5naW5lLydcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5cbmNsYXNzIERlc2F0dXJhdGlvbkZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgeyBkZXNhdHVyYXRpb24gfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FudmFzLndpZHRoICogY2FudmFzLmhlaWdodDsgaSsrKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGkgKiA0XG4gICAgICB2YXIgbHVtaW5hbmNlID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogMC4zICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIDAuNTkgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4xMVxuICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlICogKDEgLSBkZXNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIGRlc2F0dXJhdGlvbilcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIGRlc2F0dXJhdGlvbilcbiAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIGRlc2F0dXJhdGlvbilcbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIGZpbHRlclxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRGVzYXR1cmF0aW9uRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBkZXNhdHVyYXRpb246IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDEsIHVuaWZvcm1UeXBlOiAnZicgfVxufVxuXG4vKipcbiAqIERlc2F0dXJhdGlvbiBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIERlc2F0dXJhdGlvbiBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBEZXNhdHVyYXRpb25GaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpbHRlcidzIHVuaWZvcm1zXG4gICAqL1xuICB1cGRhdGUgKCkge1xuICAgIHRoaXMuX2ZpbHRlci5zZXREZXNhdHVyYXRpb24odGhpcy5fb3B0aW9ucy5kZXNhdHVyYXRpb24pXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuRGVzYXR1cmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0gRGVzYXR1cmF0aW9uRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zXG5cbmV4cG9ydCBkZWZhdWx0IERlc2F0dXJhdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4uLy4uLy4uL2VuZ2luZSdcbmltcG9ydCBQcmltaXRpdmUgZnJvbSAnLi9wcmltaXRpdmUnXG5pbXBvcnQgQ29sb3IgZnJvbSAnLi4vLi4vLi4vbGliL2NvbG9yJ1xuXG5jbGFzcyBHbG93RmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL2dsb3cuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgY29uc3QgeyBjb2xvciB9ID0gdGhpcy5fb3B0aW9uc1xuXG4gICAgdmFyIGRcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNFxuXG4gICAgICAgIHZhciB4MDEgPSB4IC8gY2FudmFzLndpZHRoXG4gICAgICAgIHZhciB5MDEgPSB5IC8gY2FudmFzLmhlaWdodFxuXG4gICAgICAgIHZhciBueCA9ICh4MDEgLSAwLjUpIC8gMC43NVxuICAgICAgICB2YXIgbnkgPSAoeTAxIC0gMC41KSAvIDAuNzVcblxuICAgICAgICB2YXIgc2NhbGFyWCA9IG54ICogbnhcbiAgICAgICAgdmFyIHNjYWxhclkgPSBueSAqIG55XG4gICAgICAgIGQgPSAxIC0gKHNjYWxhclggKyBzY2FsYXJZKVxuICAgICAgICBkID0gTWF0aC5taW4oTWF0aC5tYXgoZCwgMC4xKSwgMS4wKVxuXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIChkICogY29sb3IucilcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAoZCAqIGNvbG9yLmcpXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogKGQgKiBjb2xvci5iKVxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDNdID0gMjU1XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cbkdsb3dGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbG9yOiB7IHR5cGU6ICdjb2xvcicsIGRlZmF1bHQ6IENvbG9yLldISVRFLCB1bmlmb3JtVHlwZTogJzNmJyB9XG59XG5cbi8qKlxuICogR2xvdyBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIEdsb3cgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgR2xvd0ZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyLnNldENvbG9yKHRoaXMuX29wdGlvbnMuY29sb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuR2xvdy5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IEdsb3dGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgR2xvd1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nbG93LmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUvJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcblxuY2xhc3MgR29iYmxpbkZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0XG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjMzXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuNlxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICs9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMzNcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjdcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSA9IDI1NVxuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG4vKipcbiAqIEdvYmJsaW4gcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlcnMuUHJpbWl0aXZlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBHb2JibGluIGV4dGVuZHMgUHJpbWl0aXZlIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBHb2JibGluRmlsdGVyKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHb2JibGluXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dvYmJsaW4uanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRW5naW5lIGZyb20gJy4uLy4uLy4uL2VuZ2luZS8nXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuXG5jbGFzcyBHcmF5c2NhbGVGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi8uLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0XG5cbiAgICAgICAgdmFyIGx1bWluYW5jZSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMjEyNSArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjcxNTQgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4wNzIxXG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2VcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGx1bWluYW5jZVxuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG4vKipcbiAqIEdyYXlzY2FsZSBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIEdyYXlzY2FsZSBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgR3JheXNjYWxlRmlsdGVyKClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcmF5c2NhbGVcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUvJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcblxuY2xhc3MgU2F0dXJhdGlvbkZpbHRlciBleHRlbmRzIEVuZ2luZS5GaWx0ZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uLy4uL3NoYWRlcnMvcHJpbWl0aXZlcy9zYXR1cmF0aW9uLmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbiAgICBjb25zdCB7IHNhdHVyYXRpb24gfSA9IHRoaXMuX29wdGlvbnNcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0XG5cbiAgICAgICAgdmFyIGx1bWluYW5jZSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMjEyNSArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjcxNTQgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4wNzIxXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogc2F0dXJhdGlvbilcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIHNhdHVyYXRpb24pXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgKGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gKiBzYXR1cmF0aW9uKVxuICAgICAgfVxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMClcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgZmlsdGVyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5TYXR1cmF0aW9uRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBzYXR1cmF0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwLCB1bmlmb3JtVHlwZTogJ2YnIH1cbn1cblxuLyoqXG4gKiBTYXR1cmF0aW9uIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgU2F0dXJhdGlvbiBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBTYXR1cmF0aW9uRmlsdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmaWx0ZXIncyB1bmlmb3Jtc1xuICAgKi9cbiAgdXBkYXRlICgpIHtcbiAgICB0aGlzLl9maWx0ZXIuc2V0U2F0dXJhdGlvbih0aGlzLl9vcHRpb25zLnNhdHVyYXRpb24pXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU2F0dXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IFNhdHVyYXRpb25GaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgU2F0dXJhdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zYXR1cmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUvJ1xuaW1wb3J0IFByaW1pdGl2ZSBmcm9tICcuL3ByaW1pdGl2ZSdcbmltcG9ydCBDb2xvciBmcm9tICcuLi8uLi8uLi9saWIvY29sb3InXG5cbmNsYXNzIFNvZnRDb2xvck92ZXJsYXlGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IHJlcXVpcmUoJ3JhdyEuLi8uLi8uLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc29mdC1jb2xvci1vdmVybGF5LmZyYWcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBjYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0XG5cbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gTWF0aC5tYXgodGhpcy5fb3B0aW9ucy5jb2xvci5yICogMjU1LCBpbWFnZURhdGEuZGF0YVtpbmRleF0pXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLmcgKiAyNTUsIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0pXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLmIgKiAyNTUsIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3V0cHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBmaWx0ZXJcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAaWdub3JlXG4gKi9cblNvZnRDb2xvck92ZXJsYXlGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGNvbG9yOiB7IHR5cGU6ICdjb2xvcicsIGRlZmF1bHQ6IENvbG9yLldISVRFLCB1bmlmb3JtVHlwZTogJzNmJyB9XG59XG5cbi8qKlxuICogU29mdENvbG9yT3ZlcmxheSBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJQcmltaXRpdmVzXG4gKi9cbmNsYXNzIFNvZnRDb2xvck92ZXJsYXkgZXh0ZW5kcyBQcmltaXRpdmUge1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgU29mdENvbG9yT3ZlcmxheUZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZmlsdGVyJ3MgdW5pZm9ybXNcbiAgICovXG4gIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fZmlsdGVyLnNldENvbG9yKHRoaXMuX29wdGlvbnMuY29sb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIHByaW1pdGl2ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU29mdENvbG9yT3ZlcmxheS5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IFNvZnRDb2xvck92ZXJsYXlGaWx0ZXIucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnNcblxuZXhwb3J0IGRlZmF1bHQgU29mdENvbG9yT3ZlcmxheVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgTG9va3VwVGFibGUgZnJvbSAnLi9sb29rdXAtdGFibGUnXG5cbi8qKlxuICogVG9uZSBjdXJ2ZSBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVycy5QcmltaXRpdmVzLkxvb2t1cFRhYmxlXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyUHJpbWl0aXZlc1xuICovXG5jbGFzcyBUb25lQ3VydmUgZXh0ZW5kcyBMb29rdXBUYWJsZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIGlmICghdGhpcy5fb3B0aW9ucy5yZ2JDb250cm9sUG9pbnRzKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMgPSB7XG4gICAgICAgIHJlZDogdGhpcy5fb3B0aW9ucy5jb250cm9sUG9pbnRzLFxuICAgICAgICBncmVlbjogdGhpcy5fb3B0aW9ucy5jb250cm9sUG9pbnRzLFxuICAgICAgICBibHVlOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVMb29rdXBUYWJsZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbG9va3VwIHRhYmxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlTG9va3VwVGFibGUgKCkge1xuICAgIHZhciByID0gdGhpcy5fY2FsY3VsYXRlU3BsaW5lQ3VydmUodGhpcy5fb3B0aW9ucy5yZ2JDb250cm9sUG9pbnRzLnJlZClcbiAgICB2YXIgZyA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5ncmVlbilcbiAgICB2YXIgYiA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5ibHVlKVxuXG4gICAgdGhpcy5fb3B0aW9ucy5kYXRhID0gdGhpcy5fYnVpbGRMb29rdXBUYWJsZShyLCBnLCBiKVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyB0aGUgbG9va3VwIHRhYmxlXG4gICAqIEBwYXJhbSAge0FycmF5fSByXG4gICAqIEBwYXJhbSAge0FycmF5fSBnXG4gICAqIEBwYXJhbSAge0FycmF5fSBiXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkTG9va3VwVGFibGUgKHIsIGcsIGIpIHtcbiAgICB2YXIgZGF0YSA9IFtdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBkYXRhLnB1c2goTWF0aC5taW4oTWF0aC5tYXgoaSArIHJbaV0sIDApLCAyNTUpKVxuICAgICAgZGF0YS5wdXNoKE1hdGgubWluKE1hdGgubWF4KGkgKyBnW2ldLCAwKSwgMjU1KSlcbiAgICAgIGRhdGEucHVzaChNYXRoLm1pbihNYXRoLm1heChpICsgYltpXSwgMCksIDI1NSkpXG4gICAgICBkYXRhLnB1c2goMjU1KVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc3BsaW5lIGN1cnZlIGRhdGEgZm9yIHRoZSBnaXZlbiBwb2ludHNcbiAgICogQHBhcmFtICB7QXJyYXkuPEFycmF5LjxOdW1iZXI+Pn0gcG9pbnRzXG4gICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgKi9cbiAgX2NhbGN1bGF0ZVNwbGluZUN1cnZlIChwb2ludHMpIHtcbiAgICBwb2ludHMgPSBwb2ludHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gPiBiWzBdXG4gICAgfSlcblxuICAgIHZhciBzcGxpbmVQb2ludHMgPSB0aGlzLl9nZXRTcGxpbmVDdXJ2ZShwb2ludHMpXG4gICAgdmFyIGZpcnN0U3BsaW5lUG9pbnQgPSBzcGxpbmVQb2ludHNbMF1cbiAgICB2YXIgaVxuXG4gICAgaWYgKGZpcnN0U3BsaW5lUG9pbnRbMF0gPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlyc3RTcGxpbmVQb2ludFswXTsgaSsrKSB7XG4gICAgICAgIHNwbGluZVBvaW50cy51bnNoaWZ0KFswLCAwXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJlcGFyZWRQb2ludHMgPSBbXVxuICAgIGZvciAoaSA9IDA7IGkgPCBzcGxpbmVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXdQb2ludCA9IHNwbGluZVBvaW50c1tpXVxuICAgICAgdmFyIG9yaWdQb2ludCA9IFtuZXdQb2ludFswXSwgbmV3UG9pbnRbMF1dXG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3cob3JpZ1BvaW50WzBdIC0gbmV3UG9pbnRbMF0sIDIpICtcbiAgICAgICAgTWF0aC5wb3cob3JpZ1BvaW50WzFdIC0gbmV3UG9pbnRbMV0sIDIpXG4gICAgICApXG5cbiAgICAgIGlmIChvcmlnUG9pbnRbMV0gPiBuZXdQb2ludFsxXSkge1xuICAgICAgICBkaXN0YW5jZSA9IC1kaXN0YW5jZVxuICAgICAgfVxuXG4gICAgICBwcmVwYXJlZFBvaW50cy5wdXNoKGRpc3RhbmNlKVxuICAgIH1cblxuICAgIHJldHVybiBwcmVwYXJlZFBvaW50c1xuICB9XG5cbiAgX2dldFNwbGluZUN1cnZlIChwb2ludHMpIHtcbiAgICB2YXIgc2RBID0gdGhpcy5fc2Vjb25kRGVyaXZhdGl2ZShwb2ludHMpXG5cbiAgICB2YXIgbiA9IHNkQS5sZW5ndGhcbiAgICB2YXIgc2QgPSBbXVxuICAgIHZhciBpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzZFtpXSA9IHNkQVtpXVxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBbXVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBwb2ludHNbaV1cbiAgICAgIHZhciBuZXh0ID0gcG9pbnRzW2kgKyAxXVxuXG4gICAgICBmb3IgKHZhciB4ID0gY3VyWzBdOyB4IDwgbmV4dFswXTsgeCsrKSB7XG4gICAgICAgIHZhciB0ID0gKHggLSBjdXJbMF0pIC8gKG5leHRbMF0gLSBjdXJbMF0pXG5cbiAgICAgICAgdmFyIGEgPSAxIC0gdFxuICAgICAgICB2YXIgYiA9IHRcbiAgICAgICAgdmFyIGggPSBuZXh0WzBdIC0gY3VyWzBdXG5cbiAgICAgICAgdmFyIHkgPSBhICogY3VyWzFdICsgYiAqIG5leHRbMV0gKyAoaCAqIGggLyA2KSAqXG4gICAgICAgICAgKChhICogYSAqIGEgLSBhKSAqIHNkW2ldICsgKGIgKiBiICogYiAtIGIpICogc2RbaSArIDFdKVxuXG4gICAgICAgIGlmICh5ID4gMjU1KSB7XG4gICAgICAgICAgeSA9IDI1NVxuICAgICAgICB9IGVsc2UgaWYgKHkgPCAwKSB7XG4gICAgICAgICAgeSA9IDBcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKFt4LCB5XSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMjU1KSB7XG4gICAgICBvdXRwdXQucHVzaChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIF9zZWNvbmREZXJpdmF0aXZlIChwb2ludHMpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgICBpZiAobiA8PSAwIHx8IG4gPT09IDEpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgdmFyIG1hdHJpeCA9IFtdXG4gICAgdmFyIHJlc3VsdCA9IFtdXG4gICAgdmFyIGksIGtcblxuICAgIG1hdHJpeFswXSA9IFswLCAxLCAwXVxuXG4gICAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIHZhciBQMSA9IHBvaW50c1tpIC0gMV1cbiAgICAgIHZhciBQMiA9IHBvaW50c1tpXVxuICAgICAgdmFyIFAzID0gcG9pbnRzW2kgKyAxXVxuXG4gICAgICBtYXRyaXhbaV0gPSBtYXRyaXhbaV0gfHwgW11cbiAgICAgIG1hdHJpeFtpXVswXSA9IChQMlswXSAtIFAxWzBdKSAvIDZcbiAgICAgIG1hdHJpeFtpXVsxXSA9IChQM1swXSAtIFAxWzBdKSAvIDNcbiAgICAgIG1hdHJpeFtpXVsyXSA9IChQM1swXSAtIFAyWzBdKSAvIDZcbiAgICAgIHJlc3VsdFtpXSA9IChQM1sxXSAtIFAyWzFdKSAvIChQM1swXSAtIFAyWzBdKSAtIChQMlsxXSAtIFAxWzFdKSAvIChQMlswXSAtIFAxWzBdKVxuICAgIH1cblxuICAgIHJlc3VsdFswXSA9IDBcbiAgICByZXN1bHRbbiAtIDFdID0gMFxuXG4gICAgbWF0cml4W24gLSAxXSA9IFswLCAxLCAwXVxuXG4gICAgLy8gUGFzcyAxXG4gICAgZm9yIChpID0gMTsgaSA8IG47IGkrKykge1xuICAgICAgayA9IG1hdHJpeFsxXVswXSAvIG1hdHJpeFtpIC0gMV1bMV1cbiAgICAgIG1hdHJpeFtpXVsxXSAtPSBrICogbWF0cml4W2kgLSAxXVsyXVxuICAgICAgbWF0cml4W2ldWzBdID0gMFxuICAgICAgcmVzdWx0W2ldIC09IGsgKiByZXN1bHRbaSAtIDFdXG4gICAgfVxuXG4gICAgLy8gUGFzcyAyXG4gICAgZm9yIChpID0gbiAtIDI7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGsgPSBtYXRyaXhbaV1bMl0gLyBtYXRyaXhbaSArIDFdWzFdXG4gICAgICBtYXRyaXhbaV1bMV0gLT0gayAqIG1hdHJpeFtpICsgMV1bMF1cbiAgICAgIG1hdHJpeFtpXVsyXSA9IDBcbiAgICAgIHJlc3VsdFtpXSAtPSBrICogcmVzdWx0W2kgKyAxXVxuICAgIH1cblxuICAgIHZhciB5MiA9IFtdXG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgeTJbaV0gPSByZXN1bHRbaV0gLyBtYXRyaXhbaV1bMV1cbiAgICB9XG5cbiAgICByZXR1cm4geTJcbiAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgcHJpbWl0aXZlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5Ub25lQ3VydmUucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHJnYkNvbnRyb2xQb2ludHM6IHsgdHlwZTogJ29iamVjdCcgfSxcbiAgY29udHJvbFBvaW50czogeyB0eXBlOiAnYXJyYXknLCBkZWZhdWx0OiBbXSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvbmVDdXJ2ZVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy90b25lLWN1cnZlLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEVuZ2luZSBmcm9tICcuLi8uLi8uLi9lbmdpbmUnXG5pbXBvcnQgUHJpbWl0aXZlIGZyb20gJy4vcHJpbWl0aXZlJ1xuXG5jbGFzcyBYNDAwRmlsdGVyIGV4dGVuZHMgRW5naW5lLkZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5fZnJhZ21lbnRTb3VyY2UgPSByZXF1aXJlKCdyYXchLi4vLi4vLi4vc2hhZGVycy9wcmltaXRpdmVzL3g0MDAuZnJhZycpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3Qgb3V0cHV0Q29udGV4dCA9IG91dHB1dFRhcmdldC5nZXRDb250ZXh0KClcblxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDRcblxuICAgICAgICB2YXIgZ3JheSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAvIDI1NSAqIDAuMyArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gLyAyNTUgKiAwLjMgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdIC8gMjU1ICogMC4zXG4gICAgICAgIGdyYXkgLT0gMC4yXG4gICAgICAgIGdyYXkgPSBNYXRoLm1heCgwLjAsIE1hdGgubWluKDEuMCwgZ3JheSkpXG4gICAgICAgIGdyYXkgKz0gMC4xNVxuICAgICAgICBncmF5ICo9IDEuNFxuXG4gICAgICAgIGdyYXkgKj0gMjU1XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGdyYXlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGdyYXlcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGdyYXlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBYNDAwIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJzLlByaW1pdGl2ZVxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlclByaW1pdGl2ZXNcbiAqL1xuY2xhc3MgWDQwMCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcbiAgICB0aGlzLl9maWx0ZXIgPSBuZXcgWDQwMEZpbHRlcigpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgWDQwMFxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy94NDAwLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFF1b3ppIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFF1b3ppRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgLy8gRGVzYXR1cmF0aW9uXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5EZXNhdHVyYXRpb24oe1xuICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgfSkpXG5cbiAgICAvLyBUb25lIGN1cnZlXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNTBdLFxuICAgICAgICAgIFs0MCwgNzhdLFxuICAgICAgICAgIFsxMTgsIDE3MF0sXG4gICAgICAgICAgWzE4MSwgMjExXSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDI3XSxcbiAgICAgICAgICBbMjgsIDQ1XSxcbiAgICAgICAgICBbMTA5LCAxNTddLFxuICAgICAgICAgIFsxNTcsIDE5NV0sXG4gICAgICAgICAgWzE3OSwgMjA4XSxcbiAgICAgICAgICBbMjA2LCAyMTJdLFxuICAgICAgICAgIFsyNTUsIDI0MF1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCA1MF0sXG4gICAgICAgICAgWzEyLCA1NV0sXG4gICAgICAgICAgWzQ2LCAxMDNdLFxuICAgICAgICAgIFsxMDMsIDE2Ml0sXG4gICAgICAgICAgWzE5NCwgMTgyXSxcbiAgICAgICAgICBbMjQxLCAyMDFdLFxuICAgICAgICAgIFsyNTUsIDIxOV1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH0pKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuUXVvemlGaWx0ZXIuaWRlbnRpZmllciA9ICdxdW96aSdcblxuUXVvemlGaWx0ZXIuZGlzcGxheU5hbWUgPSAnUXVvemknXG5cbmV4cG9ydCBkZWZhdWx0IFF1b3ppRmlsdGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9xdW96aS1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgRmlsdGVyIGZyb20gJy4vZmlsdGVyJ1xuaW1wb3J0ICogYXMgRmlsdGVyUHJpbWl0aXZlcyBmcm9tICcuL3ByaW1pdGl2ZXMnXG5cbi8qKlxuICogU2VtaXJlZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuRmlsdGVyXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuRmlsdGVyc1xuICovXG5jbGFzcyBTZW1pcmVkRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMTI5XSxcbiAgICAgICAgICBbNzUsIDE1M10sXG4gICAgICAgICAgWzE4MSwgMjI3XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDhdLFxuICAgICAgICAgIFsxMTEsIDg1XSxcbiAgICAgICAgICBbMjEyLCAxNThdLFxuICAgICAgICAgIFsyNTUsIDIyNl1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCA1XSxcbiAgICAgICAgICBbNzUsIDIyXSxcbiAgICAgICAgICBbMTkzLCA5MF0sXG4gICAgICAgICAgWzI1NSwgMjI5XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLkdsb3coKSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblNlbWlyZWRGaWx0ZXIuaWRlbnRpZmllciA9ICdzZW1pcmVkJ1xuXG5TZW1pcmVkRmlsdGVyLmRpc3BsYXlOYW1lID0gJ1NlbWlyZWQnXG5cbmV4cG9ydCBkZWZhdWx0IFNlbWlyZWRGaWx0ZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3NlbWlyZWQtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFN1bm55IEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFN1bm55RmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgWzYyLCA4Ml0sXG4gICAgICAgICAgWzE0MSwgMTU0XSxcbiAgICAgICAgICBbMjU1LCAyNTVdXG4gICAgICAgIF0sXG4gICAgICAgIGdyZWVuOiBbXG4gICAgICAgICAgWzAsIDM5XSxcbiAgICAgICAgICBbNTYsIDk2XSxcbiAgICAgICAgICBbMTkyLCAxNzZdLFxuICAgICAgICAgIFsyNTUsIDI1NV1cbiAgICAgICAgXSxcbiAgICAgICAgYmx1ZTogW1xuICAgICAgICAgIFswLCAwXSxcbiAgICAgICAgICBbMTc0LCA5OV0sXG4gICAgICAgICAgWzI1NSwgMjM1XVxuICAgICAgICBdXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICB0aGlzLl9zdGFjay5wdXNoKG5ldyBGaWx0ZXJQcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICBjb250cm9sUG9pbnRzOiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzU1LCAyMF0sXG4gICAgICAgIFsxNTgsIDE5MV0sXG4gICAgICAgIFsyNTUsIDI1NV1cbiAgICAgIF1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblN1bm55RmlsdGVyLmlkZW50aWZpZXIgPSAnc3VubnknXG5cblN1bm55RmlsdGVyLmRpc3BsYXlOYW1lID0gJ1N1bm55J1xuXG5leHBvcnQgZGVmYXVsdCBTdW5ueUZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvc3VubnktZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFRleGFzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5GaWx0ZXJcbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5GaWx0ZXJzXG4gKi9cbmNsYXNzIFRleGFzRmlsdGVyIGV4dGVuZHMgRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fc3RhY2sucHVzaChuZXcgRmlsdGVyUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICByZWQ6IFtcbiAgICAgICAgICBbMCwgNzJdLFxuICAgICAgICAgIFs4OSwgOTldLFxuICAgICAgICAgIFsxNzYsIDIxMl0sXG4gICAgICAgICAgWzI1NSwgMjM3XVxuICAgICAgICBdLFxuICAgICAgICBncmVlbjogW1xuICAgICAgICAgIFswLCA0OV0sXG4gICAgICAgICAgWzI1NSwgMTkyXVxuICAgICAgICBdLFxuICAgICAgICBibHVlOiBbXG4gICAgICAgICAgWzAsIDcyXSxcbiAgICAgICAgICBbMjU1LCAxNTFdXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9KSlcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsdGVyJ3MgaWRlbnRpZmllclxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblRleGFzRmlsdGVyLmlkZW50aWZpZXIgPSAndGV4YXMnXG5cblRleGFzRmlsdGVyLmRpc3BsYXlOYW1lID0gJ1RleGFzJ1xuXG5leHBvcnQgZGVmYXVsdCBUZXhhc0ZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvdGV4YXMtZmlsdGVyLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IEZpbHRlciBmcm9tICcuL2ZpbHRlcidcbmltcG9ydCAqIGFzIEZpbHRlclByaW1pdGl2ZXMgZnJvbSAnLi9wcmltaXRpdmVzJ1xuXG4vKipcbiAqIFg0MDAgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLkZpbHRlclxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLkZpbHRlcnNcbiAqL1xuY2xhc3MgWDQwMEZpbHRlciBleHRlbmRzIEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIHRoaXMuX3N0YWNrLnB1c2gobmV3IEZpbHRlclByaW1pdGl2ZXMuWDQwMCgpKVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWx0ZXIncyBpZGVudGlmaWVyXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuWDQwMEZpbHRlci5pZGVudGlmaWVyID0gJ3g0MDAnXG5cblg0MDBGaWx0ZXIuZGlzcGxheU5hbWUgPSAnWDQwMCdcblxuZXhwb3J0IGRlZmF1bHQgWDQwMEZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMveDQwMC1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBFbmdpbmUgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFN0YWNrQmx1ciBmcm9tICcuLi8uLi92ZW5kb3Ivc3RhY2stYmx1cidcblxuY2xhc3MgTGluZWFyRm9jdXNGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZm9jdXMvbGluZWFyLWZvY3VzLmZyYWcnKVxuXG4gICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSBudWxsXG4gICAgdGhpcy5fbGFzdEdyYWRpZW50UmFkaXVzID0gbnVsbFxuICAgIHRoaXMuX2xhc3RTdGFydCA9IG5ldyBWZWN0b3IyKClcbiAgICB0aGlzLl9sYXN0RW5kID0gbmV3IFZlY3RvcjIoKVxuXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldCA9IG5ldyBFbmdpbmUuQ2FudmFzUmVuZGVyVGFyZ2V0KFxuICAgICAgMTAwLFxuICAgICAgMTAwLFxuICAgICAgMSlcblxuICAgIHRoaXMuX21hc2tSZW5kZXJUYXJnZXQgPSBuZXcgRW5naW5lLkNhbnZhc1JlbmRlclRhcmdldChcbiAgICAgIDEwMCxcbiAgICAgIDEwMCxcbiAgICAgIDEpXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGlzIGZpbHRlciB0byB0aGUgZ2l2ZW4gaW5wdXRUYXJnZXQgYW5kIHJlbmRlcnMgaXQgdG9cbiAgICogdGhlIGdpdmVuIG91dHB1dFRhcmdldCB1c2luZyB0aGUgQ2FudmFzUmVuZGVyZXJcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtICB7UmVuZGVyVGFyZ2V0fSBvdXRwdXRUYXJnZXRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY2xlYXIgPSBmYWxzZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Q2FudmFzIChyZW5kZXJlciwgaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCwgY2xlYXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlucHV0RGltZW5zaW9ucyA9IGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKVxuICAgIGNvbnN0IGRpbWVuc2lvbnNDaGFuZ2VkID0gIXRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0RGltZW5zaW9ucygpLmVxdWFscyhpbnB1dERpbWVuc2lvbnMpXG5cbiAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LnNldFBpeGVsUmF0aW8oaW5wdXRUYXJnZXQuZ2V0UGl4ZWxSYXRpbygpKVxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQucmVzaXplVG8oaW5wdXRUYXJnZXQuZ2V0RGltZW5zaW9ucygpKVxuXG4gICAgdGhpcy5fbWFza1JlbmRlclRhcmdldC5zZXRQaXhlbFJhdGlvKGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LnJlc2l6ZVRvKGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKSlcblxuICAgIGlmICghdGhpcy5fb3V0cHV0UmVuZGVyVGV4dHVyZSkge1xuICAgICAgdGhpcy5fb3V0cHV0UmVuZGVyVGV4dHVyZSA9IG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZShyZW5kZXJlcixcbiAgICAgICAgaW5wdXRUYXJnZXQuZ2V0V2lkdGgoKSxcbiAgICAgICAgaW5wdXRUYXJnZXQuZ2V0SGVpZ2h0KCksXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2xhc3RTdGFydC5lcXVhbHModGhpcy5fb3B0aW9ucy5zdGFydCkgfHxcbiAgICAgICAgIXRoaXMuX2xhc3RFbmQuZXF1YWxzKHRoaXMuX29wdGlvbnMuZW5kKSB8fFxuICAgICAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgIT09IHRoaXMuX29wdGlvbnMuc2l6ZSB8fFxuICAgICAgICBkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fcmVuZGVyTWFzaygpXG5cbiAgICAgIHRoaXMuX2xhc3RTdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKVxuICAgICAgdGhpcy5fbGFzdEVuZCA9IHRoaXMuX29wdGlvbnMuZW5kLmNsb25lKClcbiAgICAgIHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cyA9IHRoaXMuX29wdGlvbnMuc2l6ZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXN0Qmx1clJhZGl1cyAhPT0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzIHx8XG4gICAgICBkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYmx1ckltYWdlKGlucHV0VGFyZ2V0KVxuICAgICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXNcbiAgICB9XG5cbiAgICB0aGlzLl9hcHBseU1hc2soaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmx1cnJlZCBjb3B5IG9mIHRoZSBpbWFnZVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ibHVySW1hZ2UgKGlucHV0VGFyZ2V0KSB7XG4gICAgY29uc3QgaW5wdXRDYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuXG4gICAgY29uc3QgYmx1cnJ5SW1hZ2VEYXRhID0gaW5wdXRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KVxuICAgIFN0YWNrQmx1ci5zdGFja0JsdXJDYW52YXNSR0JBKGJsdXJyeUltYWdlRGF0YSwgMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCwgdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzKVxuXG4gICAgY29uc3QgYmx1cnJ5Q29udGV4dCA9IHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgYmx1cnJ5Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIG1hc2sgY2FudmFzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyTWFzayAoKSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fbWFza1JlbmRlclRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldFBpeGVsUmF0aW8oKVxuXG4gICAgY29uc3QgY2FudmFzRGltZW5zaW9ucyA9IG5ldyBWZWN0b3IyKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9vcHRpb25zLnNpemUgKiBwaXhlbFJhdGlvXG4gICAgY29uc3QgZ3JhZGllbnRTaXplID0gdGhpcy5fb3B0aW9ucy5ncmFkaWVudFNpemUgKiBwaXhlbFJhdGlvXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9vcHRpb25zLnN0YXJ0LmNsb25lKClcbiAgICBjb25zdCBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpXG5cbiAgICBzdGFydC5tdWx0aXBseShjYW52YXNEaW1lbnNpb25zKVxuICAgIGVuZC5tdWx0aXBseShjYW52YXNEaW1lbnNpb25zKVxuXG4gICAgY29uc3QgZGlzdCA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KVxuICAgIGNvbnN0IG1pZGRsZSA9IHN0YXJ0LmNsb25lKCkuYWRkKGRpc3QuY2xvbmUoKS5kaXZpZGUoMikpXG5cbiAgICBjb25zdCB0b3RhbERpc3QgPSBkaXN0LmxlbigpXG4gICAgY29uc3QgZmFjdG9yID0gZGlzdC5jbG9uZSgpLmRpdmlkZSh0b3RhbERpc3QpXG5cbiAgICBjb25zdCBncmFkaWVudFN0YXJ0ID0gbWlkZGxlLmNsb25lKClcbiAgICAgIC5hZGQoXG4gICAgICAgIChzaXplICsgZ3JhZGllbnRTaXplKSAqIGZhY3Rvci55LFxuICAgICAgICAtKHNpemUgKyBncmFkaWVudFNpemUpICogZmFjdG9yLnhcbiAgICAgIClcbiAgICBjb25zdCBncmFkaWVudEVuZCA9IG1pZGRsZS5jbG9uZSgpXG4gICAgICAuYWRkKFxuICAgICAgICAtKHNpemUgKyBncmFkaWVudFNpemUpICogZmFjdG9yLnksXG4gICAgICAgIChzaXplICsgZ3JhZGllbnRTaXplKSAqIGZhY3Rvci54XG4gICAgICApXG5cbiAgICAvLyBCdWlsZCBncmFkaWVudFxuICAgIGNvbnN0IGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChcbiAgICAgIGdyYWRpZW50U3RhcnQueCwgZ3JhZGllbnRTdGFydC55LFxuICAgICAgZ3JhZGllbnRFbmQueCwgZ3JhZGllbnRFbmQueVxuICAgIClcbiAgICBjb25zdCBmdWxsR3JhZGllbnRTaXplID0gZ3JhZGllbnRFbmQuY2xvbmUoKVxuICAgICAgLnN1YnRyYWN0KGdyYWRpZW50U3RhcnQpXG4gICAgICAubGVuKClcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyMwMDAwMDAnKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgoZ3JhZGllbnRTaXplIC8gMikgLyBmdWxsR3JhZGllbnRTaXplLCAnI0ZGRkZGRicpXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEuMCAtICgoZ3JhZGllbnRTaXplIC8gMikgLyBmdWxsR3JhZGllbnRTaXplKSwgJyNGRkZGRkYnKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzAwMDAwMCcpXG5cbiAgICAvLyBEcmF3IGdyYWRpZW50XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudFxuICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGJsdXIgYW5kIG1hc2sgdG8gdGhlIGlucHV0IGNhbnZhc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5TWFzayAoaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCkge1xuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3QgaW5wdXRDYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IGJsdXJyZWRDb250ZXh0ID0gdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBtYXNrQ29udGV4dCA9IHRoaXMuX21hc2tSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodClcbiAgICBjb25zdCBwaXhlbHMgPSBpbnB1dEltYWdlRGF0YS5kYXRhXG4gICAgY29uc3QgYmx1cnJlZFBpeGVscyA9IGJsdXJyZWRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhXG4gICAgY29uc3QgbWFza1BpeGVscyA9IG1hc2tDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhXG5cbiAgICBsZXQgYWxwaGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q2FudmFzLndpZHRoICogaW5wdXRDYW52YXMuaGVpZ2h0ICogNDsgaSArPSA0KSB7XG4gICAgICBhbHBoYSA9IG1hc2tQaXhlbHNbaV0gLyAyNTVcblxuICAgICAgcGl4ZWxzW2ldID0gYWxwaGEgKiBwaXhlbHNbaV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaV1cbiAgICAgIHBpeGVsc1tpICsgMV0gPSBhbHBoYSAqIHBpeGVsc1tpICsgMV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaSArIDFdXG4gICAgICBwaXhlbHNbaSArIDJdID0gYWxwaGEgKiBwaXhlbHNbaSArIDJdICsgKDEgLSBhbHBoYSkgKiBibHVycmVkUGl4ZWxzW2kgKyAyXVxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGlucHV0SW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cbkxpbmVhckZvY3VzRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBibHVyUmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAzMCwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICBzaXplOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiA1MCwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICBncmFkaWVudFNpemU6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDUwLCB1bmlmb3JtVHlwZTogJ2YnIH0sXG4gIHN0YXJ0OiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMCwgMC41KSwgdW5pZm9ybVR5cGU6ICcyZicgfSxcbiAgZW5kOiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMSwgMC41KSwgdW5pZm9ybVR5cGU6ICcyZicgfSxcbiAgZGVsdGE6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLCAxKSwgdW5pZm9ybVR5cGU6ICcyZicgfSxcbiAgdGV4U2l6ZTogeyB0eXBlOiAndmVjdG9yMicsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEwMCwgMTAwKSwgdW5pZm9ybVR5cGU6ICcyZicgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJGb2N1c0ZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZvY3VzL2xpbmVhci1mb2N1cy1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBWZWN0b3IyLCBFbmdpbmUgfSBmcm9tICcuLi8uLi9nbG9iYWxzJ1xuaW1wb3J0IFN0YWNrQmx1ciBmcm9tICcuLi8uLi92ZW5kb3Ivc3RhY2stYmx1cidcblxuY2xhc3MgUmFkaWFsRm9jdXNGaWx0ZXIgZXh0ZW5kcyBFbmdpbmUuRmlsdGVyIHtcbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gcmVxdWlyZSgncmF3IS4uLy4uL3NoYWRlcnMvZm9jdXMvcmFkaWFsLWZvY3VzLmZyYWcnKVxuXG4gICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSBudWxsXG4gICAgdGhpcy5fbGFzdEdyYWRpZW50UmFkaXVzID0gbnVsbFxuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKClcblxuICAgIHRoaXMuX2JsdXJyZWRSZW5kZXJUYXJnZXQgPSBuZXcgRW5naW5lLkNhbnZhc1JlbmRlclRhcmdldChcbiAgICAgIDEwMCxcbiAgICAgIDEwMCxcbiAgICAgIDEpXG5cbiAgICB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0ID0gbmV3IEVuZ2luZS5DYW52YXNSZW5kZXJUYXJnZXQoXG4gICAgICAxMDAsXG4gICAgICAxMDAsXG4gICAgICAxKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBmaWx0ZXIgdG8gdGhlIGdpdmVuIGlucHV0VGFyZ2V0IGFuZCByZW5kZXJzIGl0IHRvXG4gICAqIHRoZSBnaXZlbiBvdXRwdXRUYXJnZXQgdXNpbmcgdGhlIENhbnZhc1JlbmRlcmVyXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtSZW5kZXJUYXJnZXR9IGlucHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge1JlbmRlclRhcmdldH0gb3V0cHV0VGFyZ2V0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNsZWFyID0gZmFsc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUNhbnZhcyAocmVuZGVyZXIsIGlucHV0VGFyZ2V0LCBvdXRwdXRUYXJnZXQsIGNsZWFyID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSBpbnB1dFRhcmdldC5nZXREaW1lbnNpb25zKClcbiAgICBjb25zdCBkaW1lbnNpb25zQ2hhbmdlZCA9ICF0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LmdldERpbWVuc2lvbnMoKS5lcXVhbHMoaW5wdXREaW1lbnNpb25zKVxuXG4gICAgdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldC5zZXRQaXhlbFJhdGlvKGlucHV0VGFyZ2V0LmdldFBpeGVsUmF0aW8oKSlcbiAgICB0aGlzLl9ibHVycmVkUmVuZGVyVGFyZ2V0LnJlc2l6ZVRvKGlucHV0VGFyZ2V0LmdldERpbWVuc2lvbnMoKSlcblxuICAgIHRoaXMuX21hc2tSZW5kZXJUYXJnZXQuc2V0UGl4ZWxSYXRpbyhpbnB1dFRhcmdldC5nZXRQaXhlbFJhdGlvKCkpXG4gICAgdGhpcy5fbWFza1JlbmRlclRhcmdldC5yZXNpemVUbyhpbnB1dFRhcmdldC5nZXREaW1lbnNpb25zKCkpXG5cbiAgICBpZiAoIXRoaXMuX291dHB1dFJlbmRlclRleHR1cmUpIHtcbiAgICAgIHRoaXMuX291dHB1dFJlbmRlclRleHR1cmUgPSBuZXcgRW5naW5lLlJlbmRlclRleHR1cmUocmVuZGVyZXIsXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldFdpZHRoKCksXG4gICAgICAgIGlucHV0VGFyZ2V0LmdldEhlaWdodCgpLFxuICAgICAgICBpbnB1dFRhcmdldC5nZXRQaXhlbFJhdGlvKCkpXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9sYXN0UG9zaXRpb24uZXF1YWxzKHRoaXMuX29wdGlvbnMucG9zaXRpb24pIHx8XG4gICAgICAgIHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cyAhPT0gdGhpcy5fb3B0aW9ucy5ncmFkaWVudFJhZGl1cyB8fFxuICAgICAgICBkaW1lbnNpb25zQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fcmVuZGVyTWFzaygpXG5cbiAgICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKVxuICAgICAgdGhpcy5fbGFzdEdyYWRpZW50UmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ncmFkaWVudFJhZGl1c1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXN0Qmx1clJhZGl1cyAhPT0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzIHx8IGRpbWVuc2lvbnNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ibHVySW1hZ2UoaW5wdXRUYXJnZXQpXG4gICAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1c1xuICAgIH1cblxuICAgIHRoaXMuX2FwcGx5TWFzayhpbnB1dFRhcmdldCwgb3V0cHV0VGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBibHVycmVkIGNvcHkgb2YgdGhlIGltYWdlXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHJldHVybiB7Q2FudmFzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JsdXJJbWFnZSAoaW5wdXRUYXJnZXQpIHtcbiAgICBjb25zdCBpbnB1dENhbnZhcyA9IGlucHV0VGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgaW5wdXRDb250ZXh0ID0gaW5wdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBibHVycnlJbWFnZURhdGEgPSBpbnB1dENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGlucHV0Q2FudmFzLndpZHRoLCBpbnB1dENhbnZhcy5oZWlnaHQpXG4gICAgU3RhY2tCbHVyLnN0YWNrQmx1ckNhbnZhc1JHQkEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0LCB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMpXG5cbiAgICBjb25zdCBibHVycnlDb250ZXh0ID0gdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldC5nZXRDb250ZXh0KClcbiAgICBibHVycnlDb250ZXh0LnB1dEltYWdlRGF0YShibHVycnlJbWFnZURhdGEsIDAsIDApXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgbWFzayBjYW52YXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJNYXNrICgpIHtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldENhbnZhcygpXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX21hc2tSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBjYW52YXNEaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLl9tYXNrUmVuZGVyVGFyZ2V0LmdldFBpeGVsUmF0aW8oKVxuXG4gICAgY29uc3QgeyByYWRpdXMsIGdyYWRpZW50UmFkaXVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKClcbiAgICAgIC5tdWx0aXBseSh0aGlzLl9vcHRpb25zLnRleFNpemUpXG4gICAgICAubXVsdGlwbHkocGl4ZWxSYXRpbylcblxuICAgIC8vIEJ1aWxkIGdyYWRpZW50XG4gICAgY29uc3QgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMCxcbiAgICAgIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIChyYWRpdXMgKyBncmFkaWVudFJhZGl1cykgKiBwaXhlbFJhdGlvXG4gICAgKVxuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI0ZGRkZGRicpXG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHJhZGl1cyAvIChyYWRpdXMgKyBncmFkaWVudFJhZGl1cyksICcjRkZGRkZGJylcbiAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyMwMDAwMDAnKVxuXG4gICAgLy8gRHJhdyBncmFkaWVudFxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhc0RpbWVuc2lvbnMueCwgY2FudmFzRGltZW5zaW9ucy55KVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGJsdXIgYW5kIG1hc2sgdG8gdGhlIGlucHV0IGNhbnZhc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlclRhcmdldH0gaW5wdXRUYXJnZXRcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJUYXJnZXR9IG91dHB1dFRhcmdldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5TWFzayAoaW5wdXRUYXJnZXQsIG91dHB1dFRhcmdldCkge1xuICAgIGNvbnN0IG91dHB1dENvbnRleHQgPSBvdXRwdXRUYXJnZXQuZ2V0Q29udGV4dCgpXG4gICAgY29uc3QgaW5wdXRDYW52YXMgPSBpbnB1dFRhcmdldC5nZXRDYW52YXMoKVxuICAgIGNvbnN0IGlucHV0Q29udGV4dCA9IGlucHV0VGFyZ2V0LmdldENvbnRleHQoKVxuICAgIGNvbnN0IGJsdXJyZWRDb250ZXh0ID0gdGhpcy5fYmx1cnJlZFJlbmRlclRhcmdldC5nZXRDb250ZXh0KClcbiAgICBjb25zdCBtYXNrQ29udGV4dCA9IHRoaXMuX21hc2tSZW5kZXJUYXJnZXQuZ2V0Q29udGV4dCgpXG5cbiAgICBjb25zdCBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodClcbiAgICBjb25zdCBwaXhlbHMgPSBpbnB1dEltYWdlRGF0YS5kYXRhXG4gICAgY29uc3QgYmx1cnJlZFBpeGVscyA9IGJsdXJyZWRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhXG4gICAgY29uc3QgbWFza1BpeGVscyA9IG1hc2tDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhXG5cbiAgICBsZXQgYWxwaGFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q2FudmFzLndpZHRoICogaW5wdXRDYW52YXMuaGVpZ2h0ICogNDsgaSArPSA0KSB7XG4gICAgICBhbHBoYSA9IG1hc2tQaXhlbHNbaV0gLyAyNTVcblxuICAgICAgcGl4ZWxzW2ldID0gYWxwaGEgKiBwaXhlbHNbaV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaV1cbiAgICAgIHBpeGVsc1tpICsgMV0gPSBhbHBoYSAqIHBpeGVsc1tpICsgMV0gKyAoMSAtIGFscGhhKSAqIGJsdXJyZWRQaXhlbHNbaSArIDFdXG4gICAgICBwaXhlbHNbaSArIDJdID0gYWxwaGEgKiBwaXhlbHNbaSArIDJdICsgKDEgLSBhbHBoYSkgKiBibHVycmVkUGl4ZWxzW2kgKyAyXVxuICAgIH1cblxuICAgIG91dHB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGlucHV0SW1hZ2VEYXRhLCAwLCAwKVxuICB9XG59XG5cblJhZGlhbEZvY3VzRmlsdGVyLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBibHVyUmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAzMCwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICByYWRpdXM6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDUwLCB1bmlmb3JtVHlwZTogJ2YnIH0sXG4gIGdyYWRpZW50UmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAyNSwgdW5pZm9ybVR5cGU6ICdmJyB9LFxuICBwb3NpdGlvbjogeyB0eXBlOiAndmVjdG9yMicsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDAuNSwgMC41KSwgdW5pZm9ybVR5cGU6ICcyZicgfSxcbiAgZGVsdGE6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLCAxKSwgdW5pZm9ybVR5cGU6ICcyZicgfSxcbiAgdGV4U2l6ZTogeyB0eXBlOiAndmVjdG9yMicsIGRlZmF1bHQ6IG5ldyBWZWN0b3IyKDEwMCwgMTAwKSwgdW5pZm9ybVR5cGU6ICcyZicgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSYWRpYWxGb2N1c0ZpbHRlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2ZvY3VzL3JhZGlhbC1mb2N1cy1maWx0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFZlY3RvcjIgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IExpbmVhckZvY3VzRmlsdGVyIGZyb20gJy4vZm9jdXMvbGluZWFyLWZvY3VzLWZpbHRlcidcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gZHJhdyBhIGxpbmVhciBmb2N1c1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIExpbmVhckZvY3VzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTGluZWFyRm9jdXNPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXNcbiAgICB0aGlzLl9sYXN0U2l6ZSA9IHRoaXMuX29wdGlvbnMuc2l6ZVxuICAgIHRoaXMuX2xhc3RHcmFkaWVudFNpemUgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50U2l6ZVxuXG4gICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlciA9IG5ldyBMaW5lYXJGb2N1c0ZpbHRlcigpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIgPSBuZXcgTGluZWFyRm9jdXNGaWx0ZXIoKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFtcbiAgICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIsXG4gICAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlclxuICAgIF0pXG5cbiAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyLnNldERlbHRhKG5ldyBWZWN0b3IyKDEsIDEpKVxuICAgIHRoaXMuX3ZlcnRpY2FsRmlsdGVyLnNldERlbHRhKG5ldyBWZWN0b3IyKC0xLCAxKSlcblxuICAgIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlID0gdGhpcy5fb25PcGVyYXRpb25VcGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Nkay5vbihDb25zdGFudHMuRXZlbnRzLk9QRVJBVElPTl9VUERBVEVELCB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSlcblxuICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBMaW5lYXJGb2N1c0ZpbHRlcigpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvcGVyYXRpb24gaXMgYWJvdXQgdG8gYmUgdXBkYXRlZC4gSWYgdGhlIGNyb3BcbiAgICogb3Igcm90YXRpb24gb3BlcmF0aW9uIGlzIHVwZGF0ZWQsIHRoaXMgd2lsbCBiZSByZWNvZ25pemVkIGFuZCB0aGVcbiAgICogYmx1ciB3aWxsIGJlIHVwZGF0ZWQgYWNjb3JkaW5nbHlcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25PcGVyYXRpb25VcGRhdGUgKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gb3BlcmF0aW9uLmNvbnN0cnVjdG9yXG5cbiAgICBpZiAoaWRlbnRpZmllciA9PT0gJ29yaWVudGF0aW9uJyAmJlxuICAgICAgICAncm90YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2FwcGx5Um90YXRpb24ob3BlcmF0aW9uLCBvcHRpb25zKVxuICAgIH1cblxuICAgIGlmIChpZGVudGlmaWVyID09PSAnb3JpZW50YXRpb24nICYmXG4gICAgICAgICgnZmxpcEhvcml6b250YWxseScgaW4gb3B0aW9ucyB8fCAnZmxpcFZlcnRpY2FsbHknIGluIG9wdGlvbnMpKSB7XG4gICAgICB0aGlzLl9hcHBseUZsaXAob3BlcmF0aW9uLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBnaXZlbiByb3RhdGlvbiBjaGFuZ2VcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Sb3RhdGlvbk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5Um90YXRpb24gKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9sZFJvdGF0aW9uID0gb3BlcmF0aW9uLmdldFJvdGF0aW9uKClcbiAgICBjb25zdCBuZXdSb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb25cbiAgICBjb25zdCBkZWdyZWVzRGlmZmVyZW5jZSA9IG5ld1JvdGF0aW9uIC0gb2xkUm90YXRpb25cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydFxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kXG5cbiAgICBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IDkwIHx8IChvbGRSb3RhdGlvbiA9PT0gMjcwICYmIG5ld1JvdGF0aW9uID09PSAwKSkge1xuICAgICAgc3RhcnQuZmxpcCgpXG4gICAgICBzdGFydC54ID0gMSAtIHN0YXJ0LnhcbiAgICAgIGVuZC5mbGlwKClcbiAgICAgIGVuZC54ID0gMSAtIGVuZC54XG4gICAgfSBlbHNlIGlmIChkZWdyZWVzRGlmZmVyZW5jZSA9PT0gLTkwIHx8IChvbGRSb3RhdGlvbiA9PT0gLTI3MCAmJiBuZXdSb3RhdGlvbiA9PT0gMCkpIHtcbiAgICAgIHN0YXJ0LmZsaXAoKVxuICAgICAgc3RhcnQueSA9IDEgLSBzdGFydC55XG4gICAgICBlbmQuZmxpcCgpXG4gICAgICBlbmQueSA9IDEgLSBlbmQueVxuICAgIH1cblxuICAgIHRoaXMuc2V0KHsgc3RhcnQsIGVuZCB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIGZsaXAgY2hhbmdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuUm90YXRpb25PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUZsaXAgKG9wZXJhdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICgnZmxpcFZlcnRpY2FsbHknIGluIG9wdGlvbnMgJiZcbiAgICAgICAgb3BlcmF0aW9uLmdldEZsaXBWZXJ0aWNhbGx5KCkgIT09IG9wdGlvbnMuZmxpcFZlcnRpY2FsbHkpIHtcbiAgICAgIHRoaXMuX2FwcGx5RmxpcERpcmVjdGlvbihvcGVyYXRpb24sICd2ZXJ0aWNhbCcpXG4gICAgfVxuXG4gICAgaWYgKCdmbGlwSG9yaXpvbnRhbGx5JyBpbiBvcHRpb25zICYmXG4gICAgICAgIG9wZXJhdGlvbi5nZXRGbGlwSG9yaXpvbnRhbGx5KCkgIT09IG9wdGlvbnMuZmxpcEhvcml6b250YWxseSkge1xuICAgICAgdGhpcy5fYXBwbHlGbGlwRGlyZWN0aW9uKG9wZXJhdGlvbiwgJ2hvcml6b250YWwnKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUZsaXBEaXJlY3Rpb24gKG9wZXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSBvcGVyYXRpb24uZ2V0Um90YXRpb24oKVxuICAgIGlmIChyb3RhdGlvbiA9PT0gOTAgfHwgcm90YXRpb24gPT09IDI3MCkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBkaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnRcbiAgICBjb25zdCBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZFxuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBzdGFydC54ID0gMSAtIHN0YXJ0LnhcbiAgICAgICAgZW5kLnggPSAxIC0gZW5kLnhcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgc3RhcnQueSA9IDEgLSBzdGFydC55XG4gICAgICAgIGVuZC55ID0gMSAtIGVuZC55XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgdGhpcy5zZXQoeyBzdGFydCwgZW5kIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3JlbmRlcldlYkdMIChzZGspIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG4gICAgY29uc3Qgb3V0cHV0U3ByaXRlID0gc2RrLmdldFNwcml0ZSgpXG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHRoaXMuX2dldFJlbmRlclRleHR1cmUoc2RrKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUob3V0cHV0U3ByaXRlLmdldFRleHR1cmUoKSlcblxuICAgIGNvbnN0IHNwcml0ZUJvdW5kcyA9IG91dHB1dFNwcml0ZS5nZXRCb3VuZHMoKVxuICAgIGNvbnN0IG91dHB1dERpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihzcHJpdGVCb3VuZHMud2lkdGgsIHNwcml0ZUJvdW5kcy5oZWlnaHQpXG5cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKVxuICAgIGNvbnN0IGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kLmNsb25lKClcblxuICAgIHN0YXJ0Lm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG4gICAgZW5kLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCB7IGJsdXJSYWRpdXMsIHNpemUsIGdyYWRpZW50U2l6ZSB9ID0gdGhpcy5fb3B0aW9uc1xuICAgIGNvbnN0IGNvbW1vbk9wdGlvbnMgPSB7XG4gICAgICBibHVyUmFkaXVzLCBzaXplLCBncmFkaWVudFNpemUsXG5cbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgdGV4U2l6ZTogb3V0cHV0RGltZW5zaW9uc1xuICAgIH1cblxuICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG5cbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9zcHJpdGUuZ2V0Qm91bmRzKClcbiAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCkpXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcbiAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZmFsc2UsIHJlbmRlcmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcmFkaWFsIGJsdXIgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHNkaykge1xuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaylcblxuICAgIGNvbnN0IHsgYmx1clJhZGl1cywgc2l6ZSwgZ3JhZGllbnRTaXplLCBzdGFydCwgZW5kIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgdGhpcy5fZmlsdGVyLnNldCh7XG4gICAgICBibHVyUmFkaXVzLCBncmFkaWVudFNpemUsIHNpemUsIHN0YXJ0LCBlbmQsXG4gICAgICB0ZXhTaXplOiBzZGsuZ2V0T3V0cHV0RGltZW5zaW9ucygpXG4gICAgfSlcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkpXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW1xuICAgICAgdGhpcy5fZmlsdGVyXG4gICAgXSlcblxuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuX3Nwcml0ZS5nZXRCb3VuZHMoKVxuICAgIHJlbmRlclRleHR1cmUucmVzaXplVG8obmV3IFZlY3RvcjIoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KSlcbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbkxpbmVhckZvY3VzT3BlcmF0aW9uLmlkZW50aWZpZXIgPSAnbGluZWFyLWZvY3VzJ1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGlnbm9yZVxuICovXG5MaW5lYXJGb2N1c09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgc3RhcnQ6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLjAsIDAuNSkgfSxcbiAgZW5kOiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMS4wLCAwLjUpIH0sXG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDMwIH0sXG4gIHNpemU6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDUwIH0sXG4gIGdyYWRpZW50U2l6ZTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogNTAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5lYXJGb2N1c09wZXJhdGlvblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL2xpbmVhci1mb2N1cy1vcGVyYXRpb24uanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBFbmdpbmUgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vdmVuZG9yL3Byb21pc2UnXG5pbXBvcnQgVmVjdG9yMiBmcm9tICcuLi9saWIvbWF0aC92ZWN0b3IyJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gcm90YXRlIGFuZCBmbGlwIGFuIGltYWdlXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvblxuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgT3JpZW50YXRpb25PcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPcmllbnRhdGlvbk9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl9zcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fY29udGFpbmVyID0gbmV3IEVuZ2luZS5Db250YWluZXIoKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDaGlsZCh0aGlzLl9zcHJpdGUpXG4gIH1cblxuICAvKipcbiAgICogUm90YXRlcyBhbmQvb3IgZmxpcHMgdGhlIGltYWdlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlciAoc2RrKSB7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaylcblxuICAgIGNvbnN0IGFjdHVhbERlZ3JlZXMgPSB0aGlzLl9vcHRpb25zLnJvdGF0aW9uICUgMzYwXG4gICAgY29uc3QgcmFkaWFucyA9IGFjdHVhbERlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MClcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRTY2FsZShcbiAgICAgIHRoaXMuX29wdGlvbnMuZmxpcEhvcml6b250YWxseSA/IC0xIDogMSxcbiAgICAgIHRoaXMuX29wdGlvbnMuZmxpcFZlcnRpY2FsbHkgPyAtMSA6IDFcbiAgICApXG4gICAgdGhpcy5fc3ByaXRlLnNldFJvdGF0aW9uKHJhZGlhbnMpXG4gICAgdGhpcy5fc3ByaXRlLnNldEFuY2hvcigwLjUsIDAuNSlcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShvdXRwdXRTcHJpdGUuZ2V0VGV4dHVyZSgpKVxuICAgIHRoaXMuX3Nwcml0ZS51cGRhdGVUcmFuc2Zvcm0oKVxuXG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5fc3ByaXRlLmdldEJvdW5kcygpXG4gICAgcmVuZGVyVGV4dHVyZS5yZXNpemVUbyhuZXcgVmVjdG9yMihib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHJlbmRlcmluZyB0byB0b3AgbGVmdCBjb3JuZXJcbiAgICB0aGlzLl9zcHJpdGUuc2V0UG9zaXRpb24ocmVuZGVyVGV4dHVyZS5nZXRXaWR0aCgpIC8gMiwgcmVuZGVyVGV4dHVyZS5nZXRIZWlnaHQoKSAvIDIpXG5cbiAgICAvLyBEcmF3XG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuICAgIG91dHB1dFNwcml0ZS5zZXRUZXh0dXJlKHJlbmRlclRleHR1cmUpXG4gICAgdGhpcy5zZXREaXJ0eUZvclJlbmRlcmVyKGZhbHNlLCByZW5kZXJlcilcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgdGhlIGdpdmVuIGRpbWVuc2lvbnMgd2lsbCBoYXZlIGFmdGVyIHRoaXMgb3BlcmF0aW9uXG4gICAqIGhhcyBiZWVuIGFwcGxpZWRcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE5ld0RpbWVuc2lvbnMgKGRpbWVuc2lvbnMpIHtcbiAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucy5jbG9uZSgpXG4gICAgaWYgKHRoaXMuX29wdGlvbnMucm90YXRpb24gJSAxODApIHtcbiAgICAgIGRpbWVuc2lvbnMuZmxpcCgpXG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25zXG4gIH1cbn1cblxuLyoqXG4gKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAqIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHRcbiAqL1xuT3JpZW50YXRpb25PcGVyYXRpb24uaWRlbnRpZmllciA9ICdvcmllbnRhdGlvbidcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuT3JpZW50YXRpb25PcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHJvdGF0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwLCB2YWxpZGF0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJSA5MCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmllbnRhdGlvbk9wZXJhdGlvbjogYHJvdGF0aW9uYCBoYXMgdG8gYmUgYSBtdWx0aXBsZSBvZiA5MC4nKVxuICAgIH1cbiAgfSwgc2V0dGVyOiAodmFsdWUpID0+IHZhbHVlICUgMzYwIH0sXG4gIGZsaXBWZXJ0aWNhbGx5OiB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfSxcbiAgZmxpcEhvcml6b250YWxseTogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgT3JpZW50YXRpb25PcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9vcmllbnRhdGlvbi1vcGVyYXRpb24uanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBDb25zdGFudHMsIFZlY3RvcjIgfSBmcm9tICcuLi9nbG9iYWxzJ1xuaW1wb3J0IE9wZXJhdGlvbiBmcm9tICcuL29wZXJhdGlvbidcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL3ZlbmRvci9wcm9taXNlJ1xuaW1wb3J0IFJhZGlhbEZvY3VzRmlsdGVyIGZyb20gJy4vZm9jdXMvcmFkaWFsLWZvY3VzLWZpbHRlcidcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gdGhhdCBjYW4gZHJhdyBhIHJhZGlhbCBmb2N1c1xuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIFJhZGlhbEZvY3VzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmFkaWFsRm9jdXNPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXNcbiAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzXG5cbiAgICB0aGlzLl9ob3Jpem9udGFsRmlsdGVyID0gbmV3IFJhZGlhbEZvY3VzRmlsdGVyKClcbiAgICB0aGlzLl92ZXJ0aWNhbEZpbHRlciA9IG5ldyBSYWRpYWxGb2N1c0ZpbHRlcigpXG4gICAgdGhpcy5fc3ByaXRlLnNldEZpbHRlcnMoW1xuICAgICAgdGhpcy5faG9yaXpvbnRhbEZpbHRlcixcbiAgICAgIHRoaXMuX3ZlcnRpY2FsRmlsdGVyXG4gICAgXSlcblxuICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIuc2V0RGVsdGEobmV3IFZlY3RvcjIoMSwgMSkpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuc2V0RGVsdGEobmV3IFZlY3RvcjIoLTEsIDEpKVxuXG4gICAgdGhpcy5fb25PcGVyYXRpb25VcGRhdGUgPSB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5fc2RrLm9uKENvbnN0YW50cy5FdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuXG4gICAgdGhpcy5fZmlsdGVyID0gbmV3IFJhZGlhbEZvY3VzRmlsdGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGFuIG9wZXJhdGlvbiBpcyBhYm91dCB0byBiZSB1cGRhdGVkLiBJZiB0aGUgY3JvcFxuICAgKiBvciByb3RhdGlvbiBvcGVyYXRpb24gaXMgdXBkYXRlZCwgdGhpcyB3aWxsIGJlIHJlY29nbml6ZWQgYW5kIHRoZVxuICAgKiBibHVyIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZSAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZGVudGlmaWVyIH0gPSBvcGVyYXRpb24uY29uc3RydWN0b3JcblxuICAgIGlmIChpZGVudGlmaWVyID09PSAnb3JpZW50YXRpb24nICYmXG4gICAgICAgICdyb3RhdGlvbicgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5fYXBwbHlSb3RhdGlvbihvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKGlkZW50aWZpZXIgPT09ICdvcmllbnRhdGlvbicgJiZcbiAgICAgICAgKCdmbGlwSG9yaXpvbnRhbGx5JyBpbiBvcHRpb25zIHx8ICdmbGlwVmVydGljYWxseScgaW4gb3B0aW9ucykpIHtcbiAgICAgIHRoaXMuX2FwcGx5RmxpcChvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIHJvdGF0aW9uIGNoYW5nZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlSb3RhdGlvbiAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2xkUm90YXRpb24gPSBvcGVyYXRpb24uZ2V0Um90YXRpb24oKVxuICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvblxuICAgIGNvbnN0IGRlZ3JlZXNEaWZmZXJlbmNlID0gbmV3Um90YXRpb24gLSBvbGRSb3RhdGlvblxuXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uXG5cbiAgICBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IDkwIHx8IChvbGRSb3RhdGlvbiA9PT0gMjcwICYmIG5ld1JvdGF0aW9uID09PSAwKSkge1xuICAgICAgcG9zaXRpb24uZmxpcCgpXG4gICAgICBwb3NpdGlvbi54ID0gMSAtIHBvc2l0aW9uLnhcbiAgICB9IGVsc2UgaWYgKGRlZ3JlZXNEaWZmZXJlbmNlID09PSAtOTAgfHwgKG9sZFJvdGF0aW9uID09PSAtMjcwICYmIG5ld1JvdGF0aW9uID09PSAwKSkge1xuICAgICAgcG9zaXRpb24uZmxpcCgpXG4gICAgICBwb3NpdGlvbi55ID0gMSAtIHBvc2l0aW9uLnlcbiAgICB9XG5cbiAgICB0aGlzLnNldCh7IHBvc2l0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gZmxpcCBjaGFuZ2VcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Sb3RhdGlvbk9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5RmxpcCAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCdmbGlwVmVydGljYWxseScgaW4gb3B0aW9ucyAmJlxuICAgICAgICBvcGVyYXRpb24uZ2V0RmxpcFZlcnRpY2FsbHkoKSAhPT0gb3B0aW9ucy5mbGlwVmVydGljYWxseSkge1xuICAgICAgdGhpcy5fYXBwbHlGbGlwRGlyZWN0aW9uKG9wZXJhdGlvbiwgJ3ZlcnRpY2FsJylcbiAgICB9XG5cbiAgICBpZiAoJ2ZsaXBIb3Jpem9udGFsbHknIGluIG9wdGlvbnMgJiZcbiAgICAgICAgb3BlcmF0aW9uLmdldEZsaXBIb3Jpem9udGFsbHkoKSAhPT0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbGx5KSB7XG4gICAgICB0aGlzLl9hcHBseUZsaXBEaXJlY3Rpb24ob3BlcmF0aW9uLCAnaG9yaXpvbnRhbCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgYSBmbGlwIHdpdGggdGhlIGdpdmVuIGRpcmVjdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUZsaXBEaXJlY3Rpb24gKG9wZXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSBvcGVyYXRpb24uZ2V0Um90YXRpb24oKVxuICAgIGlmIChyb3RhdGlvbiA9PT0gOTAgfHwgcm90YXRpb24gPT09IDI3MCkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBkaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb25cblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgcG9zaXRpb24ueCA9IDEgLSBwb3NpdGlvbi54XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIHBvc2l0aW9uLnkgPSAxIC0gcG9zaXRpb24ueVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHRoaXMuc2V0KHsgcG9zaXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSByYWRpYWwgYmx1ciB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwcml2YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX3JlbmRlcldlYkdMIChzZGspIHtcbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG4gICAgY29uc3Qgb3V0cHV0U3ByaXRlID0gc2RrLmdldFNwcml0ZSgpXG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHRoaXMuX2dldFJlbmRlclRleHR1cmUoc2RrKVxuXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUob3V0cHV0U3ByaXRlLmdldFRleHR1cmUoKSlcbiAgICBjb25zdCBzcHJpdGVCb3VuZHMgPSBvdXRwdXRTcHJpdGUuZ2V0Qm91bmRzKClcbiAgICBjb25zdCBvdXRwdXREaW1lbnNpb25zID0gbmV3IFZlY3RvcjIoc3ByaXRlQm91bmRzLndpZHRoLCBzcHJpdGVCb3VuZHMuaGVpZ2h0KVxuXG4gICAgLy8gSW52ZXJ0IFlcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKVxuICAgIHBvc2l0aW9uLm11bHRpcGx5KG91dHB1dERpbWVuc2lvbnMpXG5cbiAgICBjb25zdCB7IGJsdXJSYWRpdXMsIHJhZGl1cywgZ3JhZGllbnRSYWRpdXMgfSA9IHRoaXMuX29wdGlvbnNcbiAgICBjb25zdCBjb21tb25PcHRpb25zID0ge1xuICAgICAgYmx1clJhZGl1cywgcmFkaXVzLCBncmFkaWVudFJhZGl1cyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgdGV4U2l6ZTogb3V0cHV0RGltZW5zaW9uc1xuICAgIH1cblxuICAgIHRoaXMuX2hvcml6b250YWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG4gICAgdGhpcy5fdmVydGljYWxGaWx0ZXIuc2V0KGNvbW1vbk9wdGlvbnMpXG5cbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9zcHJpdGUuZ2V0Qm91bmRzKClcbiAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCkpXG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG4gICAgb3V0cHV0U3ByaXRlLnNldFRleHR1cmUocmVuZGVyVGV4dHVyZSlcbiAgICB0aGlzLnNldERpcnR5Rm9yUmVuZGVyZXIoZmFsc2UsIHJlbmRlcmVyKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcmFkaWFsIGJsdXIgdXNpbmcgQ2FudmFzMkRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9yZW5kZXJDYW52YXMgKHNkaykge1xuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaylcblxuICAgIGNvbnN0IHsgYmx1clJhZGl1cywgcmFkaXVzLCBncmFkaWVudFJhZGl1cywgcG9zaXRpb24gfSA9IHRoaXMuX29wdGlvbnNcbiAgICB0aGlzLl9maWx0ZXIuc2V0KHtcbiAgICAgIGJsdXJSYWRpdXMsIHJhZGl1cywgZ3JhZGllbnRSYWRpdXMsIHBvc2l0aW9uLFxuICAgICAgdGV4U2l6ZTogc2RrLmdldE91dHB1dERpbWVuc2lvbnMoKVxuICAgIH0pXG5cbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShvdXRwdXRTcHJpdGUuZ2V0VGV4dHVyZSgpKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRGaWx0ZXJzKFtcbiAgICAgIHRoaXMuX2ZpbHRlclxuICAgIF0pXG5cbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLl9zcHJpdGUuZ2V0Qm91bmRzKClcbiAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCkpXG4gICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcy5fY29udGFpbmVyKVxuICAgIG91dHB1dFNwcml0ZS5zZXRUZXh0dXJlKHJlbmRlclRleHR1cmUpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgfVxufVxuXG4vKipcbiAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICogb3BlcmF0aW9ucy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdFxuICovXG5SYWRpYWxGb2N1c09wZXJhdGlvbi5pZGVudGlmaWVyID0gJ3JhZGlhbC1mb2N1cydcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuUmFkaWFsRm9jdXNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHBvc2l0aW9uOiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC41LCAwLjUpIH0sXG4gIHJhZGl1czogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogNTAgfSxcbiAgZ3JhZGllbnRSYWRpdXM6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDI1IH0sXG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogJ251bWJlcicsIGRlZmF1bHQ6IDIwIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFkaWFsRm9jdXNPcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9yYWRpYWwtZm9jdXMtb3BlcmF0aW9uLmpzXG4gKiovIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFBob3RvRWRpdG9yU0RLLlxuICpcbiAqIENvcHlyaWdodCAoQykgMjAxNiA5ZWxlbWVudHMgR21iSCA8Y29udGFjdEA5ZWxlbWVudHMuY29tPlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGxpY2Vuc2UgYWdyZWVtZW50XG4gKiBpcyBhcHByb3ZlZCBhbmQgYSBsZWdhbC9maW5hbmNpYWwgY29udHJhY3Qgd2FzIHNpZ25lZCBieSB0aGUgdXNlci5cbiAqIFRoZSBsaWNlbnNlIGFncmVlbWVudCBjYW4gYmUgZm91bmQgdW5kZXIgZm9sbG93aW5nIGxpbms6XG4gKlxuICogaHR0cHM6Ly93d3cucGhvdG9lZGl0b3JzZGsuY29tL0xJQ0VOU0UudHh0XG4gKi9cblxuaW1wb3J0IHsgVXRpbHMsIFByb21pc2UsIExvZywgQ29uc3RhbnRzLCBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24nXG5cbmltcG9ydCBTcHJpdGUgZnJvbSAnLi9zcHJpdGVzL3Nwcml0ZSdcbmltcG9ydCBTdGlja2VyIGZyb20gJy4vc3ByaXRlcy9zdGlja2VyJ1xuaW1wb3J0IFRleHQgZnJvbSAnLi9zcHJpdGVzL3RleHQnXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgc3ByaXRlcyAodGV4dCBhbmQgc3RpY2tlcnMpIG9uIHRoZSBjYW52YXNcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9uc1xuICovXG5jbGFzcyBTcHJpdGVPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTcHJpdGVPcGVyYXRpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fcmVuZGVyZXJzID0ge31cblxuICAgIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlID0gdGhpcy5fb25PcGVyYXRpb25VcGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuX29uU3ByaXRlVXBkYXRlID0gdGhpcy5fb25TcHJpdGVVcGRhdGUuYmluZCh0aGlzKVxuICAgIHRoaXMuX3Nkay5vbihDb25zdGFudHMuRXZlbnRzLk9QRVJBVElPTl9VUERBVEVELCB0aGlzLl9vbk9wZXJhdGlvblVwZGF0ZSlcblxuICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLl9vcHRpb25zLnNwcml0ZXMuc2xpY2UoKVxuICAgIHNwcml0ZXMuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZVNwcml0ZShzcHJpdGUpXG4gICAgICB0aGlzLmFkZFNwcml0ZShzcHJpdGUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcHJpdGVzIHRoYXQgYXJlIGluc3RhbmNlcyBvZiB0aGUgZ2l2ZW4gY2xhc3NcbiAgICogQHBhcmFtICB7Q2xhc3N9IEtsYXNzXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlNwcml0ZVtdfVxuICAgKiBAdG9kbyAgIERvIHdlIHN0aWxsIG5lZWQgdGhpcz9cbiAgICovXG4gIGdldFNwcml0ZXNPZlR5cGUgKEtsYXNzKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5maWx0ZXIoKHNwcml0ZSkgPT5cbiAgICAgIHNwcml0ZSBpbnN0YW5jZW9mIEtsYXNzXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGFib3V0IHRvIGJlIHVwZGF0ZWQuIElmIHRoZSBjcm9wXG4gICAqIG9yIHJvdGF0aW9uIG9wZXJhdGlvbiBpcyB1cGRhdGVkLCB0aGlzIHdpbGwgYmUgcmVjb2duaXplZCBhbmQgdGhlXG4gICAqIHN0aWNrZXJzIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmdseVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbk9wZXJhdGlvblVwZGF0ZSAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZGVudGlmaWVyIH0gPSBvcGVyYXRpb24uY29uc3RydWN0b3JcblxuICAgIGlmIChpZGVudGlmaWVyID09PSAnY3JvcCcgJiZcbiAgICAgICAgJ3N0YXJ0JyBpbiBvcHRpb25zICYmXG4gICAgICAgICdlbmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2FwcGx5Q3JvcChvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgaWYgKGlkZW50aWZpZXIgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgIGlmICgncm90YXRpb24nIGluIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlSb3RhdGlvbihvcGVyYXRpb24sIG9wdGlvbnMpXG4gICAgICB9XG5cbiAgICAgIGlmICgnZmxpcFZlcnRpY2FsbHknIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICBvcGVyYXRpb24uZ2V0RmxpcFZlcnRpY2FsbHkoKSAhPT0gb3B0aW9ucy5mbGlwVmVydGljYWxseSkge1xuICAgICAgICB0aGlzLl9hcHBseUZsaXAob3BlcmF0aW9uLCAndmVydGljYWwnKVxuICAgICAgfVxuXG4gICAgICBpZiAoJ2ZsaXBIb3Jpem9udGFsbHknIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICBvcGVyYXRpb24uZ2V0RmxpcEhvcml6b250YWxseSgpICE9PSBvcHRpb25zLmZsaXBIb3Jpem9udGFsbHkpIHtcbiAgICAgICAgdGhpcy5fYXBwbHlGbGlwKG9wZXJhdGlvbiwgJ2hvcml6b250YWwnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCB3aXRoIHRoZSBnaXZlbiBkaXJlY3Rpb25cbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7U3RyaW5nfSBkaXJlY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseUZsaXAgKG9wZXJhdGlvbiwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSBvcGVyYXRpb24uZ2V0Um90YXRpb24oKVxuICAgIGlmIChyb3RhdGlvbiA9PT0gOTAgfHwgcm90YXRpb24gPT09IDI3MCkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICBkaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9vcHRpb25zLnNwcml0ZXMuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICBzcHJpdGUuYXBwbHlGbGlwKHRoaXMuX3NkaywgZGlyZWN0aW9uKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgd2hlbiBhIHNwcml0ZSBpcyBmbGFnZ2VkIGFzIGRpcnR5IC8gaXRzIG9wdGlvbnMgY2hhbmdlZFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNwcml0ZVVwZGF0ZSAoc3ByaXRlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5zZXREaXJ0eSh0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGdpdmVuIHJvdGF0aW9uIGNoYW5nZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlSb3RhdGlvbiAob3BlcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2xkUm90YXRpb24gPSBvcGVyYXRpb24uZ2V0Um90YXRpb24oKVxuICAgIGNvbnN0IG5ld1JvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvblxuICAgIGNvbnN0IGRlZ3JlZXNEaWZmZXJlbmNlID0gbmV3Um90YXRpb24gLSBvbGRSb3RhdGlvblxuXG4gICAgY29uc3QgZmluYWxEaW1lbnNpb25zID0gdGhpcy5fc2RrLmdldEZpbmFsRGltZW5zaW9ucygpXG4gICAgdGhpcy5fb3B0aW9ucy5zcHJpdGVzLmZvckVhY2goKHNwcml0ZSkgPT4ge1xuICAgICAgLy8gVXBkYXRlIHNwcml0ZSByb3RhdGlvblxuICAgICAgbGV0IHNwcml0ZURlZ3JlZXMgPSBzcHJpdGUuZ2V0Um90YXRpb24oKSAqIDE4MCAvIE1hdGguUElcbiAgICAgIHNwcml0ZURlZ3JlZXMgKz0gZGVncmVlc0RpZmZlcmVuY2VcbiAgICAgIHNwcml0ZS5zZXRSb3RhdGlvbihzcHJpdGVEZWdyZWVzICogTWF0aC5QSSAvIDE4MClcblxuICAgICAgLy8gRmxpcCBYIGFuZCBZIHVubGVzcyB3ZSdyZSByb3RhdGluZyBieSAxODAgZGVncmVlc1xuICAgICAgY29uc3Qgc3ByaXRlUG9zaXRpb24gPSBzcHJpdGUuZ2V0UG9zaXRpb24oKS5jbG9uZSgpXG4gICAgICBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IDkwIHx8IChvbGRSb3RhdGlvbiA9PT0gMjcwICYmIG5ld1JvdGF0aW9uID09PSAwKSkge1xuICAgICAgICBjb25zdCB0ZW1wWCA9IHNwcml0ZVBvc2l0aW9uLnhcbiAgICAgICAgc3ByaXRlUG9zaXRpb24ueCA9IGZpbmFsRGltZW5zaW9ucy55IC0gc3ByaXRlUG9zaXRpb24ueVxuICAgICAgICBzcHJpdGVQb3NpdGlvbi55ID0gdGVtcFhcbiAgICAgIH0gZWxzZSBpZiAoZGVncmVlc0RpZmZlcmVuY2UgPT09IC05MCB8fCAob2xkUm90YXRpb24gPT09IC0yNzAgJiYgbmV3Um90YXRpb24gPT09IDApKSB7XG4gICAgICAgIGNvbnN0IHRlbXBZID0gc3ByaXRlUG9zaXRpb24ueVxuICAgICAgICBzcHJpdGVQb3NpdGlvbi55ID0gZmluYWxEaW1lbnNpb25zLnggLSBzcHJpdGVQb3NpdGlvbi54XG4gICAgICAgIHNwcml0ZVBvc2l0aW9uLnggPSB0ZW1wWVxuICAgICAgfVxuICAgICAgc3ByaXRlLnNldFBvc2l0aW9uKHNwcml0ZVBvc2l0aW9uKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgZ2l2ZW4gY3JvcCBjaGFuZ2VcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5Dcm9wT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlDcm9wIChvcGVyYXRpb24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnB1dERpbWVuc2lvbnMgPSB0aGlzLl9zZGsuZ2V0SW5wdXREaW1lbnNpb25zKClcblxuICAgIGNvbnN0IG9sZFN0YXJ0ID0gb3BlcmF0aW9uLmdldFN0YXJ0KClcbiAgICBjb25zdCBuZXdTdGFydCA9IG9wdGlvbnMuc3RhcnRcblxuICAgIHRoaXMuX29wdGlvbnMuc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gc3ByaXRlLmdldFBvc2l0aW9uKCkuY2xvbmUoKVxuICAgICAgc3ByaXRlLnNldCh7XG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICAgICAgICAgIC5hZGQoXG4gICAgICAgICAgICBvbGRTdGFydC5jbG9uZSgpLnN1YnRyYWN0KG5ld1N0YXJ0KS5tdWx0aXBseShpbnB1dERpbWVuc2lvbnMpXG4gICAgICAgICAgKVxuICAgICAgfSwgZmFsc2UpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbk5hbWVcbiAgICogQHJldHVybiB7Kn0gb3B0aW9uTmFtZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9zZXJpYWxpemVPcHRpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAvLyBTaW5jZSBgc3ByaXRlc2AgaXMgYW4gYXJyYXkgb2YgY29uZmlndXJhYmxlcywgd2UgbmVlZFxuICAgIC8vIHRvIHNlcmlhbGl6ZSB0aGVtIGFzIHdlbGxcbiAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ3Nwcml0ZXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5zcHJpdGVzLm1hcCgoc3ByaXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBzcHJpdGUuc2VyaWFsaXplT3B0aW9ucygpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX3NlcmlhbGl6ZU9wdGlvbihvcHRpb25OYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3RpY2tlciBvYmplY3QgYW5kIHJldHVybnMgaXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlN0aWNrZXJ9XG4gICAqL1xuICBjcmVhdGVTdGlja2VyIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTdGlja2VyKHRoaXMsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdGlja2VyIG9iamVjdCBhbmQgcmV0dXJucyBpdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24uVGV4dH1cbiAgICovXG4gIGNyZWF0ZVRleHQgKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRleHQodGhpcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIGEgc3ByaXRlIGhhcyBiZWVuIGFkZGVkXG4gICAqIEBwYXJhbSB7UGhvdG9FZGl0b3JTREsuU3ByaXRlfSBzcHJpdGVcbiAgICovXG4gIGFkZFNwcml0ZSAoc3ByaXRlKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zcHJpdGVzLnB1c2goc3ByaXRlKVxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRDaGlsZChzcHJpdGUuZ2V0RGlzcGxheU9iamVjdCgpKVxuXG4gICAgLy8gVGhpcyBvcGVyYXRpb24gbmVlZHMgdG8gYmUgcmVyZW5kZXJlZFxuICAgIHRoaXMuc2V0RGlydHkodHJ1ZSlcblxuICAgIHNwcml0ZS5vbigndXBkYXRlJywgdGhpcy5fb25TcHJpdGVVcGRhdGUpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gc3ByaXRlIGZyb20gdGhlIGxpc3Qgb2Ygc3ByaXRlc1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNESy5TcHJpdGV9IHNwcml0ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgcmVtb3ZlU3ByaXRlIChzcHJpdGUpIHtcbiAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5fb3B0aW9ucy5zcHJpdGVzXG4gICAgY29uc3QgaW5kZXggPSBzcHJpdGVzLmluZGV4T2Yoc3ByaXRlKVxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHNwcml0ZS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uU3ByaXRlVXBkYXRlKVxuICAgICAgdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKHNwcml0ZS5nZXREaXNwbGF5T2JqZWN0KCkpXG5cbiAgICAgIHNwcml0ZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXIgKHNkaykge1xuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSB0aGlzLl9nZXRSZW5kZXJUZXh0dXJlKHNkaylcblxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkpXG5cbiAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXJcbiAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5fb3B0aW9ucy5zcHJpdGVzXG5cbiAgICBjb25zdCBvdXRwdXRCb3VuZHMgPSBvdXRwdXRTcHJpdGUuZ2V0Qm91bmRzKClcbiAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKG91dHB1dEJvdW5kcy53aWR0aCwgb3V0cHV0Qm91bmRzLmhlaWdodCkpXG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc3ByaXRlcy5tYXAoKHMpID0+IHMudmFsaWRhdGVTZXR0aW5ncygpKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgc3ByaXRlcy5mb3JFYWNoKChzcHJpdGUpID0+IHtcbiAgICAgICAgICBzcHJpdGUudXBkYXRlKHNkaylcbiAgICAgICAgfSlcblxuICAgICAgICByZW5kZXJUZXh0dXJlLmNsZWFyKClcbiAgICAgICAgcmVuZGVyVGV4dHVyZS5yZW5kZXIoY29udGFpbmVyKVxuICAgICAgICBvdXRwdXRTcHJpdGUuc2V0VGV4dHVyZShyZW5kZXJUZXh0dXJlKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgZ2l2ZW4gU3ByaXRlIHRvIGZyb250XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uLlNwcml0ZX0gc3ByaXRlXG4gICAqL1xuICB0YWtlU3ByaXRlVG9Gcm9udCAoc3ByaXRlKSB7XG4gICAgY29uc3QgeyBzcHJpdGVzIH0gPSB0aGlzLl9vcHRpb25zXG4gICAgY29uc3Qgc3ByaXRlSW5kZXggPSBzcHJpdGVzLmluZGV4T2Yoc3ByaXRlKVxuICAgIGlmIChzcHJpdGVJbmRleCA9PT0gLTEpIHJldHVyblxuXG4gICAgVXRpbHMubW92ZUFycmF5SXRlbShzcHJpdGVzLCBzcHJpdGVJbmRleCwgc3ByaXRlcy5sZW5ndGggLSAxKVxuXG4gICAgY29uc3QgZGlzcGxheU9iamVjdCA9IHNwcml0ZS5nZXREaXNwbGF5T2JqZWN0KClcbiAgICB0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoZGlzcGxheU9iamVjdClcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQoZGlzcGxheU9iamVjdClcblxuICAgIHRoaXMuc2V0RGlydHkodHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzcHJpdGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuTWF0aC5WZWN0b3IyfSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtDbGFzc30gW3R5cGVdXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLlNwcml0ZX1cbiAgICovXG4gIGdldFNwcml0ZUF0UG9zaXRpb24gKHBvc2l0aW9uLCB0eXBlKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5zcHJpdGVzLmZvckVhY2goKHMpID0+IHMudXBkYXRlKHRoaXMuX3NkaykpXG5cbiAgICAvLyBUcmFuc2xhdGUgY2FudmFzIHBvc2l0aW9uIHRvIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHNwcml0ZSBieVxuICAgIC8vIGFwcGx5aW5nIHRoZSBpbnZlcnNlIG9mIG91ciBvdXRwdXRTcHJpdGUncyB3b3JsZCB0cmFuc2Zvcm0gbWF0cml4XG4gICAgY29uc3Qgb3V0cHV0U3ByaXRlID0gdGhpcy5fc2RrLmdldFNwcml0ZSgpXG4gICAgY29uc3QgYWN0dWFsUG9zaXRpb24gPSBvdXRwdXRTcHJpdGVcbiAgICAgIC5nZXRXb3JsZFRyYW5zZm9ybSgpXG4gICAgICAuYXBwbHlJbnZlcnNlVG9WZWN0b3IocG9zaXRpb24pXG5cbiAgICAvLyBBcHBseSBhbmNob3JcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG91dHB1dFNwcml0ZS5nZXRUZXh0dXJlKCkuZ2V0RnJhbWUoKVxuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IG91dHB1dFNwcml0ZS5nZXRBbmNob3IoKS5jbG9uZSgpXG4gICAgICAubXVsdGlwbHkoLXdpZHRoLCAtaGVpZ2h0KVxuICAgIGFjdHVhbFBvc2l0aW9uLnN1YnRyYWN0KGFuY2hvck9mZnNldClcblxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW5nIHNwcml0ZVxuICAgIGxldCBpbnRlcnNlY3RpbmdTcHJpdGUgPSBudWxsXG4gICAgbGV0IHNwcml0ZXMgPSB0aGlzLl9vcHRpb25zLnNwcml0ZXMuc2xpY2UoMCkucmV2ZXJzZSgpXG4gICAgZm9yIChsZXQgaSA9IDAsIGMgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGM7IGkrKykge1xuICAgICAgY29uc3Qgc3ByaXRlID0gc3ByaXRlc1tpXVxuICAgICAgaWYgKHR5cGUgJiYgIShzcHJpdGUgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKHNwcml0ZS5nZXREaXNwbGF5T2JqZWN0KCkuaXNBdFBvc2l0aW9uKGFjdHVhbFBvc2l0aW9uKSkge1xuICAgICAgICBpbnRlcnNlY3RpbmdTcHJpdGUgPSBzcHJpdGVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGluZ1Nwcml0ZVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoaXMgb3BlcmF0aW9uXG4gICAqL1xuICBkaXNwb3NlICgpIHtcbiAgICB0aGlzLl9zZGsub2ZmKENvbnN0YW50cy5FdmVudHMuT1BFUkFUSU9OX1VQREFURUQsIHRoaXMuX29uT3BlcmF0aW9uVXBkYXRlKVxuICB9XG59XG5cblNwcml0ZU9wZXJhdGlvbi5TdGlja2VyID0gU3RpY2tlclxuU3ByaXRlT3BlcmF0aW9uLlRleHQgPSBUZXh0XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cblNwcml0ZU9wZXJhdGlvbi5pZGVudGlmaWVyID0gJ3Nwcml0ZSdcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuU3ByaXRlT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBzcHJpdGVzOiB7XG4gICAgdHlwZTogJ2FycmF5JywgZGVmYXVsdDogW10sXG4gICAgc2V0dGVyOiBmdW5jdGlvbiAoc3ByaXRlcywgaW5pdGlhbCkge1xuICAgICAgc3ByaXRlcyA9IHNwcml0ZXMubWFwKChzcHJpdGUsIGkpID0+IHtcbiAgICAgICAgaWYgKHNwcml0ZSBpbnN0YW5jZW9mIFNwcml0ZSkge1xuICAgICAgICAgIHJldHVybiBzcHJpdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gc3ByaXRlXG4gICAgICAgIGRlbGV0ZSBzcHJpdGUudHlwZVxuXG4gICAgICAgIC8vIENyZWF0ZSBzcHJpdGUgZnJvbSB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCh0aGlzLCBzcHJpdGUpXG4gICAgICAgICAgY2FzZSAnc3RpY2tlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0aWNrZXIodGhpcywgc3ByaXRlKVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBMb2cuZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnSW52YWxpZCBzcHJpdGUgdHlwZTogJyArIHNwcml0ZS50eXBlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyBSZW1vdmUgYWxsIHNwcml0ZXNcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5zcHJpdGVzKSB7XG4gICAgICAgICAgY29uc3Qgc3ByaXRlc1RvUmVtb3ZlID0gdGhpcy5fb3B0aW9ucy5zcHJpdGVzLnNsaWNlKClcbiAgICAgICAgICBzcHJpdGVzVG9SZW1vdmUuZm9yRWFjaCgoc3ByaXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNwcml0ZShzcHJpdGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBhbGwgc3ByaXRlc1xuICAgICAgICBzcHJpdGVzLmZvckVhY2goKHNwcml0ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkU3ByaXRlKHNwcml0ZSlcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwcml0ZXNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3ByaXRlT3BlcmF0aW9uXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvc3ByaXRlLW9wZXJhdGlvbi5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IFByb21pc2UsIEVuZ2luZSwgVmVjdG9yMiB9IGZyb20gJy4uLy4uL2dsb2JhbHMnXG5pbXBvcnQgU3ByaXRlIGZyb20gJy4vc3ByaXRlJ1xuaW1wb3J0IEFkanVzdG1lbnRzRmlsdGVyIGZyb20gJy4uL2FkanVzdG1lbnRzL2FkanVzdG1lbnRzLWZpbHRlcidcblxuLyoqXG4gKiBBIHN0aWNrZXIgdGhhdCBjYW4gYmUgZHJhd24gYnkgU3ByaXRlT3BlcmF0aW9uLiBTaG91bGQgb25seSBiZSBjcmVhdGVkIHZpYSB7QGxpbmsgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb24jY3JlYXRlU3RpY2tlcn1cbiAqIEBjbGFzc1xuICogQG1lbWJlcm9mIFBob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9uXG4gKi9cbmNsYXNzIFN0aWNrZXIgZXh0ZW5kcyBTcHJpdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdGlja2VyXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLLk9wZXJhdGlvbnMuU3ByaXRlT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncylcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLmltYWdlKSB7XG4gICAgICB0aGlzLl9vbkltYWdlVXBkYXRlKClcbiAgICB9XG5cbiAgICB0aGlzLl9yZW5kZXJUZXh0dXJlcyA9IHt9XG4gICAgdGhpcy5fYWRqdXN0bWVudHNGaWx0ZXIgPSBuZXcgQWRqdXN0bWVudHNGaWx0ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBjb25maWd1cmFibGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgc2VyaWFsaXplT3B0aW9ucyAoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHN1cGVyLnNlcmlhbGl6ZU9wdGlvbnMoKVxuICAgIG9wdGlvbnMudHlwZSA9ICdzdGlja2VyJ1xuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgdXBkYXRlIChzZGspIHtcbiAgICBzdXBlci51cGRhdGUoc2RrKVxuXG4gICAgY29uc3QgcmVuZGVyZXIgPSBzZGsuZ2V0UmVuZGVyZXIoKVxuXG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHRoaXMuX2dldFJlbmRlclRleHR1cmUocmVuZGVyZXIpXG4gICAgY29uc3QgaGFzQWRqdXN0bWVudHMgPSB0aGlzLl9oYXNBZGp1c3RtZW50cygpXG5cbiAgICB0aGlzLl9pZGVudGl0eVNwcml0ZS5zZXRGaWx0ZXJzKGhhc0FkanVzdG1lbnRzID8gW3RoaXMuX2FkanVzdG1lbnRzRmlsdGVyXSA6IFtdKVxuXG4gICAgLy8gU3RpY2tlcnMgd2l0aCBhZGp1c3RtZW50cyBhcmUgcmVuZGVyZWQgdG8gYSByZW5kZXIgdGV4dHVyZSB0aGF0XG4gICAgLy8gY2FuIGJlIHJlLXVzZWRcbiAgICBpZiAoaGFzQWRqdXN0bWVudHMpIHtcbiAgICAgIHRoaXMuX2lkZW50aXR5U3ByaXRlLnNldFRleHR1cmUodGhpcy5faW5wdXRUZXh0dXJlKVxuXG4gICAgICBjb25zdCBhZGp1c3RtZW50cyA9IHRoaXMuX29wdGlvbnMuYWRqdXN0bWVudHNcbiAgICAgIHRoaXMuX2FkanVzdG1lbnRzRmlsdGVyLnNldCh7XG4gICAgICAgIGJyaWdodG5lc3M6IGFkanVzdG1lbnRzLmdldEJyaWdodG5lc3MoKSxcbiAgICAgICAgc2F0dXJhdGlvbjogYWRqdXN0bWVudHMuZ2V0U2F0dXJhdGlvbigpLFxuICAgICAgICBjb250cmFzdDogYWRqdXN0bWVudHMuZ2V0Q29udHJhc3QoKVxuICAgICAgfSlcblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9vcHRpb25zLmltYWdlXG4gICAgICByZW5kZXJUZXh0dXJlLnJlc2l6ZVRvKG5ldyBWZWN0b3IyKHdpZHRoLCBoZWlnaHQpKVxuICAgICAgcmVuZGVyVGV4dHVyZS5jbGVhcigpXG4gICAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9pZGVudGl0eVNwcml0ZSlcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHJlbmRlclRleHR1cmUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX2lucHV0VGV4dHVyZSlcbiAgICB9XG5cbiAgICAvLyBGbGlwXG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zcHJpdGUuZ2V0U2NhbGUoKVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmZsaXBWZXJ0aWNhbGx5KSB7XG4gICAgICBzY2FsZS55ICo9IC0xXG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmZsaXBIb3Jpem9udGFsbHkpIHtcbiAgICAgIHNjYWxlLnggKj0gLTFcbiAgICB9XG4gICAgdGhpcy5fc3ByaXRlLnNldFNjYWxlKHNjYWxlKVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQvb3IgcmV0dXJucyBhIFJlbmRlclRleHR1cmVcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5FbmdpbmUuQmFzZVJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQaG90b0VkaXRvclNESy5FbmdpbmUuUmVuZGVyVGV4dHVyZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZW5kZXJUZXh0dXJlIChyZW5kZXJlcikge1xuICAgIGlmICghdGhpcy5fcmVuZGVyVGV4dHVyZXNbcmVuZGVyZXIuaWRdKSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuX29wdGlvbnMuaW1hZ2VcbiAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVzW3JlbmRlcmVyLmlkXSA9XG4gICAgICAgIG5ldyBFbmdpbmUuUmVuZGVyVGV4dHVyZShyZW5kZXJlciwgd2lkdGgsIGhlaWdodCwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmVzW3JlbmRlcmVyLmlkXVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIHN0aWNrZXIgaGFzIGFueSBhZGp1c3RtZW50cyBhbmQgYSBmaWx0ZXIgaXMgbmVlZGVkXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFzQWRqdXN0bWVudHMgKCkge1xuICAgIGNvbnN0IGFkanVzdG1lbnRzID0gdGhpcy5fb3B0aW9ucy5hZGp1c3RtZW50c1xuICAgIHJldHVybiBhZGp1c3RtZW50cy5nZXRCcmlnaHRuZXNzKCkgIT09IDAgfHxcbiAgICAgIGFkanVzdG1lbnRzLmdldFNhdHVyYXRpb24oKSAhPT0gMSB8fFxuICAgICAgYWRqdXN0bWVudHMuZ2V0Q29udHJhc3QoKSAhPT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBzdGlja2VyJ3MgaW1hZ2UgaXMgdXBkYXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uSW1hZ2VVcGRhdGUgKCkge1xuICAgIHRoaXMuX2lucHV0VGV4dHVyZSA9IEVuZ2luZS5UZXh0dXJlLmZyb21JbWFnZSh0aGlzLl9vcHRpb25zLmltYWdlKVxuICAgIHRoaXMuX2lkZW50aXR5U3ByaXRlLnNldFRleHR1cmUodGhpcy5faW5wdXRUZXh0dXJlKVxuICAgIHRoaXMuX3Nwcml0ZS5zZXRUZXh0dXJlKHRoaXMuX2lucHV0VGV4dHVyZSlcbiAgICB0aGlzLnNldERpcnR5KHRydWUpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHZhbGlkYXRlcyBpdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXBkYXRlID0gdHJ1ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHNldE9wdGlvbiAob3B0aW9uTmFtZSwgdmFsdWUsIHVwZGF0ZSA9IHRydWUpIHtcbiAgICBzdXBlci5zZXRPcHRpb24ob3B0aW9uTmFtZSwgdmFsdWUsIHVwZGF0ZSlcblxuICAgIGlmIChvcHRpb25OYW1lID09PSAnaW1hZ2UnICYmIHRoaXMuX2lkZW50aXR5U3ByaXRlKSB7XG4gICAgICB0aGlzLl9vbkltYWdlVXBkYXRlKClcbiAgICB9XG4gIH1cbn1cblxuU3RpY2tlci5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgbmFtZTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJycgfSxcbiAgaW1hZ2U6IHsgdHlwZTogJ29iamVjdCcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIHBvc2l0aW9uOiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMCwgMCkgfSxcbiAgc2NhbGU6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigxLjAsIDEuMCkgfSxcbiAgYW5jaG9yOiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC4wLCAwLjApIH0sXG4gIHBpdm90OiB7IHR5cGU6ICd2ZWN0b3IyJywgZGVmYXVsdDogbmV3IFZlY3RvcjIoMC41LCAwLjUpIH0sXG4gIHJvdGF0aW9uOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gIGZsaXBIb3Jpem9udGFsbHk6IHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9LFxuICBmbGlwVmVydGljYWxseTogeyB0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHQ6IGZhbHNlIH0sXG4gIGFkanVzdG1lbnRzOiB7IHR5cGU6ICdjb25maWd1cmFibGUnLCBzdHJ1Y3R1cmU6IHtcbiAgICBicmlnaHRuZXNzOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAwIH0sXG4gICAgc2F0dXJhdGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMSB9LFxuICAgIGNvbnRyYXN0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxIH1cbiAgfX1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RpY2tlclxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9vcGVyYXRpb25zL3Nwcml0ZXMvc3RpY2tlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmltcG9ydCB7IENvbG9yLCBWZWN0b3IyIH0gZnJvbSAnLi4vLi4vZ2xvYmFscydcbmltcG9ydCBTcHJpdGUgZnJvbSAnLi9zcHJpdGUnXG5pbXBvcnQgVGV4dFJlbmRlcmVyIGZyb20gJy4vdGV4dC90ZXh0LXJlbmRlcmVyJ1xuXG4vKipcbiAqIEEgdGV4dCB0aGF0IGNhbiBiZSBkcmF3biBieSBTcHJpdGVPcGVyYXRpb24uIFNob3VsZCBvbmx5IGJlIGNyZWF0ZWQgdmlhIHtAbGluayBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zLlNwcml0ZU9wZXJhdGlvbiNjcmVhdGVUZXh0fVxuICogQGNsYXNzXG4gKiBAbWVtYmVyb2YgUGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb25cbiAqL1xuY2xhc3MgVGV4dCBleHRlbmRzIFNwcml0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRleHRcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREsuT3BlcmF0aW9ucy5TcHJpdGVPcGVyYXRpb259IG9wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgdGhpcy5fdGV4dFJlbmRlcmVyID0gbmV3IFRleHRSZW5kZXJlcih0aGlzLCB0aGlzLl9vcGVyYXRpb24pXG4gICAgdGhpcy5fc3ByaXRlLnNldFRleHR1cmUodGhpcy5fdGV4dFJlbmRlcmVyLmdldFRleHR1cmUoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgY29uZmlndXJhYmxlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHNlcmlhbGl6ZU9wdGlvbnMgKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzdXBlci5zZXJpYWxpemVPcHRpb25zKClcbiAgICBvcHRpb25zLnR5cGUgPSAndGV4dCdcbiAgICByZXR1cm4gb3B0aW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHlsZSBvYmplY3QgZm9yIHRoaXMgdGV4dFxuICAgKiBAcGFyYW0ge1Bob3RvRWRpdG9yU0RLfSBTREtcbiAgICogQHBhcmFtIHtQaG90b0VkaXRvclNESy5NYXRoLlZlY3RvcjJ9IG91dHB1dERpbWVuc2lvbnNcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0RE9NU3R5bGUgKHNkaywgb3V0cHV0RGltZW5zaW9ucykge1xuICAgIGNvbnN0IHRleHRPcHRpb25zID0gdGhpcy5fdGV4dFJlbmRlcmVyLmNhbGN1bGF0ZUZvbnRTdHlsZXMoc2RrLCB0cnVlKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuX29wdGlvbnMuZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaXplOiB0ZXh0T3B0aW9ucy5mb250U2l6ZSxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuX29wdGlvbnMuZm9udEZhbWlseSxcbiAgICAgIGxpbmVIZWlnaHQ6IHRleHRPcHRpb25zLmxpbmVIZWlnaHQgKyAncHgnLFxuICAgICAgY29sb3I6IHRoaXMuX29wdGlvbnMuY29sb3IudG9SR0JBKCksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX29wdGlvbnMuYmFja2dyb3VuZENvbG9yLnRvUkdCQSgpLFxuICAgICAgdGV4dEFsaWduOiB0aGlzLl9vcHRpb25zLmFsaWdubWVudFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIHRoaXMgdGV4dFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGNvbnNpZGVyWm9vbSA9IGZhbHNlXG4gICAqIEByZXR1cm4ge1Bob3RvRWRpdG9yU0RLLk1hdGguVmVjdG9yMn1cbiAgICovXG4gIGdldEJvdW5kaW5nQm94IChzZGssIGNvbnNpZGVyWm9vbSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRSZW5kZXJlci5nZXRCb3VuZGluZ0JveChzZGssIGNvbnNpZGVyWm9vbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGEgZmxpcCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZGlyZWN0aW9uXG4gICAqL1xuICBhcHBseUZsaXAgKGRpcmVjdGlvbikge1xuICAgIHN1cGVyLmFwcGx5RmxpcChkaXJlY3Rpb24pXG5cbiAgICBsZXQgcm90YXRpb24gPSB0aGlzLl9vcHRpb25zLnJvdGF0aW9uXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICByb3RhdGlvbiArPSAoTWF0aC5QSSAtIHJvdGF0aW9uKSAqIDJcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbilcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgcm90YXRpb24gKz0gKE1hdGguUEkgLyAyIC0gcm90YXRpb24pICogMlxuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgc3ByaXRlXG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIHVwZGF0ZSAoc2RrKSB7XG4gICAgLy8gUmUtcmVuZGVyIHRleHRcbiAgICB0aGlzLl90ZXh0UmVuZGVyZXIudXBkYXRlKHNkaylcbiAgICBjb25zdCB0ZXh0VGV4dHVyZSA9IHRoaXMuX3RleHRSZW5kZXJlci5nZXRUZXh0dXJlKClcbiAgICBjb25zdCBiYXNlVGV4dHVyZSA9IHRleHRUZXh0dXJlLmdldEJhc2VUZXh0dXJlKClcbiAgICBiYXNlVGV4dHVyZS51cGRhdGUoKVxuXG4gICAgLy8gVXBsb2FkIHRleHR1cmVcbiAgICBjb25zdCByZW5kZXJlciA9IHNkay5nZXRSZW5kZXJlcigpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChyZW5kZXJlci5pc09mVHlwZSgnd2ViZ2wnKSkge1xuICAgICAgcmVuZGVyZXIudXBkYXRlVGV4dHVyZSh0ZXh0VGV4dHVyZS5nZXRCYXNlVGV4dHVyZSgpKVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci51cGRhdGUoc2RrKVxuICB9XG59XG5cblRleHQucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGZvbnRTaXplOiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAzMCB9LFxuICBsaW5lSGVpZ2h0OiB7IHR5cGU6ICdudW1iZXInLCBkZWZhdWx0OiAxLjEgfSxcbiAgZm9udEZhbWlseTogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJ1RpbWVzIE5ldyBSb21hbicgfSxcbiAgZm9udFdlaWdodDogeyB0eXBlOiAnc3RyaW5nJywgZGVmYXVsdDogJ25vcm1hbCcgfSxcbiAgYWxpZ25tZW50OiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAnbGVmdCcsIGF2YWlsYWJsZTogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddIH0sXG4gIHZlcnRpY2FsQWxpZ25tZW50OiB7IHR5cGU6ICdzdHJpbmcnLCBkZWZhdWx0OiAndG9wJywgYXZhaWxhYmxlOiBbJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJ10gfSxcbiAgY29sb3I6IHsgdHlwZTogJ2NvbG9yJywgZGVmYXVsdDogbmV3IENvbG9yKDEsIDAsIDAsIDEpIH0sXG4gIGJhY2tncm91bmRDb2xvcjogeyB0eXBlOiAnY29sb3InLCBkZWZhdWx0OiBuZXcgQ29sb3IoMCwgMCwgMCwgMCkgfSxcbiAgcG9zaXRpb246IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLCAwKSB9LFxuICBhbmNob3I6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLjUsIDAuNSkgfSxcbiAgcGl2b3Q6IHsgdHlwZTogJ3ZlY3RvcjInLCBkZWZhdWx0OiBuZXcgVmVjdG9yMigwLCAwKSB9LFxuICByb3RhdGlvbjogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICB0ZXh0OiB7IHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICBtYXhXaWR0aDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMTAwIH0sXG4gIG1heEhlaWdodDogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LFxuICBmbGlwSG9yaXpvbnRhbGx5OiB7IHR5cGU6ICdib29sZWFuJywgZGVmYXVsdDogZmFsc2UgfSxcbiAgZmxpcFZlcnRpY2FsbHk6IHsgdHlwZTogJ2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZSB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9zcHJpdGVzL3RleHQuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9taXNlLCBFbmdpbmUsIFZlY3RvcjIsIFV0aWxzIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscydcbmltcG9ydCBUZXh0U3BsaXR0ZXIgZnJvbSAnLi90ZXh0LXNwbGl0dGVyJ1xuXG5jbGFzcyBUZXh0UmVuZGVyZXIge1xuICBjb25zdHJ1Y3RvciAodGV4dCwgb3BlcmF0aW9uKSB7XG4gICAgdGhpcy5fdGV4dCA9IHRleHRcbiAgICB0aGlzLl9vcGVyYXRpb24gPSBvcGVyYXRpb25cblxuICAgIHRoaXMuX2NyZWF0ZUNhbnZhcygpXG4gICAgdGhpcy5fY3JlYXRlVGV4dHVyZSgpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgY2FudmFzIGFuZCBpbml0aWFsaXplcyB0aGUgdGV4dCBzcGxpdHRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNhbnZhcyAoKSB7XG4gICAgdGhpcy5fY2FudmFzID0gVXRpbHMuY3JlYXRlQ2FudmFzKClcbiAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICB0aGlzLl90ZXh0U3BsaXR0ZXIgPSBuZXcgVGV4dFNwbGl0dGVyKHRoaXMuX2NvbnRleHQpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgdGV4dHVyZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZVRleHR1cmUgKCkge1xuICAgIHRoaXMuX3RleHR1cmUgPSBFbmdpbmUuVGV4dHVyZS5mcm9tQ2FudmFzKHRoaXMuX2NhbnZhcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSB0ZXh0IG9wdGlvbnMgb24gdGhlIGdpdmVuIGNvbnRleHRcbiAgICogQHBhcmFtICB7T2JqZWN0fSB0ZXh0T3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5VGV4dE9wdGlvbnMgKHRleHRPcHRpb25zKSB7XG4gICAgdGhpcy5fY29udGV4dC5mb250ID0gdGhpcy5fdGV4dC5nZXRGb250V2VpZ2h0KCkgKyAnICcgK1xuICAgICAgdGV4dE9wdGlvbnMuZm9udFNpemUgKyAncHggJyArXG4gICAgICB0aGlzLl90ZXh0LmdldEZvbnRGYW1pbHkoKVxuICAgIHRoaXMuX2NvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCdcbiAgICB0aGlzLl9jb250ZXh0LnRleHRBbGlnbiA9IHRoaXMuX3RleHQuZ2V0QWxpZ25tZW50KClcbiAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX3RleHQuZ2V0Q29sb3IoKS50b1JHQkEoKVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgbGluZXMgYW5kIHNwbGl0IHRoZW0gaW50byBtdWx0aXBsZSBsaW5lcywgZGVwZW5kaW5nXG4gICAqIG9uIHRoZSB3aWR0aCB0aGV5IG5lZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFdpZHRoXG4gICAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkT3V0cHV0TGluZXMgKG1heFdpZHRoKSB7XG4gICAgdGhpcy5fdGV4dFNwbGl0dGVyLnNldFRleHQodGhpcy5fdGV4dC5nZXRUZXh0KCkpXG4gICAgdGhpcy5fdGV4dFNwbGl0dGVyLnNldE1heFdpZHRoKG1heFdpZHRoKVxuICAgIHJldHVybiB0aGlzLl90ZXh0U3BsaXR0ZXIuZ2V0TGluZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBnaXZlbiBsaW5lIG9udG8gY29udGV4dCBhdCB0aGUgZ2l2ZW4gWSBwb3NpdGlvblxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHRleHRcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVGV4dExpbmUgKHRleHQsIHkpIHtcbiAgICBjb25zdCB0ZXh0QWxpZ25tZW50ID0gdGhpcy5fdGV4dC5nZXRBbGlnbm1lbnQoKVxuICAgIGlmICh0ZXh0QWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0aGlzLl9jYW52YXMud2lkdGggLyAyLCB5KVxuICAgIH0gZWxzZSBpZiAodGV4dEFsaWdubWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIDAsIHkpXG4gICAgfSBlbHNlIGlmICh0ZXh0QWxpZ25tZW50ID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHQsIHRoaXMuX2NhbnZhcy53aWR0aCwgeSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGlzIHNwcml0ZVxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgdXBkYXRlIChzZGspIHtcbiAgICBjb25zdCB0ZXh0T3B0aW9ucyA9IHRoaXMuY2FsY3VsYXRlRm9udFN0eWxlcyhzZGspXG4gICAgY29uc3QgeyBib3VuZGluZ0JveCwgbGluZXMgfSA9IHRoaXMuX2NhbGN1bGF0ZVRleHQoc2RrLCB0ZXh0T3B0aW9ucylcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dChzZGssIGJvdW5kaW5nQm94LCBsaW5lcywgdGV4dE9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgdGV4dFxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGJvdW5kaW5nQm94XG4gICAqIEBwYXJhbSAge0FycmF5LjxTdHJpbmc+fSBsaW5lc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHRPcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVGV4dCAoc2RrLCBib3VuZGluZ0JveCwgbGluZXMsIHRleHRPcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFJlc2l6ZSB0aGUgY2FudmFzXG4gICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBib3VuZGluZ0JveC54XG4gICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gYm91bmRpbmdCb3gueVxuXG4gICAgICBpZiAodGhpcy5fdGV4dC5nZXRNYXhIZWlnaHQoKSkge1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gTWF0aC5taW4oXG4gICAgICAgICAgdGhpcy5fdGV4dC5nZXRNYXhIZWlnaHQoKSxcbiAgICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZXh0XG4gICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJylcblxuICAgICAgLy8gUmVuZGVyIGJhY2tncm91bmQgY29sb3JcbiAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5fdGV4dC5nZXRCYWNrZ3JvdW5kQ29sb3IoKS50b1JHQkEoKVxuICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCgwLCAwLCBib3VuZGluZ0JveC54LCBib3VuZGluZ0JveC55KVxuXG4gICAgICAvLyBBcHBseSB0ZXh0IG9wdGlvbnNcbiAgICAgIHRoaXMuX2FwcGx5VGV4dE9wdGlvbnModGV4dE9wdGlvbnMpXG5cbiAgICAgIC8vIERyYXcgbGluZXNcbiAgICAgIGZvciAodmFyIGxpbmVOdW0gPSAwOyBsaW5lTnVtIDwgbGluZXMubGVuZ3RoOyBsaW5lTnVtKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2xpbmVOdW1dXG4gICAgICAgIHRoaXMuX3JlbmRlclRleHRMaW5lKGxpbmUsIHRleHRPcHRpb25zLmxpbmVIZWlnaHQgKiBsaW5lTnVtKVxuICAgICAgfVxuXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGFjdHVhbCBmb250IHNpemUgYW5kIGxpbmUgaGVpZ2h0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY29uc2lkZXJab29tXG4gICAqL1xuICBjYWxjdWxhdGVGb250U3R5bGVzIChzZGssIGNvbnNpZGVyWm9vbSA9IGZhbHNlKSB7XG4gICAgbGV0IGZvbnRTaXplID0gdGhpcy5fdGV4dC5nZXRGb250U2l6ZSgpXG4gICAgbGV0IGxpbmVIZWlnaHQgPSB0aGlzLl90ZXh0LmdldExpbmVIZWlnaHQoKSAqIGZvbnRTaXplXG5cbiAgICBpZiAoY29uc2lkZXJab29tKSB7XG4gICAgICBjb25zdCB6b29tID0gc2RrLmdldFpvb20oKVxuICAgICAgZm9udFNpemUgKj0gem9vbVxuICAgICAgbGluZUhlaWdodCAqPSB6b29tXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZm9udFNpemUsIGxpbmVIZWlnaHQgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGJvdW5kaW5nIGJveCBhbmQgbmV3IGxpbmVzIGFjY29yZGluZyB0byBtYXggd2lkdGhcbiAgICogQHBhcmFtICB7UGhvdG9FZGl0b3JTREt9IHNka1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRleHRPcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWxjdWxhdGVUZXh0IChzZGssIHRleHRPcHRpb25zKSB7XG4gICAgLy8gQ2FsY3VsYXRlIG1heCB3aWR0aFxuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMuX3RleHQuZ2V0TWF4V2lkdGgoKVxuXG4gICAgLy8gQXBwbHkgdGV4dCBvcHRpb25zXG4gICAgdGhpcy5fYXBwbHlUZXh0T3B0aW9ucyh0ZXh0T3B0aW9ucylcblxuICAgIC8vIENhbGN1bGF0ZSBib3VuZGluZyBib3hcbiAgICBsZXQgYm91bmRpbmdCb3ggPSBuZXcgVmVjdG9yMigpXG4gICAgbGV0IGxpbmVzID0gdGhpcy5fdGV4dC5nZXRUZXh0KCkuc3BsaXQoJ1xcbicpXG4gICAgaWYgKHR5cGVvZiBtYXhXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94XG4gICAgICBib3VuZGluZ0JveC54ID0gbWF4V2lkdGhcbiAgICAgIGxpbmVzID0gdGhpcy5fYnVpbGRPdXRwdXRMaW5lcyhtYXhXaWR0aClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgbGluZU51bSA9IDA7IGxpbmVOdW0gPCBsaW5lcy5sZW5ndGg7IGxpbmVOdW0rKykge1xuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbbGluZU51bV1cbiAgICAgICAgYm91bmRpbmdCb3gueCA9IE1hdGgubWF4KGJvdW5kaW5nQm94LngsIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQobGluZSkud2lkdGgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGJvdW5kaW5nYm94IGhlaWdodFxuICAgIGJvdW5kaW5nQm94LnkgPSB0ZXh0T3B0aW9ucy5saW5lSGVpZ2h0ICogbGluZXMubGVuZ3RoXG5cbiAgICByZXR1cm4geyBib3VuZGluZ0JveCwgbGluZXMgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyByZW5kZXJlcidzIHRleHR1cmVcbiAgICogQHJldHVybiB7RW5naW5lLlRleHR1cmV9XG4gICAqL1xuICBnZXRUZXh0dXJlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhpcyB0ZXh0XG4gICAqIEBwYXJhbSAge1Bob3RvRWRpdG9yU0RLfSBzZGtcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gY29uc2lkZXJab29tID0gZmFsc2VcbiAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICovXG4gIGdldEJvdW5kaW5nQm94IChzZGssIGNvbnNpZGVyWm9vbSA9IGZhbHNlKSB7XG4gICAgY29uc3QgdGV4dE9wdGlvbnMgPSB0aGlzLmNhbGN1bGF0ZUZvbnRTdHlsZXMoc2RrKVxuICAgIGNvbnN0IHsgYm91bmRpbmdCb3ggfSA9IHRoaXMuX2NhbGN1bGF0ZVRleHQoc2RrLCB0ZXh0T3B0aW9ucylcbiAgICBpZiAoY29uc2lkZXJab29tKSB7XG4gICAgICBib3VuZGluZ0JveC5tdWx0aXBseShzZGsuZ2V0Wm9vbSgpKVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRpbmdCb3hcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUZXh0UmVuZGVyZXJcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy9zcHJpdGVzL3RleHQvdGV4dC1yZW5kZXJlci5qc1xuICoqLyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBQaG90b0VkaXRvclNESy5cbiAqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTYgOWVsZW1lbnRzIEdtYkggPGNvbnRhY3RAOWVsZW1lbnRzLmNvbT5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBsaWNlbnNlIGFncmVlbWVudFxuICogaXMgYXBwcm92ZWQgYW5kIGEgbGVnYWwvZmluYW5jaWFsIGNvbnRyYWN0IHdhcyBzaWduZWQgYnkgdGhlIHVzZXIuXG4gKiBUaGUgbGljZW5zZSBhZ3JlZW1lbnQgY2FuIGJlIGZvdW5kIHVuZGVyIGZvbGxvd2luZyBsaW5rOlxuICpcbiAqIGh0dHBzOi8vd3d3LnBob3RvZWRpdG9yc2RrLmNvbS9MSUNFTlNFLnR4dFxuICovXG5cbmNsYXNzIFRleHRTcGxpdHRlciB7XG4gIGNvbnN0cnVjdG9yIChjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcbiAgICB0aGlzLl9sYXN0Rm9udFN0eWxlID0ge31cbiAgICB0aGlzLl9jaGFyYWN0ZXJXaWR0aENhY2hlID0ge31cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaW5lcyB0aGF0IGZpdCB0aGUgbWF4V2lkdGhcbiAgICogQHJldHVybiB7QXJyYXkuPFN0cmluZz59XG4gICAqL1xuICBnZXRMaW5lcyAoKSB7XG4gICAgaWYgKHRoaXMuX2ZvbnRTdHlsZUNoYW5nZWQoKSkge1xuICAgICAgdGhpcy5fY2hhcmFjdGVyV2lkdGhDYWNoZSA9IHt9XG4gICAgfVxuXG4gICAgbGV0IGxpbmVzID0gW11cbiAgICBsZXQgbmV3TGluZVdvcmRzID0gW11cblxuICAgIC8vIEl0ZXJhdGUgb3ZlciBsaW5lc1xuICAgIGNvbnN0IGxpbmVzQ291bnQgPSB0aGlzLl9saW5lcy5sZW5ndGhcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGxpbmVzQ291bnQ7IGwrKykge1xuICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2xpbmVzW2xdXG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciB3b3Jkc1xuICAgICAgY29uc3Qgd29yZHMgPSB0aGlzLl9idWlsZFdvcmRzKGxpbmUpXG4gICAgICBjb25zdCB3b3Jkc0NvdW50ID0gd29yZHMubGVuZ3RoXG4gICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdvcmRzQ291bnQ7IHcrKykge1xuICAgICAgICBjb25zdCB3b3JkID0gd29yZHNbd11cblxuICAgICAgICAvLyBDaGVjayBpZiBsaW5lIGlzIHRvbyB3aWRlIGZvciB0aGUgbWF4d2lkdGhcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gbmV3TGluZVdvcmRzLmNvbmNhdCh3b3JkKS5qb2luKCcnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHMrJC9pLCAnJylcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl9nZXRXaWR0aChjdXJyZW50TGluZSlcbiAgICAgICAgaWYgKHdpZHRoID4gdGhpcy5fbWF4V2lkdGgpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBoYXZlIGJlZW4gd29yZHMgYmVmb3JlIHRoaXMgb25lLCBzdGFydFxuICAgICAgICAgIC8vIGEgbmV3IGxpbmVcbiAgICAgICAgICBpZiAobmV3TGluZVdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIExpbmUgdG9vIGxvbmcgLT4gbGluZSBlbmRlZFxuICAgICAgICAgICAgbGluZXMucHVzaChuZXdMaW5lV29yZHMuam9pbignJykpXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGxpbmUgd2l0aCB0aGUgd29yZFxuICAgICAgICAgICAgbmV3TGluZVdvcmRzID0gW3dvcmRdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIG5leHQgd29yZCBpcyB0b28gbG9uZyAod2l0aG91dCB0cmFpbGluZyBzcGFjZXMpLCBzcGxpdCBpdCB1cFxuICAgICAgICAgIGNvbnN0IF93b3JkID0gd29yZC5yZXBsYWNlKC9cXHMrJC9pLCAnJylcbiAgICAgICAgICBpZiAodGhpcy5fZ2V0V2lkdGgoX3dvcmQpID4gdGhpcy5fbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwbGl0V29yZCA9IHRoaXMuX3NwbGl0V29yZCh3b3JkKVxuICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQoc3BsaXRXb3JkLmxpbmVzKVxuICAgICAgICAgICAgaWYgKHNwbGl0V29yZC5yZXN0KSB7XG4gICAgICAgICAgICAgIG5ld0xpbmVXb3JkcyA9IFtzcGxpdFdvcmQucmVzdF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGluZVdvcmRzLnB1c2god29yZClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lcy5wdXNoKG5ld0xpbmVXb3Jkcy5qb2luKCcnKSlcbiAgICAgIG5ld0xpbmVXb3JkcyA9IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGFycmF5IG9mIHdvcmRzIGZyb20gdGhlIGdpdmVuIGxpbmVcbiAgICogQHBhcmFtICB7U3RyaW5nfSBsaW5lXG4gICAqIEByZXR1cm4ge0FycmF5LjxTdHJpbmc+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2J1aWxkV29yZHMgKGxpbmUpIHtcbiAgICBsZXQgd29yZHMgPSBbXVxuICAgIGxldCB3b3JkID0gJydcblxuICAgIGNvbnN0IGxlbiA9IGxpbmUubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IGxpbmVbaV1cbiAgICAgIHdvcmQgKz0gY2hhclxuICAgICAgaWYgKGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnLScgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpXG4gICAgICAgIHdvcmQgPSAnJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3b3Jkc1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyB1cCB0aGUgZ2l2ZW4gd29yZCB0byBmaXQgdGhlIG1heCB3aWR0aFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHdvcmRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NwbGl0V29yZCAod29yZCkge1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIGxpbmVzOiBbXSxcbiAgICAgIHJlc3Q6IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCB3b3JkTGVuZ3RoID0gd29yZC5sZW5ndGhcbiAgICBsZXQgY2hhcnMgPSBbXVxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgd29yZExlbmd0aDsgYysrKSB7XG4gICAgICBjb25zdCBjaGFyID0gd29yZFtjXVxuICAgICAgaWYgKHRoaXMuX2dldFdpZHRoKGNoYXJzLmNvbmNhdChjaGFyKS5qb2luKCcnKSkgPiB0aGlzLl9tYXhXaWR0aCkge1xuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3BvbnNlLmxpbmVzLnB1c2goY2hhcnMuam9pbignJykpXG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMgPSBbY2hhcl1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJzLnB1c2goY2hhcilcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPT09IHdvcmRMZW5ndGggLSAxICYmIGNoYXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzcG9uc2UucmVzdCA9IGNoYXJzLmpvaW4oJycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmb250IHN0eWxlIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBjYWxsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9udFN0eWxlQ2hhbmdlZCAoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHQuZm9udCAhPT0gdGhpcy5fbGFzdEZvbnRTdHlsZSkge1xuICAgICAgdGhpcy5fbGFzdEZvbnRTdHlsZSA9IHRoaXMuX2NvbnRleHQuZm9udFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWVhc3VyZWQgd2lkdGggZm9yIHRoZSBnaXZlbiBzdHJpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFdpZHRoIChzdHJpbmcpIHtcbiAgICBsZXQgd2lkdGggPSAwXG4gICAgY29uc3Qgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgc3RyaW5nTGVuZ3RoOyBjKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBzdHJpbmdbY11cbiAgICAgIGlmICghdGhpcy5fY2hhcmFjdGVyV2lkdGhDYWNoZVtjaGFyXSkge1xuICAgICAgICBjb25zdCBjaGFyV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoXG4gICAgICAgIHRoaXMuX2NoYXJhY3RlcldpZHRoQ2FjaGVbY2hhcl0gPSBjaGFyV2lkdGhcbiAgICAgIH1cbiAgICAgIHdpZHRoICs9IHRoaXMuX2NoYXJhY3RlcldpZHRoQ2FjaGVbY2hhcl1cbiAgICB9XG4gICAgcmV0dXJuIHdpZHRoXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICAgKi9cbiAgc2V0VGV4dCAodGV4dCkge1xuICAgIHRoaXMuX3RleHQgPSB0ZXh0XG4gICAgdGhpcy5fbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1heCB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gbWF4V2lkdGhcbiAgICovXG4gIHNldE1heFdpZHRoIChtYXhXaWR0aCkgeyB0aGlzLl9tYXhXaWR0aCA9IG1heFdpZHRoIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dFNwbGl0dGVyXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL29wZXJhdGlvbnMvc3ByaXRlcy90ZXh0L3RleHQtc3BsaXR0ZXIuanNcbiAqKi8iLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgUGhvdG9FZGl0b3JTREsuXG4gKlxuICogQ29weXJpZ2h0IChDKSAyMDE2IDllbGVtZW50cyBHbWJIIDxjb250YWN0QDllbGVtZW50cy5jb20+XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgbGljZW5zZSBhZ3JlZW1lbnRcbiAqIGlzIGFwcHJvdmVkIGFuZCBhIGxlZ2FsL2ZpbmFuY2lhbCBjb250cmFjdCB3YXMgc2lnbmVkIGJ5IHRoZSB1c2VyLlxuICogVGhlIGxpY2Vuc2UgYWdyZWVtZW50IGNhbiBiZSBmb3VuZCB1bmRlciBmb2xsb3dpbmcgbGluazpcbiAqXG4gKiBodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vTElDRU5TRS50eHRcbiAqL1xuXG5pbXBvcnQgeyBQcm9taXNlLCBFbmdpbmUsIFV0aWxzLCBWZWN0b3IyIH0gZnJvbSAnLi4vZ2xvYmFscydcbmltcG9ydCBPcGVyYXRpb24gZnJvbSAnLi9vcGVyYXRpb24nXG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGRyYXcgYSB3YXRlcm1hcmsgb24gdG9wIG9mIHRoZSBpbWFnZVxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBQaG90b0VkaXRvclNESy5PcGVyYXRpb25cbiAqIEBtZW1iZXJvZiBQaG90b0VkaXRvclNESy5PcGVyYXRpb25zXG4gKi9cbmNsYXNzIFdhdGVybWFya09wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFdhdGVybWFya09wZXJhdGlvblxuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG5cbiAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUgPSBuZXcgRW5naW5lLlNwcml0ZSgpXG4gICAgdGhpcy5fd2F0ZXJtYXJrU3ByaXRlLnNldEFuY2hvcigwLjUsIDAuNSlcbiAgICB0aGlzLl9jb250YWluZXIuYWRkQ2hpbGQodGhpcy5fd2F0ZXJtYXJrU3ByaXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHdhdGVybWFya1xuICAgKiBAcGFyYW0gIHtQaG90b0VkaXRvclNES30gc2RrXG4gICAqIEBwcml2YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3JlbmRlciAoc2RrKSB7XG4gICAgaWYgKCF0aGlzLl93YXRlcm1hcmtUZXh0dXJlKSB7XG4gICAgICB0aGlzLl93YXRlcm1hcmtUZXh0dXJlID0gRW5naW5lLlRleHR1cmUuZnJvbUltYWdlKHRoaXMuX29wdGlvbnMuaW1hZ2UpXG4gICAgICB0aGlzLl93YXRlcm1hcmtTcHJpdGUuc2V0VGV4dHVyZSh0aGlzLl93YXRlcm1hcmtUZXh0dXJlKVxuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dFNwcml0ZSA9IHNkay5nZXRTcHJpdGUoKVxuICAgIGNvbnN0IHNwcml0ZUJvdW5kcyA9IG91dHB1dFNwcml0ZS5nZXRCb3VuZHMoKVxuICAgIGNvbnN0IHNwcml0ZURpbWVuc2lvbnMgPSBuZXcgVmVjdG9yMihzcHJpdGVCb3VuZHMud2lkdGgsIHNwcml0ZUJvdW5kcy5oZWlnaHQpXG4gICAgY29uc3QgcmVuZGVyVGV4dHVyZSA9IHRoaXMuX2dldFJlbmRlclRleHR1cmUoc2RrKVxuICAgIHJlbmRlclRleHR1cmUucmVzaXplVG8oc3ByaXRlRGltZW5zaW9ucylcbiAgICB0aGlzLl9zcHJpdGUuc2V0VGV4dHVyZShvdXRwdXRTcHJpdGUuZ2V0VGV4dHVyZSgpKVxuXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLl9vcHRpb25zLmltYWdlXG4gICAgY29uc3QgZGltZW5zaW9ucyA9IFV0aWxzLnJlc2l6ZVZlY3RvclRvRml0KFxuICAgICAgbmV3IFZlY3RvcjIod2lkdGgsIGhlaWdodCksXG4gICAgICBzcHJpdGVEaW1lbnNpb25zXG4gICAgKVxuICAgIHRoaXMuX3dhdGVybWFya1Nwcml0ZS5zZXRQb3NpdGlvbihcbiAgICAgIHNwcml0ZURpbWVuc2lvbnMueCAvIDIsXG4gICAgICBzcHJpdGVEaW1lbnNpb25zLnkgLyAyXG4gICAgKVxuICAgIHRoaXMuX3dhdGVybWFya1Nwcml0ZS5zZXRXaWR0aChkaW1lbnNpb25zLngpXG4gICAgdGhpcy5fd2F0ZXJtYXJrU3ByaXRlLnNldEhlaWdodChkaW1lbnNpb25zLnkpXG5cbiAgICByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLl9jb250YWluZXIpXG5cbiAgICBvdXRwdXRTcHJpdGUuc2V0VGV4dHVyZShyZW5kZXJUZXh0dXJlKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG59XG5cbi8qKlxuICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gKiBvcGVyYXRpb25zLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0XG4gKi9cbldhdGVybWFya09wZXJhdGlvbi5pZGVudGlmaWVyID0gJ3dhdGVybWFyaydcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqIEBpZ25vcmVcbiAqL1xuV2F0ZXJtYXJrT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBpbWFnZTogeyB0eXBlOiAnb2JqZWN0JywgcmVxdWlyZWQ6IHRydWUgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXYXRlcm1hcmtPcGVyYXRpb25cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vb3BlcmF0aW9ucy93YXRlcm1hcmstb3BlcmF0aW9uLmpzXG4gKiovIiwiLyohXG4gKiBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xuICogaHR0cDovL215Lm9wZXJhLmNvbS9lbW9sbGVyL2Jsb2cvMjAxMS8xMi8yMC9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWVyLWFuaW1hdGluZ1xuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsIGJ5IEVyaWsgTcO2bGxlci4gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxuICogTUlUIGxpY2Vuc2VcbiAqL1xuY29uc3Qgcm9vdCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogd2luZG93XG5sZXQgckFGID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbmxldCBjQUYgPSByb290LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG5cbmxldCBsYXN0VGltZSA9IDBcbmNvbnN0IHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddXG5mb3IgKGxldCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFyQUY7ICsreCkge1xuICByQUYgPSByb290W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cbiAgY0FGID0gcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgcm9vdFt2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddXG59XG5cbmlmICghckFGKSB7XG4gIHJBRiA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICBjb25zdCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpXG4gICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKSB9LCB0aW1lVG9DYWxsKVxuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsXG4gICAgcmV0dXJuIGlkXG4gIH1cbn1cblxuaWYgKCFjQUYpIHtcbiAgY0FGID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgY2xlYXJUaW1lb3V0KGlkKVxuICB9XG59XG5cbmV4cG9ydCB7XG4gIHJBRiBhcyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gIGNBRiBhcyBjYW5jZWxBbmltYXRpb25GcmFtZVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi4vc2hhcmVkL2FuaW1hdGlvbi1mcmFtZS5qc1xuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mLmpzXG4gKiogbW9kdWxlIGlkID0gMTY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTcyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKXtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzXG4gKiogbW9kdWxlIGlkID0gMTczXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2Mpe1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE3NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTc2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1xuICoqIG1vZHVsZSBpZCA9IDE4MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpXG4gICwgcElFICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgcmVzdWx0ICAgICA9IGdldEtleXMoaXQpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZihnZXRTeW1ib2xzKXtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpXG4gICAgICAsIGlzRW51bSAgPSBwSUUuZlxuICAgICAgLCBpICAgICAgID0gMFxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUoc3ltYm9scy5sZW5ndGggPiBpKWlmKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKXJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzXG4gKiogbW9kdWxlIGlkID0gMTgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4gKiogbW9kdWxlIGlkID0gMTgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTgzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKXtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpe1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbiAqKiBtb2R1bGUgaWQgPSAxODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19rZXlvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDE4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIE1FVEEgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKVxuICAsIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBoYXMgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgc2V0RGVzYyAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mXG4gICwgaWQgICAgICAgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24oaXQpe1xuICBzZXREZXNjKGl0LCBNRVRBLCB7dmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9fSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbihpdCwgY3JlYXRlKXtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZighaXNPYmplY3QoaXQpKXJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZighY3JlYXRlKXJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIGlmKCFoYXMoaXQsIE1FVEEpKXtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmKCFpc0V4dGVuc2libGUoaXQpKXJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKXNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiAgICAgIE1FVEEsXG4gIE5FRUQ6ICAgICBmYWxzZSxcbiAgZmFzdEtleTogIGZhc3RLZXksXG4gIGdldFdlYWs6ICBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbWV0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDE4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIGRQICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcclxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcclxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcclxuICBhbk9iamVjdChPKTtcclxuICB2YXIga2V5cyAgID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKVxyXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxyXG4gICAgLCBpID0gMFxyXG4gICAgLCBQO1xyXG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcclxuICByZXR1cm4gTztcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzXG4gKiogbW9kdWxlIGlkID0gMTg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QTiAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgdG9TdHJpbmcgID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMTkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxyXG52YXIgaGFzICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxyXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxyXG4gICwgSUVfUFJPVE8gICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJylcclxuICAsIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uKE8pe1xyXG4gIE8gPSB0b09iamVjdChPKTtcclxuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcclxuICBpZih0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKXtcclxuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xyXG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanNcbiAqKiBtb2R1bGUgaWQgPSAxOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUT19TVFJJTkcpe1xuICByZXR1cm4gZnVuY3Rpb24odGhhdCwgcG9zKXtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuICAgICAgLCBpID0gdG9JbnRlZ2VyKHBvcylcbiAgICAgICwgbCA9IHMubGVuZ3RoXG4gICAgICAsIGEsIGI7XG4gICAgaWYoaSA8IDAgfHwgaSA+PSBsKXJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXG4gKiogbW9kdWxlIGlkID0gMTk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpXG4gICwgc3RlcCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgSXRlcmF0b3JzICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwga2luZCAgPSB0aGlzLl9rXG4gICAgLCBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYoa2luZCA9PSAna2V5cycgIClyZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmKGtpbmQgPT0gJ3ZhbHVlcycpcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXHJcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxyXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtjcmVhdGU6IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKX0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XHJcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXHJcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4gKiogbW9kdWxlIGlkID0gMTk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge3NldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXR9KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qc1xuICoqIG1vZHVsZSBpZCA9IDIwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGluZGV4ID0gdGhpcy5faVxuICAgICwgcG9pbnQ7XG4gIGlmKGluZGV4ID49IE8ubGVuZ3RoKXJldHVybiB7dmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZX07XG4gIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcbiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiB7dmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZX07XG59KTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPYmplY3RQcm90byAgICA9IE9iamVjdFtQUk9UT1RZUEVdXG4gICwgVVNFX05BVElWRSAgICAgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nXG4gICwgUU9iamVjdCAgICAgICAgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIF9jcmVhdGUoZFAoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIGRQKHRoaXMsICdhJywge3ZhbHVlOiA3fSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbihpdCwga2V5LCBEKXtcbiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7XG4gIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbih0YWcpe1xuICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzeW0uX2sgPSB0YWc7XG4gIHJldHVybiBzeW07XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKXtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYoaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuICAgIGlmKCFELmVudW1lcmFibGUpe1xuICAgICAgaWYoIWhhcyhpdCwgSElEREVOKSlkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwge2VudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTtcbiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKVxuICAgICwgaSAgICA9IDBcbiAgICAsIGwgPSBrZXlzLmxlbmd0aFxuICAgICwga2V5O1xuICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSl7XG4gIHZhciBEID0gZ09QRChpdCA9IHRvSU9iamVjdChpdCksIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZihEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCl7XG4gIHZhciBuYW1lcyAgPSBnT1BOKHRvSU9iamVjdChpdCkpXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgaSAgICAgID0gMFxuICAgICwga2V5O1xuICB3aGlsZShuYW1lcy5sZW5ndGggPiBpKWlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIERFU0NSSVBUT1JTICYmIHNldHRlciAmJiBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBpZihoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKXRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgIHJldHVybiB0aGlzLl9rO1xuICB9KTtcblxuICAkR09QRC5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgJERQLmYgICA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZihERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKXtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfVxufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cbmZvcih2YXIgc3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzKHN5bWJvbHNbaSsrXSk7XG5cbmZvcih2YXIgc3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGkgPSAwOyBzeW1ib2xzLmxlbmd0aCA+IGk7ICl3a3NEZWZpbmUoc3ltYm9sc1tpKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioa2V5KXtcbiAgICBpZihpc1N5bWJvbChrZXkpKXJldHVybiBrZXlPZihTeW1ib2xSZWdpc3RyeSwga2V5KTtcbiAgICB0aHJvdyBUeXBlRXJyb3Ioa2V5ICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24oKXsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSlcbiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbigpe1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgdmFyIGFyZ3MgPSBbaXRdXG4gICAgICAsIGkgICAgPSAxXG4gICAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUoYXJndW1lbnRzLmxlbmd0aCA+IGkpYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYodHlwZW9mIHJlcGxhY2VyID09ICdmdW5jdGlvbicpJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgaWYoJHJlcGxhY2VyIHx8ICFpc0FycmF5KHJlcGxhY2VyKSlyZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgaWYoJHJlcGxhY2VyKXZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZighaXNTeW1ib2wodmFsdWUpKXJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzXG4gKiogbW9kdWxlIGlkID0gMjAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vYmFiZWwtcnVudGltZS9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyMDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9iYWJlbC1ydW50aW1lL34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKWhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L2JhYmVsLXJ1bnRpbWUvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMjA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCkgKiB2X2NvbG9yO1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vZW5naW5lL3NoYWRlcnMvc291cmNlL3RleHR1cmUuZnJhZ1xuICoqIG1vZHVsZSBpZCA9IDIwN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnVuaWZvcm0gbWF0MyB1X3Byb2pNYXRyaXg7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X3Byb2pNYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSwgMCwgMSk7XFxuICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcXG4gIHZfY29sb3IgPSB2ZWM0KGFfY29sb3IucmdiICogYV9jb2xvci5hLCBhX2NvbG9yLmEpO1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vZW5naW5lL3NoYWRlcnMvc291cmNlL3RleHR1cmUudmVydFxuICoqIG1vZHVsZSBpZCA9IDIwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iL21hc3Rlci9zcmMvZmlsdGVycy9ibHVyL3RpbHRzaGlmdC5qc1xcbiAqL1xcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X2JsdXJSYWRpdXM7XFxudW5pZm9ybSBmbG9hdCB1X2dyYWRpZW50U2l6ZTtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZTtcXG51bmlmb3JtIHZlYzIgdV9zdGFydDtcXG51bmlmb3JtIHZlYzIgdV9lbmQ7XFxudW5pZm9ybSB2ZWMyIHVfZGVsdGE7XFxudW5pZm9ybSB2ZWMyIHVfdGV4U2l6ZTtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG5cXG5mbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZCkge1xcbiAgcmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiArIHNlZWQsIHNjYWxlKSkgKiA0Mzc1OC41NDUzICsgc2VlZCk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbSh2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpLCAwLjApO1xcblxcbiAgICB2ZWMyIG5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMyKHVfc3RhcnQueSAtIHVfZW5kLnksIHVfZW5kLnggLSB1X3N0YXJ0LngpKTtcXG4gICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCxcXG4gICAgICAoYWJzKFxcbiAgICAgICAgZG90KHZfdGV4Q29vcmQgKiB1X3RleFNpemUgLSB1X3N0YXJ0LCBub3JtYWwpXFxuICAgICAgKSAtIHVfc2l6ZSkgLyB1X2dyYWRpZW50U2l6ZVxcbiAgICApICogdV9ibHVyUmFkaXVzO1xcblxcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIHVfZGVsdGEgKiBwZXJjZW50ICogcmFkaXVzIC8gdV90ZXhTaXplKTtcXG5cXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuXFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAvPSBnbF9GcmFnQ29sb3IuYSArIDAuMDAwMDE7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL2ZvY3VzL2xpbmVhci1mb2N1cy5mcmFnXG4gKiogbW9kdWxlIGlkID0gMjA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogQmFzZWQgb24gZXZhbncncyBnbGZ4LmpzIHRpbHQgc2hpZnQgc2hhZGVyOlxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzL2Jsb2IvbWFzdGVyL3NyYy9maWx0ZXJzL2JsdXIvdGlsdHNoaWZ0LmpzXFxuICovXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfcmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgdV9ibHVyUmFkaXVzO1xcbnVuaWZvcm0gZmxvYXQgdV9ncmFkaWVudFJhZGl1cztcXG51bmlmb3JtIHZlYzIgdV9wb3NpdGlvbjtcXG51bmlmb3JtIHZlYzIgdV9kZWx0YTtcXG51bmlmb3JtIHZlYzIgdV90ZXhTaXplO1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcblxcbmZsb2F0IHJhbmRvbSh2ZWMzIHNjYWxlLCBmbG9hdCBzZWVkKSB7XFxuICByZXR1cm4gZnJhY3Qoc2luKGRvdChnbF9GcmFnQ29vcmQueHl6ICsgc2VlZCwgc2NhbGUpKSAqIDQzNzU4LjU0NTMgKyBzZWVkKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xcbiAgICBmbG9hdCB0b3RhbCA9IDAuMDtcXG5cXG4gICAgZmxvYXQgb2Zmc2V0ID0gcmFuZG9tKHZlYzMoMTIuOTg5OCwgNzguMjMzLCAxNTEuNzE4MiksIDAuMCk7XFxuICAgIGZsb2F0IHJhZGl1cyA9IHNtb290aHN0ZXAoXFxuICAgICAgMC4wLCAxLjAsXFxuICAgICAgKGFicyhcXG4gICAgICAgIGRpc3RhbmNlKHZfdGV4Q29vcmQgKiB1X3RleFNpemUsIHVfcG9zaXRpb24pXFxuICAgICAgKSAtIHVfcmFkaXVzKSAvICh1X2dyYWRpZW50UmFkaXVzICogMi4wKVxcbiAgICApICogdV9ibHVyUmFkaXVzO1xcbiAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcXG4gICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIHVfZGVsdGEgKiBwZXJjZW50ICogcmFkaXVzIC8gdV90ZXhTaXplKTtcXG5cXG4gICAgICAgIHNhbXBsZS5yZ2IgKj0gc2FtcGxlLmE7XFxuXFxuICAgICAgICBjb2xvciArPSBzYW1wbGUgKiB3ZWlnaHQ7XFxuICAgICAgICB0b3RhbCArPSB3ZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgLyB0b3RhbDtcXG4gICAgZ2xfRnJhZ0NvbG9yLnJnYiAvPSBnbF9GcmFnQ29sb3IuYSArIDAuMDAwMDE7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL2ZvY3VzL3JhZGlhbC1mb2N1cy5mcmFnXG4gKiogbW9kdWxlIGlkID0gMjEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfYnJpZ2h0bmVzcztcXG51bmlmb3JtIGZsb2F0IHVfc2F0dXJhdGlvbjtcXG51bmlmb3JtIGZsb2F0IHVfY29udHJhc3Q7XFxuY29uc3QgdmVjMyBsdW1pbmFuY2VXZWlnaHRpbmcgPSB2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuXFxuICB2ZWM0IGNvbG9yID0gdGV4Q29sb3I7XFxuXFxuICAvLyBBcHBseSBicmlnaHRuZXNzXFxuICBjb2xvci5yZ2IgPSAoY29sb3IucmdiICsgdV9icmlnaHRuZXNzKTtcXG5cXG4gIC8vIEFwcGx5IHNhdHVyYXRpb25cXG4gIGZsb2F0IGx1bWluYW5jZSA9IGRvdChjb2xvci5yZ2IsIGx1bWluYW5jZVdlaWdodGluZyk7XFxuICB2ZWMzIGdyZXlTY2FsZUNvbG9yID0gdmVjMyhsdW1pbmFuY2UpO1xcbiAgY29sb3IucmdiID0gbWl4KGdyZXlTY2FsZUNvbG9yLCBjb2xvci5yZ2IsIHVfc2F0dXJhdGlvbik7XFxuXFxuICAvLyBBcHBseSBjb250cmFzdFxcbiAgY29sb3IucmdiID0gKGNvbG9yLnJnYiAtIDAuNSkgKiB1X2NvbnRyYXN0ICsgMC41O1xcblxcbiAgLy8gQXBwbHkgYWxwaGFcXG4gIGNvbG9yID0gdmVjNChjb2xvci5yZ2IgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9nZW5lcmljL2FkanVzdG1lbnRzLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZmlsdGVyZWRJbWFnZTtcXG51bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdmVjNCBjb2xvcjEgPSB0ZXh0dXJlMkQodV9maWx0ZXJlZEltYWdlLCB2X3RleENvb3JkKTtcXG4gIGdsX0ZyYWdDb2xvciA9IG1peChjb2xvcjAsIGNvbG9yMSwgdV9pbnRlbnNpdHkpO1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9nZW5lcmljL2JsZW5kLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfZnJhbWVJbWFnZTtcXG51bmlmb3JtIHZlYzQgdV9jb2xvcjtcXG51bmlmb3JtIGZsb2F0IHVfdGhpY2tuZXNzO1xcbnVuaWZvcm0gdmVjMiB1X3RleHR1cmVTaXplO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgZnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgc2NhbGVkVGhpY2tuZXNzWCA9IHVfdGhpY2tuZXNzIC8gdV90ZXh0dXJlU2l6ZS54O1xcbiAgZmxvYXQgc2NhbGVkVGhpY2tuZXNzWSA9IHVfdGhpY2tuZXNzIC8gdV90ZXh0dXJlU2l6ZS55O1xcbiAgaWYgKHZfdGV4Q29vcmQueCA8IHNjYWxlZFRoaWNrbmVzc1ggfHxcXG4gICAgdl90ZXhDb29yZC54ID4gMS4wIC0gc2NhbGVkVGhpY2tuZXNzWCB8fFxcbiAgICB2X3RleENvb3JkLnkgPCBzY2FsZWRUaGlja25lc3NZIHx8IHZfdGV4Q29vcmQueSA+IDEuMCAtIHNjYWxlZFRoaWNrbmVzc1kpIHtcXG4gICAgICBmcmFnQ29sb3IgPSBtaXgoZnJhZ0NvbG9yLCB1X2NvbG9yLCB1X2NvbG9yLmEpO1xcbiAgICB9XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBmcmFnQ29sb3I7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL29wZXJhdGlvbnMvYm9yZGVyLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9icmlnaHRuZXNzO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCh0ZXhDb2xvci5yZ2IgKyB2ZWMzKHVfYnJpZ2h0bmVzcykgKiB0ZXhDb2xvci5hKSwgdGV4Q29sb3IuYSk7O1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL2JyaWdodG5lc3MuZnJhZ1xuICoqIG1vZHVsZSBpZCA9IDIxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X2NvbnRyYXN0O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCgodGV4Q29sb3IucmdiIC0gdmVjMygwLjUpKSAqIHVfY29udHJhc3QgKyB2ZWMzKDAuNSkgKiB0ZXhDb2xvci5hKSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvY29udHJhc3QuZnJhZ1xuICoqIG1vZHVsZSBpZCA9IDIxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBmbG9hdCB1X2Rlc2F0dXJhdGlvbjtcXG5cXG5jb25zdCB2ZWMzIGx1bWluYW5jZVdlaWdodGluZyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIHZlYzMgZ3JheVhmZXIgPSB2ZWMzKDAuMywgMC41OSwgMC4xMSk7XFxuICB2ZWMzIGdyYXkgPSB2ZWMzKGRvdChncmF5WGZlciwgdGV4Q29sb3IueHl6KSk7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peCh0ZXhDb2xvci54eXosIGdyYXksIHVfZGVzYXR1cmF0aW9uKSAqIHRleENvbG9yLmEsIHRleENvbG9yLmEpO1xcbn1cXG5cIlxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL3Nhc2gvZGV2ZWxvcG1lbnQvanMvcGVzZGstaHRtbDUvfi9yYXctbG9hZGVyIS4vc2hhZGVycy9wcmltaXRpdmVzL2Rlc2F0dXJhdGlvbi5mcmFnXG4gKiogbW9kdWxlIGlkID0gMjE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcblxcbiAgdmVjMiB0ZXh0dXJlQ29vcmQgPSB2X3RleENvb3JkIC0gdmVjMigwLjUsIDAuNSk7XFxuICB0ZXh0dXJlQ29vcmQgLz0gMC43NTtcXG5cXG4gIGZsb2F0IGQgPSAxLjAgLSBkb3QodGV4dHVyZUNvb3JkLCB0ZXh0dXJlQ29vcmQpO1xcbiAgZCA9IGNsYW1wKGQsIDAuMiwgMS4wKTtcXG4gIHZlYzMgbmV3Q29sb3IgPSB0ZXhDb2xvci5yZ2IgKiBkICogdV9jb2xvci5yZ2I7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobmV3Q29sb3IpICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvZ2xvdy5mcmFnXG4gKiogbW9kdWxlIGlkID0gMjE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdGV4Q29sb3IuYiA9IHRleENvbG9yLmcgKiAwLjMzO1xcbiAgdGV4Q29sb3IuciA9IHRleENvbG9yLnIgKiAwLjY7XFxuICB0ZXhDb2xvci5iICs9IHRleENvbG9yLnIgKiAwLjMzO1xcbiAgdGV4Q29sb3IuZyA9IHRleENvbG9yLmcgKiAwLjc7XFxuICBnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcXG59XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnZlYzMgVyA9IHZlYzMoMC4yMTI1LCAwLjcxNTQsIDAuMDcyMSk7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gIGZsb2F0IGx1bWluYW5jZSA9IGRvdCh0ZXhDb2xvci5yZ2IsIFcpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKGx1bWluYW5jZSkgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy9ncmF5c2NhbGUuZnJhZ1xuICoqIG1vZHVsZSBpZCA9IDIxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9sb29rdXBUYWJsZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgciA9IHRleHR1cmUyRCh1X2xvb2t1cFRhYmxlLCB2ZWMyKHRleENvbG9yLnIsIDAuMCkpLnI7XFxuICBmbG9hdCBnID0gdGV4dHVyZTJEKHVfbG9va3VwVGFibGUsIHZlYzIodGV4Q29sb3IuZywgMC4wKSkuZztcXG4gIGZsb2F0IGIgPSB0ZXh0dXJlMkQodV9sb29rdXBUYWJsZSwgdmVjMih0ZXhDb2xvci5iLCAwLjApKS5iO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHIsIGcsIGIpICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvbG9va3VwLXRhYmxlLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbnVuaWZvcm0gZmxvYXQgdV9zYXR1cmF0aW9uO1xcblxcbmNvbnN0IHZlYzMgbHVtaW5hbmNlV2VpZ2h0aW5nID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLnJnYiwgbHVtaW5hbmNlV2VpZ2h0aW5nKTtcXG5cXG4gIHZlYzMgZ3JleVNjYWxlQ29sb3IgPSB2ZWMzKGx1bWluYW5jZSk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KG1peChncmV5U2NhbGVDb2xvciwgdGV4Q29sb3IucmdiLCB1X3NhdHVyYXRpb24pICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc2F0dXJhdGlvbi5mcmFnXG4gKiogbW9kdWxlIGlkID0gMjIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG51bmlmb3JtIHZlYzMgdV9jb2xvcjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgdmVjNCBvdmVybGF5VmVjNCA9IHZlYzQodV9jb2xvciwgdGV4Q29sb3IuYSk7XFxuICBnbF9GcmFnQ29sb3IgPSBtYXgob3ZlcmxheVZlYzQgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvcik7XFxufVxcblwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvc2FzaC9kZXZlbG9wbWVudC9qcy9wZXNkay1odG1sNS9+L3Jhdy1sb2FkZXIhLi9zaGFkZXJzL3ByaW1pdGl2ZXMvc29mdC1jb2xvci1vdmVybGF5LmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMjJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG51bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICBmbG9hdCBncmF5ID0gdGV4Q29sb3IuciAqIDAuMyArIHRleENvbG9yLmcgKiAwLjMgKyB0ZXhDb2xvci5iICogMC4zO1xcbiAgZ3JheSAtPSAwLjI7XFxuICBncmF5ID0gY2xhbXAoZ3JheSwgMC4wLCAxLjApO1xcbiAgZ3JheSArPSAwLjE1O1xcbiAgZ3JheSAqPSAxLjQ7XFxuICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoZ3JheSkgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG59XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9zYXNoL2RldmVsb3BtZW50L2pzL3Blc2RrLWh0bWw1L34vcmF3LWxvYWRlciEuL3NoYWRlcnMvcHJpbWl0aXZlcy94NDAwLmZyYWdcbiAqKiBtb2R1bGUgaWQgPSAyMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=